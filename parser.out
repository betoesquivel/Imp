Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> config body
Rule 2     config -> configdirective config
Rule 3     config -> empty
Rule 4     configdirective -> VARSCONFIG = options
Rule 5     configdirective -> DECISIONSCONFIG = options
Rule 6     configdirective -> COMPLEXITYCONFIG = optionsyesno
Rule 7     options -> SOME
Rule 8     options -> ALL
Rule 9     options -> MOST
Rule 10    options -> NONE
Rule 11    optionsyesno -> YES
Rule 12    optionsyesno -> NO
Rule 13    body -> declarationsOpt funcsOpt main funcsOpt
Rule 14    funcsOpt -> suprafunc funcsOpt
Rule 15    funcsOpt -> empty
Rule 16    declarationsOpt -> declaration declarationsOpt
Rule 17    declarationsOpt -> empty
Rule 18    declaration -> type declarationB declarationC
Rule 19    declarationB -> ID dimensionsOpt
Rule 20    declarationC -> = superexpression declarationD
Rule 21    declarationC -> , declarationB declarationC
Rule 22    declarationC -> ;
Rule 23    declarationD -> , declarationB declarationC
Rule 24    declarationD -> ;
Rule 25    main -> MAIN ( ) block
Rule 26    suprafunc -> func block
Rule 27    func -> DEF returntype ID ( paramsOpt )
Rule 28    paramsOpt -> params paramsB
Rule 29    paramsOpt -> empty
Rule 30    block -> { instructionsOpt }
Rule 31    instructionsOpt -> instruction instructionsOpt
Rule 32    instructionsOpt -> empty
Rule 33    assign -> ID dimensionsOpt = superexpression
Rule 34    assignB -> dimensionsOpt = superexpression
Rule 35    dimensionsOpt -> dimensions
Rule 36    dimensionsOpt -> empty
Rule 37    condition -> IF ( superexpression ) block else
Rule 38    else -> ELSE block
Rule 39    else -> empty
Rule 40    instruction -> assignfunccall ;
Rule 41    instruction -> output ;
Rule 42    instruction -> return ;
Rule 43    instruction -> input ;
Rule 44    instruction -> declaration
Rule 45    instruction -> condition
Rule 46    instruction -> whileloop
Rule 47    instruction -> forloop
Rule 48    instruction -> localdirective
Rule 49    assignfunccall -> ID assignfunccallB
Rule 50    assignfunccallB -> ( funccallB funccallC
Rule 51    assignfunccallB -> assignB
Rule 52    localdirective -> localvardirective
Rule 53    localdirective -> localdecisiondirective
Rule 54    localdirective -> localmsgdirective
Rule 55    superexpression -> expression superexpressionB
Rule 56    superexpressionB -> & & superexpression
Rule 57    superexpressionB -> | | superexpression
Rule 58    superexpressionB -> empty
Rule 59    expression -> exp expressionB
Rule 60    expressionB -> < exp
Rule 61    expressionB -> > exp
Rule 62    expressionB -> < > exp
Rule 63    expressionB -> = = exp
Rule 64    expressionB -> < = exp
Rule 65    expressionB -> > = exp
Rule 66    expressionB -> empty
Rule 67    exp -> term expB
Rule 68    expB -> - exp
Rule 69    expB -> + exp
Rule 70    expB -> empty
Rule 71    term -> factor termB
Rule 72    termB -> / term
Rule 73    termB -> * term
Rule 74    termB -> empty
Rule 75    factor -> signB constant
Rule 76    factor -> ( superexpression )
Rule 77    factor -> funccall
Rule 78    factor -> ID seen_ID dimensionsOpt
Rule 79    seen_ID -> <empty>
Rule 80    signB -> sign
Rule 81    signB -> empty
Rule 82    constant -> FCONST
Rule 83    constant -> ICONST
Rule 84    constant -> SCONST
Rule 85    constant -> TRUE
Rule 86    constant -> FALSE
Rule 87    sign -> +
Rule 88    sign -> -
Rule 89    whileloop -> WHILE ( superexpression ) block
Rule 90    type -> INT
Rule 91    type -> FLOAT
Rule 92    type -> STRING
Rule 93    type -> BOOL
Rule 94    returntype -> VOID
Rule 95    returntype -> type
Rule 96    forloop -> FOR ( assign ; superexpression ; superexpression ) block
Rule 97    input -> INPUT ( ID inputB )
Rule 98    inputB -> , ID inputB
Rule 99    inputB -> empty
Rule 100   output -> PRINT ( outputB
Rule 101   outputB -> SCONST outputC
Rule 102   outputB -> superexpression outputC
Rule 103   outputC -> )
Rule 104   outputC -> , outputB
Rule 105   localvardirective -> # localvardirectiveB ID
Rule 106   localvardirectiveB -> TRACK
Rule 107   localvardirectiveB -> FORGET
Rule 108   localmsgdirective -> # SHOW SCONST
Rule 109   localdecisiondirective -> TRACKDECISION
Rule 110   localdecisiondirective -> FORGETDECISION
Rule 111   localdecisiondirective -> empty
Rule 112   funccall -> ID ( funccallB funccallC
Rule 113   funccallB -> superexpression
Rule 114   funccallB -> empty
Rule 115   funccallC -> , funccallB funccallC
Rule 116   funccallC -> )
Rule 117   dimensions -> [ superexpression ] dimensionsB
Rule 118   dimensionsB -> [ superexpression ]
Rule 119   dimensionsB -> empty
Rule 120   return -> RETURN superexpression
Rule 121   params -> type ID
Rule 122   paramsB -> , params paramsB
Rule 123   paramsB -> empty
Rule 124   empty -> <empty>

Terminals, with rules where they appear

#                    : 105 108
&                    : 56 56
(                    : 25 27 37 50 76 89 96 97 100 112
)                    : 25 27 37 76 89 96 97 103 116
*                    : 73
+                    : 69 87
,                    : 21 23 98 104 115 122
-                    : 68 88
/                    : 72
;                    : 22 24 40 41 42 43 96 96
<                    : 60 62 64
=                    : 4 5 6 20 33 34 63 63 64 65
>                    : 61 62 65
ALL                  : 8
BOOL                 : 93
COMPLEXITYCONFIG     : 6
DECISIONSCONFIG      : 5
DEF                  : 27
ELSE                 : 38
FALSE                : 86
FCONST               : 82
FLOAT                : 91
FOR                  : 96
FORGET               : 107
FORGETDECISION       : 110
ICONST               : 83
ID                   : 19 27 33 49 78 97 98 105 112 121
IF                   : 37
INPUT                : 97
INT                  : 90
MAIN                 : 25
MOST                 : 9
NO                   : 12
NONE                 : 10
PRINT                : 100
RETURN               : 120
SCONST               : 84 101 108
SHOW                 : 108
SOME                 : 7
STRING               : 92
TRACK                : 106
TRACKDECISION        : 109
TRUE                 : 85
VARSCONFIG           : 4
VOID                 : 94
WHILE                : 89
YES                  : 11
[                    : 117 118
]                    : 117 118
error                : 
{                    : 30
|                    : 57 57
}                    : 30

Nonterminals, with rules where they appear

assign               : 96
assignB              : 51
assignfunccall       : 40
assignfunccallB      : 49
block                : 25 26 37 38 89 96
body                 : 1
condition            : 45
config               : 1 2
configdirective      : 2
constant             : 75
declaration          : 16 44
declarationB         : 18 21 23
declarationC         : 18 21 23
declarationD         : 20
declarationsOpt      : 13 16
dimensions           : 35
dimensionsB          : 117
dimensionsOpt        : 19 33 34 78
else                 : 37
empty                : 3 15 17 29 32 36 39 58 66 70 74 81 99 111 114 119 123
exp                  : 59 60 61 62 63 64 65 68 69
expB                 : 67
expression           : 55
expressionB          : 59
factor               : 71
forloop              : 47
func                 : 26
funccall             : 77
funccallB            : 50 112 115
funccallC            : 50 112 115
funcsOpt             : 13 13 14
input                : 43
inputB               : 97 98
instruction          : 31
instructionsOpt      : 30 31
localdecisiondirective : 53
localdirective       : 48
localmsgdirective    : 54
localvardirective    : 52
localvardirectiveB   : 105
main                 : 13
options              : 4 5
optionsyesno         : 6
output               : 41
outputB              : 100 104
outputC              : 101 102
params               : 28 122
paramsB              : 28 122
paramsOpt            : 27
program              : 0
return               : 42
returntype           : 27
seen_ID              : 78
sign                 : 80
signB                : 75
superexpression      : 20 33 34 37 56 57 76 89 96 96 102 113 117 118 120
superexpressionB     : 55
suprafunc            : 14
term                 : 67 72 73
termB                : 71
type                 : 18 95 121
whileloop            : 46

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . config body
    (2) config -> . configdirective config
    (3) config -> . empty
    (4) configdirective -> . VARSCONFIG = options
    (5) configdirective -> . DECISIONSCONFIG = options
    (6) configdirective -> . COMPLEXITYCONFIG = optionsyesno
    (124) empty -> .

    VARSCONFIG      shift and go to state 2
    DECISIONSCONFIG shift and go to state 1
    COMPLEXITYCONFIG shift and go to state 4
    INT             reduce using rule 124 (empty -> .)
    FLOAT           reduce using rule 124 (empty -> .)
    STRING          reduce using rule 124 (empty -> .)
    BOOL            reduce using rule 124 (empty -> .)
    DEF             reduce using rule 124 (empty -> .)
    MAIN            reduce using rule 124 (empty -> .)

    configdirective                shift and go to state 3
    program                        shift and go to state 5
    config                         shift and go to state 6
    empty                          shift and go to state 7

state 1

    (5) configdirective -> DECISIONSCONFIG . = options

    =               shift and go to state 8


state 2

    (4) configdirective -> VARSCONFIG . = options

    =               shift and go to state 9


state 3

    (2) config -> configdirective . config
    (2) config -> . configdirective config
    (3) config -> . empty
    (4) configdirective -> . VARSCONFIG = options
    (5) configdirective -> . DECISIONSCONFIG = options
    (6) configdirective -> . COMPLEXITYCONFIG = optionsyesno
    (124) empty -> .

    VARSCONFIG      shift and go to state 2
    DECISIONSCONFIG shift and go to state 1
    COMPLEXITYCONFIG shift and go to state 4
    INT             reduce using rule 124 (empty -> .)
    FLOAT           reduce using rule 124 (empty -> .)
    STRING          reduce using rule 124 (empty -> .)
    BOOL            reduce using rule 124 (empty -> .)
    DEF             reduce using rule 124 (empty -> .)
    MAIN            reduce using rule 124 (empty -> .)

    config                         shift and go to state 10
    empty                          shift and go to state 7
    configdirective                shift and go to state 3

state 4

    (6) configdirective -> COMPLEXITYCONFIG . = optionsyesno

    =               shift and go to state 11


state 5

    (0) S' -> program .



state 6

    (1) program -> config . body
    (13) body -> . declarationsOpt funcsOpt main funcsOpt
    (16) declarationsOpt -> . declaration declarationsOpt
    (17) declarationsOpt -> . empty
    (18) declaration -> . type declarationB declarationC
    (124) empty -> .
    (90) type -> . INT
    (91) type -> . FLOAT
    (92) type -> . STRING
    (93) type -> . BOOL

    DEF             reduce using rule 124 (empty -> .)
    MAIN            reduce using rule 124 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18

    body                           shift and go to state 12
    declarationsOpt                shift and go to state 13
    type                           shift and go to state 16
    declaration                    shift and go to state 19
    empty                          shift and go to state 20

state 7

    (3) config -> empty .

    INT             reduce using rule 3 (config -> empty .)
    FLOAT           reduce using rule 3 (config -> empty .)
    STRING          reduce using rule 3 (config -> empty .)
    BOOL            reduce using rule 3 (config -> empty .)
    DEF             reduce using rule 3 (config -> empty .)
    MAIN            reduce using rule 3 (config -> empty .)


state 8

    (5) configdirective -> DECISIONSCONFIG = . options
    (7) options -> . SOME
    (8) options -> . ALL
    (9) options -> . MOST
    (10) options -> . NONE

    SOME            shift and go to state 22
    ALL             shift and go to state 21
    MOST            shift and go to state 24
    NONE            shift and go to state 23

    options                        shift and go to state 25

state 9

    (4) configdirective -> VARSCONFIG = . options
    (7) options -> . SOME
    (8) options -> . ALL
    (9) options -> . MOST
    (10) options -> . NONE

    SOME            shift and go to state 22
    ALL             shift and go to state 21
    MOST            shift and go to state 24
    NONE            shift and go to state 23

    options                        shift and go to state 26

state 10

    (2) config -> configdirective config .

    INT             reduce using rule 2 (config -> configdirective config .)
    FLOAT           reduce using rule 2 (config -> configdirective config .)
    STRING          reduce using rule 2 (config -> configdirective config .)
    BOOL            reduce using rule 2 (config -> configdirective config .)
    DEF             reduce using rule 2 (config -> configdirective config .)
    MAIN            reduce using rule 2 (config -> configdirective config .)


state 11

    (6) configdirective -> COMPLEXITYCONFIG = . optionsyesno
    (11) optionsyesno -> . YES
    (12) optionsyesno -> . NO

    YES             shift and go to state 27
    NO              shift and go to state 29

    optionsyesno                   shift and go to state 28

state 12

    (1) program -> config body .

    $end            reduce using rule 1 (program -> config body .)


state 13

    (13) body -> declarationsOpt . funcsOpt main funcsOpt
    (14) funcsOpt -> . suprafunc funcsOpt
    (15) funcsOpt -> . empty
    (26) suprafunc -> . func block
    (124) empty -> .
    (27) func -> . DEF returntype ID ( paramsOpt )

    MAIN            reduce using rule 124 (empty -> .)
    DEF             shift and go to state 33

    suprafunc                      shift and go to state 30
    funcsOpt                       shift and go to state 31
    func                           shift and go to state 32
    empty                          shift and go to state 34

state 14

    (92) type -> STRING .

    ID              reduce using rule 92 (type -> STRING .)


state 15

    (90) type -> INT .

    ID              reduce using rule 90 (type -> INT .)


state 16

    (18) declaration -> type . declarationB declarationC
    (19) declarationB -> . ID dimensionsOpt

    ID              shift and go to state 36

    declarationB                   shift and go to state 35

state 17

    (91) type -> FLOAT .

    ID              reduce using rule 91 (type -> FLOAT .)


state 18

    (93) type -> BOOL .

    ID              reduce using rule 93 (type -> BOOL .)


state 19

    (16) declarationsOpt -> declaration . declarationsOpt
    (16) declarationsOpt -> . declaration declarationsOpt
    (17) declarationsOpt -> . empty
    (18) declaration -> . type declarationB declarationC
    (124) empty -> .
    (90) type -> . INT
    (91) type -> . FLOAT
    (92) type -> . STRING
    (93) type -> . BOOL

    DEF             reduce using rule 124 (empty -> .)
    MAIN            reduce using rule 124 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18

    declarationsOpt                shift and go to state 37
    declaration                    shift and go to state 19
    type                           shift and go to state 16
    empty                          shift and go to state 20

state 20

    (17) declarationsOpt -> empty .

    DEF             reduce using rule 17 (declarationsOpt -> empty .)
    MAIN            reduce using rule 17 (declarationsOpt -> empty .)


state 21

    (8) options -> ALL .

    VARSCONFIG      reduce using rule 8 (options -> ALL .)
    DECISIONSCONFIG reduce using rule 8 (options -> ALL .)
    COMPLEXITYCONFIG reduce using rule 8 (options -> ALL .)
    INT             reduce using rule 8 (options -> ALL .)
    FLOAT           reduce using rule 8 (options -> ALL .)
    STRING          reduce using rule 8 (options -> ALL .)
    BOOL            reduce using rule 8 (options -> ALL .)
    DEF             reduce using rule 8 (options -> ALL .)
    MAIN            reduce using rule 8 (options -> ALL .)


state 22

    (7) options -> SOME .

    VARSCONFIG      reduce using rule 7 (options -> SOME .)
    DECISIONSCONFIG reduce using rule 7 (options -> SOME .)
    COMPLEXITYCONFIG reduce using rule 7 (options -> SOME .)
    INT             reduce using rule 7 (options -> SOME .)
    FLOAT           reduce using rule 7 (options -> SOME .)
    STRING          reduce using rule 7 (options -> SOME .)
    BOOL            reduce using rule 7 (options -> SOME .)
    DEF             reduce using rule 7 (options -> SOME .)
    MAIN            reduce using rule 7 (options -> SOME .)


state 23

    (10) options -> NONE .

    VARSCONFIG      reduce using rule 10 (options -> NONE .)
    DECISIONSCONFIG reduce using rule 10 (options -> NONE .)
    COMPLEXITYCONFIG reduce using rule 10 (options -> NONE .)
    INT             reduce using rule 10 (options -> NONE .)
    FLOAT           reduce using rule 10 (options -> NONE .)
    STRING          reduce using rule 10 (options -> NONE .)
    BOOL            reduce using rule 10 (options -> NONE .)
    DEF             reduce using rule 10 (options -> NONE .)
    MAIN            reduce using rule 10 (options -> NONE .)


state 24

    (9) options -> MOST .

    VARSCONFIG      reduce using rule 9 (options -> MOST .)
    DECISIONSCONFIG reduce using rule 9 (options -> MOST .)
    COMPLEXITYCONFIG reduce using rule 9 (options -> MOST .)
    INT             reduce using rule 9 (options -> MOST .)
    FLOAT           reduce using rule 9 (options -> MOST .)
    STRING          reduce using rule 9 (options -> MOST .)
    BOOL            reduce using rule 9 (options -> MOST .)
    DEF             reduce using rule 9 (options -> MOST .)
    MAIN            reduce using rule 9 (options -> MOST .)


state 25

    (5) configdirective -> DECISIONSCONFIG = options .

    VARSCONFIG      reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    DECISIONSCONFIG reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    COMPLEXITYCONFIG reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    INT             reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    FLOAT           reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    STRING          reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    BOOL            reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    DEF             reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    MAIN            reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)


state 26

    (4) configdirective -> VARSCONFIG = options .

    VARSCONFIG      reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    DECISIONSCONFIG reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    COMPLEXITYCONFIG reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    INT             reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    FLOAT           reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    STRING          reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    BOOL            reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    DEF             reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    MAIN            reduce using rule 4 (configdirective -> VARSCONFIG = options .)


state 27

    (11) optionsyesno -> YES .

    VARSCONFIG      reduce using rule 11 (optionsyesno -> YES .)
    DECISIONSCONFIG reduce using rule 11 (optionsyesno -> YES .)
    COMPLEXITYCONFIG reduce using rule 11 (optionsyesno -> YES .)
    INT             reduce using rule 11 (optionsyesno -> YES .)
    FLOAT           reduce using rule 11 (optionsyesno -> YES .)
    STRING          reduce using rule 11 (optionsyesno -> YES .)
    BOOL            reduce using rule 11 (optionsyesno -> YES .)
    DEF             reduce using rule 11 (optionsyesno -> YES .)
    MAIN            reduce using rule 11 (optionsyesno -> YES .)


state 28

    (6) configdirective -> COMPLEXITYCONFIG = optionsyesno .

    VARSCONFIG      reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    DECISIONSCONFIG reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    COMPLEXITYCONFIG reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    INT             reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    FLOAT           reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    STRING          reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    BOOL            reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    DEF             reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    MAIN            reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)


state 29

    (12) optionsyesno -> NO .

    VARSCONFIG      reduce using rule 12 (optionsyesno -> NO .)
    DECISIONSCONFIG reduce using rule 12 (optionsyesno -> NO .)
    COMPLEXITYCONFIG reduce using rule 12 (optionsyesno -> NO .)
    INT             reduce using rule 12 (optionsyesno -> NO .)
    FLOAT           reduce using rule 12 (optionsyesno -> NO .)
    STRING          reduce using rule 12 (optionsyesno -> NO .)
    BOOL            reduce using rule 12 (optionsyesno -> NO .)
    DEF             reduce using rule 12 (optionsyesno -> NO .)
    MAIN            reduce using rule 12 (optionsyesno -> NO .)


state 30

    (14) funcsOpt -> suprafunc . funcsOpt
    (14) funcsOpt -> . suprafunc funcsOpt
    (15) funcsOpt -> . empty
    (26) suprafunc -> . func block
    (124) empty -> .
    (27) func -> . DEF returntype ID ( paramsOpt )

    MAIN            reduce using rule 124 (empty -> .)
    $end            reduce using rule 124 (empty -> .)
    DEF             shift and go to state 33

    suprafunc                      shift and go to state 30
    funcsOpt                       shift and go to state 38
    empty                          shift and go to state 34
    func                           shift and go to state 32

state 31

    (13) body -> declarationsOpt funcsOpt . main funcsOpt
    (25) main -> . MAIN ( ) block

    MAIN            shift and go to state 39

    main                           shift and go to state 40

state 32

    (26) suprafunc -> func . block
    (30) block -> . { instructionsOpt }

    {               shift and go to state 41

    block                          shift and go to state 42

state 33

    (27) func -> DEF . returntype ID ( paramsOpt )
    (94) returntype -> . VOID
    (95) returntype -> . type
    (90) type -> . INT
    (91) type -> . FLOAT
    (92) type -> . STRING
    (93) type -> . BOOL

    VOID            shift and go to state 43
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18

    returntype                     shift and go to state 44
    type                           shift and go to state 45

state 34

    (15) funcsOpt -> empty .

    MAIN            reduce using rule 15 (funcsOpt -> empty .)
    $end            reduce using rule 15 (funcsOpt -> empty .)


state 35

    (18) declaration -> type declarationB . declarationC
    (20) declarationC -> . = superexpression declarationD
    (21) declarationC -> . , declarationB declarationC
    (22) declarationC -> . ;

    =               shift and go to state 48
    ,               shift and go to state 46
    ;               shift and go to state 49

    declarationC                   shift and go to state 47

state 36

    (19) declarationB -> ID . dimensionsOpt
    (35) dimensionsOpt -> . dimensions
    (36) dimensionsOpt -> . empty
    (117) dimensions -> . [ superexpression ] dimensionsB
    (124) empty -> .

    [               shift and go to state 51
    =               reduce using rule 124 (empty -> .)
    ,               reduce using rule 124 (empty -> .)
    ;               reduce using rule 124 (empty -> .)

    dimensionsOpt                  shift and go to state 52
    dimensions                     shift and go to state 50
    empty                          shift and go to state 53

state 37

    (16) declarationsOpt -> declaration declarationsOpt .

    DEF             reduce using rule 16 (declarationsOpt -> declaration declarationsOpt .)
    MAIN            reduce using rule 16 (declarationsOpt -> declaration declarationsOpt .)


state 38

    (14) funcsOpt -> suprafunc funcsOpt .

    MAIN            reduce using rule 14 (funcsOpt -> suprafunc funcsOpt .)
    $end            reduce using rule 14 (funcsOpt -> suprafunc funcsOpt .)


state 39

    (25) main -> MAIN . ( ) block

    (               shift and go to state 54


state 40

    (13) body -> declarationsOpt funcsOpt main . funcsOpt
    (14) funcsOpt -> . suprafunc funcsOpt
    (15) funcsOpt -> . empty
    (26) suprafunc -> . func block
    (124) empty -> .
    (27) func -> . DEF returntype ID ( paramsOpt )

    $end            reduce using rule 124 (empty -> .)
    DEF             shift and go to state 33

    suprafunc                      shift and go to state 30
    funcsOpt                       shift and go to state 55
    func                           shift and go to state 32
    empty                          shift and go to state 34

state 41

    (30) block -> { . instructionsOpt }
    (31) instructionsOpt -> . instruction instructionsOpt
    (32) instructionsOpt -> . empty
    (40) instruction -> . assignfunccall ;
    (41) instruction -> . output ;
    (42) instruction -> . return ;
    (43) instruction -> . input ;
    (44) instruction -> . declaration
    (45) instruction -> . condition
    (46) instruction -> . whileloop
    (47) instruction -> . forloop
    (48) instruction -> . localdirective
    (124) empty -> .
    (49) assignfunccall -> . ID assignfunccallB
    (100) output -> . PRINT ( outputB
    (120) return -> . RETURN superexpression
    (97) input -> . INPUT ( ID inputB )
    (18) declaration -> . type declarationB declarationC
    (37) condition -> . IF ( superexpression ) block else
    (89) whileloop -> . WHILE ( superexpression ) block
    (96) forloop -> . FOR ( assign ; superexpression ; superexpression ) block
    (52) localdirective -> . localvardirective
    (53) localdirective -> . localdecisiondirective
    (54) localdirective -> . localmsgdirective
    (90) type -> . INT
    (91) type -> . FLOAT
    (92) type -> . STRING
    (93) type -> . BOOL
    (105) localvardirective -> . # localvardirectiveB ID
    (109) localdecisiondirective -> . TRACKDECISION
    (110) localdecisiondirective -> . FORGETDECISION
    (111) localdecisiondirective -> . empty
    (108) localmsgdirective -> . # SHOW SCONST

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for TRACKDECISION resolved as shift
  ! shift/reduce conflict for FORGETDECISION resolved as shift
    }               reduce using rule 124 (empty -> .)
    ID              shift and go to state 74
    PRINT           shift and go to state 59
    RETURN          shift and go to state 56
    INPUT           shift and go to state 73
    IF              shift and go to state 76
    WHILE           shift and go to state 58
    FOR             shift and go to state 68
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18
    #               shift and go to state 61
    TRACKDECISION   shift and go to state 63
    FORGETDECISION  shift and go to state 70

  ! ID              [ reduce using rule 124 (empty -> .) ]
  ! PRINT           [ reduce using rule 124 (empty -> .) ]
  ! RETURN          [ reduce using rule 124 (empty -> .) ]
  ! INPUT           [ reduce using rule 124 (empty -> .) ]
  ! IF              [ reduce using rule 124 (empty -> .) ]
  ! WHILE           [ reduce using rule 124 (empty -> .) ]
  ! FOR             [ reduce using rule 124 (empty -> .) ]
  ! INT             [ reduce using rule 124 (empty -> .) ]
  ! FLOAT           [ reduce using rule 124 (empty -> .) ]
  ! STRING          [ reduce using rule 124 (empty -> .) ]
  ! BOOL            [ reduce using rule 124 (empty -> .) ]
  ! #               [ reduce using rule 124 (empty -> .) ]
  ! TRACKDECISION   [ reduce using rule 124 (empty -> .) ]
  ! FORGETDECISION  [ reduce using rule 124 (empty -> .) ]

    assignfunccall                 shift and go to state 57
    whileloop                      shift and go to state 60
    localvardirective              shift and go to state 62
    input                          shift and go to state 64
    type                           shift and go to state 16
    empty                          shift and go to state 65
    forloop                        shift and go to state 66
    return                         shift and go to state 67
    instructionsOpt                shift and go to state 69
    localdirective                 shift and go to state 71
    declaration                    shift and go to state 72
    condition                      shift and go to state 75
    instruction                    shift and go to state 77
    localmsgdirective              shift and go to state 78
    localdecisiondirective         shift and go to state 79
    output                         shift and go to state 80

state 42

    (26) suprafunc -> func block .

    DEF             reduce using rule 26 (suprafunc -> func block .)
    $end            reduce using rule 26 (suprafunc -> func block .)
    MAIN            reduce using rule 26 (suprafunc -> func block .)


state 43

    (94) returntype -> VOID .

    ID              reduce using rule 94 (returntype -> VOID .)


state 44

    (27) func -> DEF returntype . ID ( paramsOpt )

    ID              shift and go to state 81


state 45

    (95) returntype -> type .

    ID              reduce using rule 95 (returntype -> type .)


state 46

    (21) declarationC -> , . declarationB declarationC
    (19) declarationB -> . ID dimensionsOpt

    ID              shift and go to state 36

    declarationB                   shift and go to state 82

state 47

    (18) declaration -> type declarationB declarationC .

    INT             reduce using rule 18 (declaration -> type declarationB declarationC .)
    FLOAT           reduce using rule 18 (declaration -> type declarationB declarationC .)
    STRING          reduce using rule 18 (declaration -> type declarationB declarationC .)
    BOOL            reduce using rule 18 (declaration -> type declarationB declarationC .)
    DEF             reduce using rule 18 (declaration -> type declarationB declarationC .)
    MAIN            reduce using rule 18 (declaration -> type declarationB declarationC .)
    ID              reduce using rule 18 (declaration -> type declarationB declarationC .)
    PRINT           reduce using rule 18 (declaration -> type declarationB declarationC .)
    RETURN          reduce using rule 18 (declaration -> type declarationB declarationC .)
    INPUT           reduce using rule 18 (declaration -> type declarationB declarationC .)
    IF              reduce using rule 18 (declaration -> type declarationB declarationC .)
    WHILE           reduce using rule 18 (declaration -> type declarationB declarationC .)
    FOR             reduce using rule 18 (declaration -> type declarationB declarationC .)
    #               reduce using rule 18 (declaration -> type declarationB declarationC .)
    TRACKDECISION   reduce using rule 18 (declaration -> type declarationB declarationC .)
    FORGETDECISION  reduce using rule 18 (declaration -> type declarationB declarationC .)
    }               reduce using rule 18 (declaration -> type declarationB declarationC .)


state 48

    (20) declarationC -> = . superexpression declarationD
    (55) superexpression -> . expression superexpressionB
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 91
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95
    empty                          shift and go to state 89

state 49

    (22) declarationC -> ; .

    INT             reduce using rule 22 (declarationC -> ; .)
    FLOAT           reduce using rule 22 (declarationC -> ; .)
    STRING          reduce using rule 22 (declarationC -> ; .)
    BOOL            reduce using rule 22 (declarationC -> ; .)
    DEF             reduce using rule 22 (declarationC -> ; .)
    MAIN            reduce using rule 22 (declarationC -> ; .)
    ID              reduce using rule 22 (declarationC -> ; .)
    PRINT           reduce using rule 22 (declarationC -> ; .)
    RETURN          reduce using rule 22 (declarationC -> ; .)
    INPUT           reduce using rule 22 (declarationC -> ; .)
    IF              reduce using rule 22 (declarationC -> ; .)
    WHILE           reduce using rule 22 (declarationC -> ; .)
    FOR             reduce using rule 22 (declarationC -> ; .)
    #               reduce using rule 22 (declarationC -> ; .)
    TRACKDECISION   reduce using rule 22 (declarationC -> ; .)
    FORGETDECISION  reduce using rule 22 (declarationC -> ; .)
    }               reduce using rule 22 (declarationC -> ; .)


state 50

    (35) dimensionsOpt -> dimensions .

    =               reduce using rule 35 (dimensionsOpt -> dimensions .)
    /               reduce using rule 35 (dimensionsOpt -> dimensions .)
    *               reduce using rule 35 (dimensionsOpt -> dimensions .)
    -               reduce using rule 35 (dimensionsOpt -> dimensions .)
    +               reduce using rule 35 (dimensionsOpt -> dimensions .)
    <               reduce using rule 35 (dimensionsOpt -> dimensions .)
    >               reduce using rule 35 (dimensionsOpt -> dimensions .)
    &               reduce using rule 35 (dimensionsOpt -> dimensions .)
    |               reduce using rule 35 (dimensionsOpt -> dimensions .)
    ,               reduce using rule 35 (dimensionsOpt -> dimensions .)
    ;               reduce using rule 35 (dimensionsOpt -> dimensions .)
    ]               reduce using rule 35 (dimensionsOpt -> dimensions .)
    )               reduce using rule 35 (dimensionsOpt -> dimensions .)


state 51

    (117) dimensions -> [ . superexpression ] dimensionsB
    (55) superexpression -> . expression superexpressionB
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 96
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95
    empty                          shift and go to state 89

state 52

    (19) declarationB -> ID dimensionsOpt .

    =               reduce using rule 19 (declarationB -> ID dimensionsOpt .)
    ,               reduce using rule 19 (declarationB -> ID dimensionsOpt .)
    ;               reduce using rule 19 (declarationB -> ID dimensionsOpt .)


state 53

    (36) dimensionsOpt -> empty .

    =               reduce using rule 36 (dimensionsOpt -> empty .)
    /               reduce using rule 36 (dimensionsOpt -> empty .)
    *               reduce using rule 36 (dimensionsOpt -> empty .)
    -               reduce using rule 36 (dimensionsOpt -> empty .)
    +               reduce using rule 36 (dimensionsOpt -> empty .)
    <               reduce using rule 36 (dimensionsOpt -> empty .)
    >               reduce using rule 36 (dimensionsOpt -> empty .)
    &               reduce using rule 36 (dimensionsOpt -> empty .)
    |               reduce using rule 36 (dimensionsOpt -> empty .)
    ,               reduce using rule 36 (dimensionsOpt -> empty .)
    ;               reduce using rule 36 (dimensionsOpt -> empty .)
    ]               reduce using rule 36 (dimensionsOpt -> empty .)
    )               reduce using rule 36 (dimensionsOpt -> empty .)


state 54

    (25) main -> MAIN ( . ) block

    )               shift and go to state 97


state 55

    (13) body -> declarationsOpt funcsOpt main funcsOpt .

    $end            reduce using rule 13 (body -> declarationsOpt funcsOpt main funcsOpt .)


state 56

    (120) return -> RETURN . superexpression
    (55) superexpression -> . expression superexpressionB
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 98
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95
    empty                          shift and go to state 89

state 57

    (40) instruction -> assignfunccall . ;

    ;               shift and go to state 99


state 58

    (89) whileloop -> WHILE . ( superexpression ) block

    (               shift and go to state 100


state 59

    (100) output -> PRINT . ( outputB

    (               shift and go to state 101


state 60

    (46) instruction -> whileloop .

    ID              reduce using rule 46 (instruction -> whileloop .)
    PRINT           reduce using rule 46 (instruction -> whileloop .)
    RETURN          reduce using rule 46 (instruction -> whileloop .)
    INPUT           reduce using rule 46 (instruction -> whileloop .)
    IF              reduce using rule 46 (instruction -> whileloop .)
    WHILE           reduce using rule 46 (instruction -> whileloop .)
    FOR             reduce using rule 46 (instruction -> whileloop .)
    INT             reduce using rule 46 (instruction -> whileloop .)
    FLOAT           reduce using rule 46 (instruction -> whileloop .)
    STRING          reduce using rule 46 (instruction -> whileloop .)
    BOOL            reduce using rule 46 (instruction -> whileloop .)
    #               reduce using rule 46 (instruction -> whileloop .)
    TRACKDECISION   reduce using rule 46 (instruction -> whileloop .)
    FORGETDECISION  reduce using rule 46 (instruction -> whileloop .)
    }               reduce using rule 46 (instruction -> whileloop .)


state 61

    (105) localvardirective -> # . localvardirectiveB ID
    (108) localmsgdirective -> # . SHOW SCONST
    (106) localvardirectiveB -> . TRACK
    (107) localvardirectiveB -> . FORGET

    SHOW            shift and go to state 103
    TRACK           shift and go to state 104
    FORGET          shift and go to state 102

    localvardirectiveB             shift and go to state 105

state 62

    (52) localdirective -> localvardirective .

    ID              reduce using rule 52 (localdirective -> localvardirective .)
    PRINT           reduce using rule 52 (localdirective -> localvardirective .)
    RETURN          reduce using rule 52 (localdirective -> localvardirective .)
    INPUT           reduce using rule 52 (localdirective -> localvardirective .)
    IF              reduce using rule 52 (localdirective -> localvardirective .)
    WHILE           reduce using rule 52 (localdirective -> localvardirective .)
    FOR             reduce using rule 52 (localdirective -> localvardirective .)
    INT             reduce using rule 52 (localdirective -> localvardirective .)
    FLOAT           reduce using rule 52 (localdirective -> localvardirective .)
    STRING          reduce using rule 52 (localdirective -> localvardirective .)
    BOOL            reduce using rule 52 (localdirective -> localvardirective .)
    #               reduce using rule 52 (localdirective -> localvardirective .)
    TRACKDECISION   reduce using rule 52 (localdirective -> localvardirective .)
    FORGETDECISION  reduce using rule 52 (localdirective -> localvardirective .)
    }               reduce using rule 52 (localdirective -> localvardirective .)


state 63

    (109) localdecisiondirective -> TRACKDECISION .

    ID              reduce using rule 109 (localdecisiondirective -> TRACKDECISION .)
    PRINT           reduce using rule 109 (localdecisiondirective -> TRACKDECISION .)
    RETURN          reduce using rule 109 (localdecisiondirective -> TRACKDECISION .)
    INPUT           reduce using rule 109 (localdecisiondirective -> TRACKDECISION .)
    IF              reduce using rule 109 (localdecisiondirective -> TRACKDECISION .)
    WHILE           reduce using rule 109 (localdecisiondirective -> TRACKDECISION .)
    FOR             reduce using rule 109 (localdecisiondirective -> TRACKDECISION .)
    INT             reduce using rule 109 (localdecisiondirective -> TRACKDECISION .)
    FLOAT           reduce using rule 109 (localdecisiondirective -> TRACKDECISION .)
    STRING          reduce using rule 109 (localdecisiondirective -> TRACKDECISION .)
    BOOL            reduce using rule 109 (localdecisiondirective -> TRACKDECISION .)
    #               reduce using rule 109 (localdecisiondirective -> TRACKDECISION .)
    TRACKDECISION   reduce using rule 109 (localdecisiondirective -> TRACKDECISION .)
    FORGETDECISION  reduce using rule 109 (localdecisiondirective -> TRACKDECISION .)
    }               reduce using rule 109 (localdecisiondirective -> TRACKDECISION .)


state 64

    (43) instruction -> input . ;

    ;               shift and go to state 106


state 65

    (32) instructionsOpt -> empty .
    (111) localdecisiondirective -> empty .

  ! reduce/reduce conflict for } resolved using rule 32 (instructionsOpt -> empty .)
    }               reduce using rule 32 (instructionsOpt -> empty .)
    ID              reduce using rule 111 (localdecisiondirective -> empty .)
    PRINT           reduce using rule 111 (localdecisiondirective -> empty .)
    RETURN          reduce using rule 111 (localdecisiondirective -> empty .)
    INPUT           reduce using rule 111 (localdecisiondirective -> empty .)
    IF              reduce using rule 111 (localdecisiondirective -> empty .)
    WHILE           reduce using rule 111 (localdecisiondirective -> empty .)
    FOR             reduce using rule 111 (localdecisiondirective -> empty .)
    INT             reduce using rule 111 (localdecisiondirective -> empty .)
    FLOAT           reduce using rule 111 (localdecisiondirective -> empty .)
    STRING          reduce using rule 111 (localdecisiondirective -> empty .)
    BOOL            reduce using rule 111 (localdecisiondirective -> empty .)
    #               reduce using rule 111 (localdecisiondirective -> empty .)
    TRACKDECISION   reduce using rule 111 (localdecisiondirective -> empty .)
    FORGETDECISION  reduce using rule 111 (localdecisiondirective -> empty .)

  ! }               [ reduce using rule 111 (localdecisiondirective -> empty .) ]


state 66

    (47) instruction -> forloop .

    ID              reduce using rule 47 (instruction -> forloop .)
    PRINT           reduce using rule 47 (instruction -> forloop .)
    RETURN          reduce using rule 47 (instruction -> forloop .)
    INPUT           reduce using rule 47 (instruction -> forloop .)
    IF              reduce using rule 47 (instruction -> forloop .)
    WHILE           reduce using rule 47 (instruction -> forloop .)
    FOR             reduce using rule 47 (instruction -> forloop .)
    INT             reduce using rule 47 (instruction -> forloop .)
    FLOAT           reduce using rule 47 (instruction -> forloop .)
    STRING          reduce using rule 47 (instruction -> forloop .)
    BOOL            reduce using rule 47 (instruction -> forloop .)
    #               reduce using rule 47 (instruction -> forloop .)
    TRACKDECISION   reduce using rule 47 (instruction -> forloop .)
    FORGETDECISION  reduce using rule 47 (instruction -> forloop .)
    }               reduce using rule 47 (instruction -> forloop .)


state 67

    (42) instruction -> return . ;

    ;               shift and go to state 107


state 68

    (96) forloop -> FOR . ( assign ; superexpression ; superexpression ) block

    (               shift and go to state 108


state 69

    (30) block -> { instructionsOpt . }

    }               shift and go to state 109


state 70

    (110) localdecisiondirective -> FORGETDECISION .

    ID              reduce using rule 110 (localdecisiondirective -> FORGETDECISION .)
    PRINT           reduce using rule 110 (localdecisiondirective -> FORGETDECISION .)
    RETURN          reduce using rule 110 (localdecisiondirective -> FORGETDECISION .)
    INPUT           reduce using rule 110 (localdecisiondirective -> FORGETDECISION .)
    IF              reduce using rule 110 (localdecisiondirective -> FORGETDECISION .)
    WHILE           reduce using rule 110 (localdecisiondirective -> FORGETDECISION .)
    FOR             reduce using rule 110 (localdecisiondirective -> FORGETDECISION .)
    INT             reduce using rule 110 (localdecisiondirective -> FORGETDECISION .)
    FLOAT           reduce using rule 110 (localdecisiondirective -> FORGETDECISION .)
    STRING          reduce using rule 110 (localdecisiondirective -> FORGETDECISION .)
    BOOL            reduce using rule 110 (localdecisiondirective -> FORGETDECISION .)
    #               reduce using rule 110 (localdecisiondirective -> FORGETDECISION .)
    TRACKDECISION   reduce using rule 110 (localdecisiondirective -> FORGETDECISION .)
    FORGETDECISION  reduce using rule 110 (localdecisiondirective -> FORGETDECISION .)
    }               reduce using rule 110 (localdecisiondirective -> FORGETDECISION .)


state 71

    (48) instruction -> localdirective .

    ID              reduce using rule 48 (instruction -> localdirective .)
    PRINT           reduce using rule 48 (instruction -> localdirective .)
    RETURN          reduce using rule 48 (instruction -> localdirective .)
    INPUT           reduce using rule 48 (instruction -> localdirective .)
    IF              reduce using rule 48 (instruction -> localdirective .)
    WHILE           reduce using rule 48 (instruction -> localdirective .)
    FOR             reduce using rule 48 (instruction -> localdirective .)
    INT             reduce using rule 48 (instruction -> localdirective .)
    FLOAT           reduce using rule 48 (instruction -> localdirective .)
    STRING          reduce using rule 48 (instruction -> localdirective .)
    BOOL            reduce using rule 48 (instruction -> localdirective .)
    #               reduce using rule 48 (instruction -> localdirective .)
    TRACKDECISION   reduce using rule 48 (instruction -> localdirective .)
    FORGETDECISION  reduce using rule 48 (instruction -> localdirective .)
    }               reduce using rule 48 (instruction -> localdirective .)


state 72

    (44) instruction -> declaration .

    ID              reduce using rule 44 (instruction -> declaration .)
    PRINT           reduce using rule 44 (instruction -> declaration .)
    RETURN          reduce using rule 44 (instruction -> declaration .)
    INPUT           reduce using rule 44 (instruction -> declaration .)
    IF              reduce using rule 44 (instruction -> declaration .)
    WHILE           reduce using rule 44 (instruction -> declaration .)
    FOR             reduce using rule 44 (instruction -> declaration .)
    INT             reduce using rule 44 (instruction -> declaration .)
    FLOAT           reduce using rule 44 (instruction -> declaration .)
    STRING          reduce using rule 44 (instruction -> declaration .)
    BOOL            reduce using rule 44 (instruction -> declaration .)
    #               reduce using rule 44 (instruction -> declaration .)
    TRACKDECISION   reduce using rule 44 (instruction -> declaration .)
    FORGETDECISION  reduce using rule 44 (instruction -> declaration .)
    }               reduce using rule 44 (instruction -> declaration .)


state 73

    (97) input -> INPUT . ( ID inputB )

    (               shift and go to state 110


state 74

    (49) assignfunccall -> ID . assignfunccallB
    (50) assignfunccallB -> . ( funccallB funccallC
    (51) assignfunccallB -> . assignB
    (34) assignB -> . dimensionsOpt = superexpression
    (35) dimensionsOpt -> . dimensions
    (36) dimensionsOpt -> . empty
    (117) dimensions -> . [ superexpression ] dimensionsB
    (124) empty -> .

    (               shift and go to state 112
    [               shift and go to state 51
    =               reduce using rule 124 (empty -> .)

    dimensions                     shift and go to state 50
    assignfunccallB                shift and go to state 111
    assignB                        shift and go to state 113
    dimensionsOpt                  shift and go to state 114
    empty                          shift and go to state 53

state 75

    (45) instruction -> condition .

    ID              reduce using rule 45 (instruction -> condition .)
    PRINT           reduce using rule 45 (instruction -> condition .)
    RETURN          reduce using rule 45 (instruction -> condition .)
    INPUT           reduce using rule 45 (instruction -> condition .)
    IF              reduce using rule 45 (instruction -> condition .)
    WHILE           reduce using rule 45 (instruction -> condition .)
    FOR             reduce using rule 45 (instruction -> condition .)
    INT             reduce using rule 45 (instruction -> condition .)
    FLOAT           reduce using rule 45 (instruction -> condition .)
    STRING          reduce using rule 45 (instruction -> condition .)
    BOOL            reduce using rule 45 (instruction -> condition .)
    #               reduce using rule 45 (instruction -> condition .)
    TRACKDECISION   reduce using rule 45 (instruction -> condition .)
    FORGETDECISION  reduce using rule 45 (instruction -> condition .)
    }               reduce using rule 45 (instruction -> condition .)


state 76

    (37) condition -> IF . ( superexpression ) block else

    (               shift and go to state 115


state 77

    (31) instructionsOpt -> instruction . instructionsOpt
    (31) instructionsOpt -> . instruction instructionsOpt
    (32) instructionsOpt -> . empty
    (40) instruction -> . assignfunccall ;
    (41) instruction -> . output ;
    (42) instruction -> . return ;
    (43) instruction -> . input ;
    (44) instruction -> . declaration
    (45) instruction -> . condition
    (46) instruction -> . whileloop
    (47) instruction -> . forloop
    (48) instruction -> . localdirective
    (124) empty -> .
    (49) assignfunccall -> . ID assignfunccallB
    (100) output -> . PRINT ( outputB
    (120) return -> . RETURN superexpression
    (97) input -> . INPUT ( ID inputB )
    (18) declaration -> . type declarationB declarationC
    (37) condition -> . IF ( superexpression ) block else
    (89) whileloop -> . WHILE ( superexpression ) block
    (96) forloop -> . FOR ( assign ; superexpression ; superexpression ) block
    (52) localdirective -> . localvardirective
    (53) localdirective -> . localdecisiondirective
    (54) localdirective -> . localmsgdirective
    (90) type -> . INT
    (91) type -> . FLOAT
    (92) type -> . STRING
    (93) type -> . BOOL
    (105) localvardirective -> . # localvardirectiveB ID
    (109) localdecisiondirective -> . TRACKDECISION
    (110) localdecisiondirective -> . FORGETDECISION
    (111) localdecisiondirective -> . empty
    (108) localmsgdirective -> . # SHOW SCONST

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for TRACKDECISION resolved as shift
  ! shift/reduce conflict for FORGETDECISION resolved as shift
    }               reduce using rule 124 (empty -> .)
    ID              shift and go to state 74
    PRINT           shift and go to state 59
    RETURN          shift and go to state 56
    INPUT           shift and go to state 73
    IF              shift and go to state 76
    WHILE           shift and go to state 58
    FOR             shift and go to state 68
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18
    #               shift and go to state 61
    TRACKDECISION   shift and go to state 63
    FORGETDECISION  shift and go to state 70

  ! ID              [ reduce using rule 124 (empty -> .) ]
  ! PRINT           [ reduce using rule 124 (empty -> .) ]
  ! RETURN          [ reduce using rule 124 (empty -> .) ]
  ! INPUT           [ reduce using rule 124 (empty -> .) ]
  ! IF              [ reduce using rule 124 (empty -> .) ]
  ! WHILE           [ reduce using rule 124 (empty -> .) ]
  ! FOR             [ reduce using rule 124 (empty -> .) ]
  ! INT             [ reduce using rule 124 (empty -> .) ]
  ! FLOAT           [ reduce using rule 124 (empty -> .) ]
  ! STRING          [ reduce using rule 124 (empty -> .) ]
  ! BOOL            [ reduce using rule 124 (empty -> .) ]
  ! #               [ reduce using rule 124 (empty -> .) ]
  ! TRACKDECISION   [ reduce using rule 124 (empty -> .) ]
  ! FORGETDECISION  [ reduce using rule 124 (empty -> .) ]

    assignfunccall                 shift and go to state 57
    whileloop                      shift and go to state 60
    localvardirective              shift and go to state 62
    input                          shift and go to state 64
    type                           shift and go to state 16
    empty                          shift and go to state 65
    forloop                        shift and go to state 66
    return                         shift and go to state 67
    instructionsOpt                shift and go to state 116
    localdirective                 shift and go to state 71
    declaration                    shift and go to state 72
    condition                      shift and go to state 75
    instruction                    shift and go to state 77
    localmsgdirective              shift and go to state 78
    localdecisiondirective         shift and go to state 79
    output                         shift and go to state 80

state 78

    (54) localdirective -> localmsgdirective .

    ID              reduce using rule 54 (localdirective -> localmsgdirective .)
    PRINT           reduce using rule 54 (localdirective -> localmsgdirective .)
    RETURN          reduce using rule 54 (localdirective -> localmsgdirective .)
    INPUT           reduce using rule 54 (localdirective -> localmsgdirective .)
    IF              reduce using rule 54 (localdirective -> localmsgdirective .)
    WHILE           reduce using rule 54 (localdirective -> localmsgdirective .)
    FOR             reduce using rule 54 (localdirective -> localmsgdirective .)
    INT             reduce using rule 54 (localdirective -> localmsgdirective .)
    FLOAT           reduce using rule 54 (localdirective -> localmsgdirective .)
    STRING          reduce using rule 54 (localdirective -> localmsgdirective .)
    BOOL            reduce using rule 54 (localdirective -> localmsgdirective .)
    #               reduce using rule 54 (localdirective -> localmsgdirective .)
    TRACKDECISION   reduce using rule 54 (localdirective -> localmsgdirective .)
    FORGETDECISION  reduce using rule 54 (localdirective -> localmsgdirective .)
    }               reduce using rule 54 (localdirective -> localmsgdirective .)


state 79

    (53) localdirective -> localdecisiondirective .

    ID              reduce using rule 53 (localdirective -> localdecisiondirective .)
    PRINT           reduce using rule 53 (localdirective -> localdecisiondirective .)
    RETURN          reduce using rule 53 (localdirective -> localdecisiondirective .)
    INPUT           reduce using rule 53 (localdirective -> localdecisiondirective .)
    IF              reduce using rule 53 (localdirective -> localdecisiondirective .)
    WHILE           reduce using rule 53 (localdirective -> localdecisiondirective .)
    FOR             reduce using rule 53 (localdirective -> localdecisiondirective .)
    INT             reduce using rule 53 (localdirective -> localdecisiondirective .)
    FLOAT           reduce using rule 53 (localdirective -> localdecisiondirective .)
    STRING          reduce using rule 53 (localdirective -> localdecisiondirective .)
    BOOL            reduce using rule 53 (localdirective -> localdecisiondirective .)
    #               reduce using rule 53 (localdirective -> localdecisiondirective .)
    TRACKDECISION   reduce using rule 53 (localdirective -> localdecisiondirective .)
    FORGETDECISION  reduce using rule 53 (localdirective -> localdecisiondirective .)
    }               reduce using rule 53 (localdirective -> localdecisiondirective .)


state 80

    (41) instruction -> output . ;

    ;               shift and go to state 117


state 81

    (27) func -> DEF returntype ID . ( paramsOpt )

    (               shift and go to state 118


state 82

    (21) declarationC -> , declarationB . declarationC
    (20) declarationC -> . = superexpression declarationD
    (21) declarationC -> . , declarationB declarationC
    (22) declarationC -> . ;

    =               shift and go to state 48
    ,               shift and go to state 46
    ;               shift and go to state 49

    declarationC                   shift and go to state 119

state 83

    (80) signB -> sign .

    FCONST          reduce using rule 80 (signB -> sign .)
    ICONST          reduce using rule 80 (signB -> sign .)
    SCONST          reduce using rule 80 (signB -> sign .)
    TRUE            reduce using rule 80 (signB -> sign .)
    FALSE           reduce using rule 80 (signB -> sign .)


state 84

    (75) factor -> signB . constant
    (82) constant -> . FCONST
    (83) constant -> . ICONST
    (84) constant -> . SCONST
    (85) constant -> . TRUE
    (86) constant -> . FALSE

    FCONST          shift and go to state 121
    ICONST          shift and go to state 123
    SCONST          shift and go to state 122
    TRUE            shift and go to state 125
    FALSE           shift and go to state 124

    constant                       shift and go to state 120

state 85

    (76) factor -> ( . superexpression )
    (55) superexpression -> . expression superexpressionB
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 126
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95
    empty                          shift and go to state 89

state 86

    (87) sign -> + .

    FCONST          reduce using rule 87 (sign -> + .)
    ICONST          reduce using rule 87 (sign -> + .)
    SCONST          reduce using rule 87 (sign -> + .)
    TRUE            reduce using rule 87 (sign -> + .)
    FALSE           reduce using rule 87 (sign -> + .)


state 87

    (88) sign -> - .

    FCONST          reduce using rule 88 (sign -> - .)
    ICONST          reduce using rule 88 (sign -> - .)
    SCONST          reduce using rule 88 (sign -> - .)
    TRUE            reduce using rule 88 (sign -> - .)
    FALSE           reduce using rule 88 (sign -> - .)


state 88

    (71) term -> factor . termB
    (72) termB -> . / term
    (73) termB -> . * term
    (74) termB -> . empty
    (124) empty -> .

    /               shift and go to state 128
    *               shift and go to state 127
    -               reduce using rule 124 (empty -> .)
    +               reduce using rule 124 (empty -> .)
    <               reduce using rule 124 (empty -> .)
    >               reduce using rule 124 (empty -> .)
    =               reduce using rule 124 (empty -> .)
    &               reduce using rule 124 (empty -> .)
    |               reduce using rule 124 (empty -> .)
    ,               reduce using rule 124 (empty -> .)
    ;               reduce using rule 124 (empty -> .)
    ]               reduce using rule 124 (empty -> .)
    )               reduce using rule 124 (empty -> .)

    termB                          shift and go to state 129
    empty                          shift and go to state 130

state 89

    (81) signB -> empty .

    FCONST          reduce using rule 81 (signB -> empty .)
    ICONST          reduce using rule 81 (signB -> empty .)
    SCONST          reduce using rule 81 (signB -> empty .)
    TRUE            reduce using rule 81 (signB -> empty .)
    FALSE           reduce using rule 81 (signB -> empty .)


state 90

    (77) factor -> funccall .

    /               reduce using rule 77 (factor -> funccall .)
    *               reduce using rule 77 (factor -> funccall .)
    -               reduce using rule 77 (factor -> funccall .)
    +               reduce using rule 77 (factor -> funccall .)
    <               reduce using rule 77 (factor -> funccall .)
    >               reduce using rule 77 (factor -> funccall .)
    =               reduce using rule 77 (factor -> funccall .)
    &               reduce using rule 77 (factor -> funccall .)
    |               reduce using rule 77 (factor -> funccall .)
    ,               reduce using rule 77 (factor -> funccall .)
    ;               reduce using rule 77 (factor -> funccall .)
    ]               reduce using rule 77 (factor -> funccall .)
    )               reduce using rule 77 (factor -> funccall .)


state 91

    (20) declarationC -> = superexpression . declarationD
    (23) declarationD -> . , declarationB declarationC
    (24) declarationD -> . ;

    ,               shift and go to state 131
    ;               shift and go to state 133

    declarationD                   shift and go to state 132

state 92

    (78) factor -> ID . seen_ID dimensionsOpt
    (112) funccall -> ID . ( funccallB funccallC
    (79) seen_ID -> .

    (               shift and go to state 134
    [               reduce using rule 79 (seen_ID -> .)
    /               reduce using rule 79 (seen_ID -> .)
    *               reduce using rule 79 (seen_ID -> .)
    -               reduce using rule 79 (seen_ID -> .)
    +               reduce using rule 79 (seen_ID -> .)
    <               reduce using rule 79 (seen_ID -> .)
    >               reduce using rule 79 (seen_ID -> .)
    =               reduce using rule 79 (seen_ID -> .)
    &               reduce using rule 79 (seen_ID -> .)
    |               reduce using rule 79 (seen_ID -> .)
    ,               reduce using rule 79 (seen_ID -> .)
    ;               reduce using rule 79 (seen_ID -> .)
    ]               reduce using rule 79 (seen_ID -> .)
    )               reduce using rule 79 (seen_ID -> .)

    seen_ID                        shift and go to state 135

state 93

    (67) exp -> term . expB
    (68) expB -> . - exp
    (69) expB -> . + exp
    (70) expB -> . empty
    (124) empty -> .

    -               shift and go to state 137
    +               shift and go to state 136
    <               reduce using rule 124 (empty -> .)
    >               reduce using rule 124 (empty -> .)
    =               reduce using rule 124 (empty -> .)
    &               reduce using rule 124 (empty -> .)
    |               reduce using rule 124 (empty -> .)
    ,               reduce using rule 124 (empty -> .)
    ;               reduce using rule 124 (empty -> .)
    ]               reduce using rule 124 (empty -> .)
    )               reduce using rule 124 (empty -> .)

    expB                           shift and go to state 138
    empty                          shift and go to state 139

state 94

    (59) expression -> exp . expressionB
    (60) expressionB -> . < exp
    (61) expressionB -> . > exp
    (62) expressionB -> . < > exp
    (63) expressionB -> . = = exp
    (64) expressionB -> . < = exp
    (65) expressionB -> . > = exp
    (66) expressionB -> . empty
    (124) empty -> .

    <               shift and go to state 142
    >               shift and go to state 144
    =               shift and go to state 141
    &               reduce using rule 124 (empty -> .)
    |               reduce using rule 124 (empty -> .)
    ,               reduce using rule 124 (empty -> .)
    ;               reduce using rule 124 (empty -> .)
    ]               reduce using rule 124 (empty -> .)
    )               reduce using rule 124 (empty -> .)

    expressionB                    shift and go to state 140
    empty                          shift and go to state 143

state 95

    (55) superexpression -> expression . superexpressionB
    (56) superexpressionB -> . & & superexpression
    (57) superexpressionB -> . | | superexpression
    (58) superexpressionB -> . empty
    (124) empty -> .

    &               shift and go to state 145
    |               shift and go to state 147
    ,               reduce using rule 124 (empty -> .)
    ;               reduce using rule 124 (empty -> .)
    ]               reduce using rule 124 (empty -> .)
    )               reduce using rule 124 (empty -> .)

    empty                          shift and go to state 148
    superexpressionB               shift and go to state 146

state 96

    (117) dimensions -> [ superexpression . ] dimensionsB

    ]               shift and go to state 149


state 97

    (25) main -> MAIN ( ) . block
    (30) block -> . { instructionsOpt }

    {               shift and go to state 41

    block                          shift and go to state 150

state 98

    (120) return -> RETURN superexpression .

    ;               reduce using rule 120 (return -> RETURN superexpression .)


state 99

    (40) instruction -> assignfunccall ; .

    ID              reduce using rule 40 (instruction -> assignfunccall ; .)
    PRINT           reduce using rule 40 (instruction -> assignfunccall ; .)
    RETURN          reduce using rule 40 (instruction -> assignfunccall ; .)
    INPUT           reduce using rule 40 (instruction -> assignfunccall ; .)
    IF              reduce using rule 40 (instruction -> assignfunccall ; .)
    WHILE           reduce using rule 40 (instruction -> assignfunccall ; .)
    FOR             reduce using rule 40 (instruction -> assignfunccall ; .)
    INT             reduce using rule 40 (instruction -> assignfunccall ; .)
    FLOAT           reduce using rule 40 (instruction -> assignfunccall ; .)
    STRING          reduce using rule 40 (instruction -> assignfunccall ; .)
    BOOL            reduce using rule 40 (instruction -> assignfunccall ; .)
    #               reduce using rule 40 (instruction -> assignfunccall ; .)
    TRACKDECISION   reduce using rule 40 (instruction -> assignfunccall ; .)
    FORGETDECISION  reduce using rule 40 (instruction -> assignfunccall ; .)
    }               reduce using rule 40 (instruction -> assignfunccall ; .)


state 100

    (89) whileloop -> WHILE ( . superexpression ) block
    (55) superexpression -> . expression superexpressionB
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 151
    empty                          shift and go to state 89
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95

state 101

    (100) output -> PRINT ( . outputB
    (101) outputB -> . SCONST outputC
    (102) outputB -> . superexpression outputC
    (55) superexpression -> . expression superexpressionB
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

  ! shift/reduce conflict for SCONST resolved as shift
    SCONST          shift and go to state 152
    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

  ! SCONST          [ reduce using rule 124 (empty -> .) ]

    term                           shift and go to state 93
    factor                         shift and go to state 88
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 153
    exp                            shift and go to state 94
    outputB                        shift and go to state 154
    expression                     shift and go to state 95
    empty                          shift and go to state 89

state 102

    (107) localvardirectiveB -> FORGET .

    ID              reduce using rule 107 (localvardirectiveB -> FORGET .)


state 103

    (108) localmsgdirective -> # SHOW . SCONST

    SCONST          shift and go to state 155


state 104

    (106) localvardirectiveB -> TRACK .

    ID              reduce using rule 106 (localvardirectiveB -> TRACK .)


state 105

    (105) localvardirective -> # localvardirectiveB . ID

    ID              shift and go to state 156


state 106

    (43) instruction -> input ; .

    ID              reduce using rule 43 (instruction -> input ; .)
    PRINT           reduce using rule 43 (instruction -> input ; .)
    RETURN          reduce using rule 43 (instruction -> input ; .)
    INPUT           reduce using rule 43 (instruction -> input ; .)
    IF              reduce using rule 43 (instruction -> input ; .)
    WHILE           reduce using rule 43 (instruction -> input ; .)
    FOR             reduce using rule 43 (instruction -> input ; .)
    INT             reduce using rule 43 (instruction -> input ; .)
    FLOAT           reduce using rule 43 (instruction -> input ; .)
    STRING          reduce using rule 43 (instruction -> input ; .)
    BOOL            reduce using rule 43 (instruction -> input ; .)
    #               reduce using rule 43 (instruction -> input ; .)
    TRACKDECISION   reduce using rule 43 (instruction -> input ; .)
    FORGETDECISION  reduce using rule 43 (instruction -> input ; .)
    }               reduce using rule 43 (instruction -> input ; .)


state 107

    (42) instruction -> return ; .

    ID              reduce using rule 42 (instruction -> return ; .)
    PRINT           reduce using rule 42 (instruction -> return ; .)
    RETURN          reduce using rule 42 (instruction -> return ; .)
    INPUT           reduce using rule 42 (instruction -> return ; .)
    IF              reduce using rule 42 (instruction -> return ; .)
    WHILE           reduce using rule 42 (instruction -> return ; .)
    FOR             reduce using rule 42 (instruction -> return ; .)
    INT             reduce using rule 42 (instruction -> return ; .)
    FLOAT           reduce using rule 42 (instruction -> return ; .)
    STRING          reduce using rule 42 (instruction -> return ; .)
    BOOL            reduce using rule 42 (instruction -> return ; .)
    #               reduce using rule 42 (instruction -> return ; .)
    TRACKDECISION   reduce using rule 42 (instruction -> return ; .)
    FORGETDECISION  reduce using rule 42 (instruction -> return ; .)
    }               reduce using rule 42 (instruction -> return ; .)


state 108

    (96) forloop -> FOR ( . assign ; superexpression ; superexpression ) block
    (33) assign -> . ID dimensionsOpt = superexpression

    ID              shift and go to state 157

    assign                         shift and go to state 158

state 109

    (30) block -> { instructionsOpt } .

    ID              reduce using rule 30 (block -> { instructionsOpt } .)
    PRINT           reduce using rule 30 (block -> { instructionsOpt } .)
    RETURN          reduce using rule 30 (block -> { instructionsOpt } .)
    INPUT           reduce using rule 30 (block -> { instructionsOpt } .)
    IF              reduce using rule 30 (block -> { instructionsOpt } .)
    WHILE           reduce using rule 30 (block -> { instructionsOpt } .)
    FOR             reduce using rule 30 (block -> { instructionsOpt } .)
    INT             reduce using rule 30 (block -> { instructionsOpt } .)
    FLOAT           reduce using rule 30 (block -> { instructionsOpt } .)
    STRING          reduce using rule 30 (block -> { instructionsOpt } .)
    BOOL            reduce using rule 30 (block -> { instructionsOpt } .)
    #               reduce using rule 30 (block -> { instructionsOpt } .)
    TRACKDECISION   reduce using rule 30 (block -> { instructionsOpt } .)
    FORGETDECISION  reduce using rule 30 (block -> { instructionsOpt } .)
    }               reduce using rule 30 (block -> { instructionsOpt } .)
    DEF             reduce using rule 30 (block -> { instructionsOpt } .)
    $end            reduce using rule 30 (block -> { instructionsOpt } .)
    ELSE            reduce using rule 30 (block -> { instructionsOpt } .)
    MAIN            reduce using rule 30 (block -> { instructionsOpt } .)


state 110

    (97) input -> INPUT ( . ID inputB )

    ID              shift and go to state 159


state 111

    (49) assignfunccall -> ID assignfunccallB .

    ;               reduce using rule 49 (assignfunccall -> ID assignfunccallB .)


state 112

    (50) assignfunccallB -> ( . funccallB funccallC
    (113) funccallB -> . superexpression
    (114) funccallB -> . empty
    (55) superexpression -> . expression superexpressionB
    (124) empty -> .
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -

    ,               reduce using rule 124 (empty -> .)
    )               reduce using rule 124 (empty -> .)
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)
    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87

    funccallB                      shift and go to state 160
    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 162
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95
    empty                          shift and go to state 161

state 113

    (51) assignfunccallB -> assignB .

    ;               reduce using rule 51 (assignfunccallB -> assignB .)


state 114

    (34) assignB -> dimensionsOpt . = superexpression

    =               shift and go to state 163


state 115

    (37) condition -> IF ( . superexpression ) block else
    (55) superexpression -> . expression superexpressionB
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 164
    empty                          shift and go to state 89
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95

state 116

    (31) instructionsOpt -> instruction instructionsOpt .

    }               reduce using rule 31 (instructionsOpt -> instruction instructionsOpt .)


state 117

    (41) instruction -> output ; .

    ID              reduce using rule 41 (instruction -> output ; .)
    PRINT           reduce using rule 41 (instruction -> output ; .)
    RETURN          reduce using rule 41 (instruction -> output ; .)
    INPUT           reduce using rule 41 (instruction -> output ; .)
    IF              reduce using rule 41 (instruction -> output ; .)
    WHILE           reduce using rule 41 (instruction -> output ; .)
    FOR             reduce using rule 41 (instruction -> output ; .)
    INT             reduce using rule 41 (instruction -> output ; .)
    FLOAT           reduce using rule 41 (instruction -> output ; .)
    STRING          reduce using rule 41 (instruction -> output ; .)
    BOOL            reduce using rule 41 (instruction -> output ; .)
    #               reduce using rule 41 (instruction -> output ; .)
    TRACKDECISION   reduce using rule 41 (instruction -> output ; .)
    FORGETDECISION  reduce using rule 41 (instruction -> output ; .)
    }               reduce using rule 41 (instruction -> output ; .)


state 118

    (27) func -> DEF returntype ID ( . paramsOpt )
    (28) paramsOpt -> . params paramsB
    (29) paramsOpt -> . empty
    (121) params -> . type ID
    (124) empty -> .
    (90) type -> . INT
    (91) type -> . FLOAT
    (92) type -> . STRING
    (93) type -> . BOOL

    )               reduce using rule 124 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18

    paramsOpt                      shift and go to state 165
    params                         shift and go to state 166
    type                           shift and go to state 168
    empty                          shift and go to state 167

state 119

    (21) declarationC -> , declarationB declarationC .

    INT             reduce using rule 21 (declarationC -> , declarationB declarationC .)
    FLOAT           reduce using rule 21 (declarationC -> , declarationB declarationC .)
    STRING          reduce using rule 21 (declarationC -> , declarationB declarationC .)
    BOOL            reduce using rule 21 (declarationC -> , declarationB declarationC .)
    DEF             reduce using rule 21 (declarationC -> , declarationB declarationC .)
    MAIN            reduce using rule 21 (declarationC -> , declarationB declarationC .)
    ID              reduce using rule 21 (declarationC -> , declarationB declarationC .)
    PRINT           reduce using rule 21 (declarationC -> , declarationB declarationC .)
    RETURN          reduce using rule 21 (declarationC -> , declarationB declarationC .)
    INPUT           reduce using rule 21 (declarationC -> , declarationB declarationC .)
    IF              reduce using rule 21 (declarationC -> , declarationB declarationC .)
    WHILE           reduce using rule 21 (declarationC -> , declarationB declarationC .)
    FOR             reduce using rule 21 (declarationC -> , declarationB declarationC .)
    #               reduce using rule 21 (declarationC -> , declarationB declarationC .)
    TRACKDECISION   reduce using rule 21 (declarationC -> , declarationB declarationC .)
    FORGETDECISION  reduce using rule 21 (declarationC -> , declarationB declarationC .)
    }               reduce using rule 21 (declarationC -> , declarationB declarationC .)


state 120

    (75) factor -> signB constant .

    /               reduce using rule 75 (factor -> signB constant .)
    *               reduce using rule 75 (factor -> signB constant .)
    -               reduce using rule 75 (factor -> signB constant .)
    +               reduce using rule 75 (factor -> signB constant .)
    <               reduce using rule 75 (factor -> signB constant .)
    >               reduce using rule 75 (factor -> signB constant .)
    =               reduce using rule 75 (factor -> signB constant .)
    &               reduce using rule 75 (factor -> signB constant .)
    |               reduce using rule 75 (factor -> signB constant .)
    ,               reduce using rule 75 (factor -> signB constant .)
    ;               reduce using rule 75 (factor -> signB constant .)
    ]               reduce using rule 75 (factor -> signB constant .)
    )               reduce using rule 75 (factor -> signB constant .)


state 121

    (82) constant -> FCONST .

    /               reduce using rule 82 (constant -> FCONST .)
    *               reduce using rule 82 (constant -> FCONST .)
    -               reduce using rule 82 (constant -> FCONST .)
    +               reduce using rule 82 (constant -> FCONST .)
    <               reduce using rule 82 (constant -> FCONST .)
    >               reduce using rule 82 (constant -> FCONST .)
    =               reduce using rule 82 (constant -> FCONST .)
    &               reduce using rule 82 (constant -> FCONST .)
    |               reduce using rule 82 (constant -> FCONST .)
    ,               reduce using rule 82 (constant -> FCONST .)
    ;               reduce using rule 82 (constant -> FCONST .)
    ]               reduce using rule 82 (constant -> FCONST .)
    )               reduce using rule 82 (constant -> FCONST .)


state 122

    (84) constant -> SCONST .

    /               reduce using rule 84 (constant -> SCONST .)
    *               reduce using rule 84 (constant -> SCONST .)
    -               reduce using rule 84 (constant -> SCONST .)
    +               reduce using rule 84 (constant -> SCONST .)
    <               reduce using rule 84 (constant -> SCONST .)
    >               reduce using rule 84 (constant -> SCONST .)
    =               reduce using rule 84 (constant -> SCONST .)
    &               reduce using rule 84 (constant -> SCONST .)
    |               reduce using rule 84 (constant -> SCONST .)
    ,               reduce using rule 84 (constant -> SCONST .)
    ;               reduce using rule 84 (constant -> SCONST .)
    ]               reduce using rule 84 (constant -> SCONST .)
    )               reduce using rule 84 (constant -> SCONST .)


state 123

    (83) constant -> ICONST .

    /               reduce using rule 83 (constant -> ICONST .)
    *               reduce using rule 83 (constant -> ICONST .)
    -               reduce using rule 83 (constant -> ICONST .)
    +               reduce using rule 83 (constant -> ICONST .)
    <               reduce using rule 83 (constant -> ICONST .)
    >               reduce using rule 83 (constant -> ICONST .)
    =               reduce using rule 83 (constant -> ICONST .)
    &               reduce using rule 83 (constant -> ICONST .)
    |               reduce using rule 83 (constant -> ICONST .)
    ,               reduce using rule 83 (constant -> ICONST .)
    ;               reduce using rule 83 (constant -> ICONST .)
    ]               reduce using rule 83 (constant -> ICONST .)
    )               reduce using rule 83 (constant -> ICONST .)


state 124

    (86) constant -> FALSE .

    /               reduce using rule 86 (constant -> FALSE .)
    *               reduce using rule 86 (constant -> FALSE .)
    -               reduce using rule 86 (constant -> FALSE .)
    +               reduce using rule 86 (constant -> FALSE .)
    <               reduce using rule 86 (constant -> FALSE .)
    >               reduce using rule 86 (constant -> FALSE .)
    =               reduce using rule 86 (constant -> FALSE .)
    &               reduce using rule 86 (constant -> FALSE .)
    |               reduce using rule 86 (constant -> FALSE .)
    ,               reduce using rule 86 (constant -> FALSE .)
    ;               reduce using rule 86 (constant -> FALSE .)
    ]               reduce using rule 86 (constant -> FALSE .)
    )               reduce using rule 86 (constant -> FALSE .)


state 125

    (85) constant -> TRUE .

    /               reduce using rule 85 (constant -> TRUE .)
    *               reduce using rule 85 (constant -> TRUE .)
    -               reduce using rule 85 (constant -> TRUE .)
    +               reduce using rule 85 (constant -> TRUE .)
    <               reduce using rule 85 (constant -> TRUE .)
    >               reduce using rule 85 (constant -> TRUE .)
    =               reduce using rule 85 (constant -> TRUE .)
    &               reduce using rule 85 (constant -> TRUE .)
    |               reduce using rule 85 (constant -> TRUE .)
    ,               reduce using rule 85 (constant -> TRUE .)
    ;               reduce using rule 85 (constant -> TRUE .)
    ]               reduce using rule 85 (constant -> TRUE .)
    )               reduce using rule 85 (constant -> TRUE .)


state 126

    (76) factor -> ( superexpression . )

    )               shift and go to state 169


state 127

    (73) termB -> * . term
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 170
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    factor                         shift and go to state 88
    empty                          shift and go to state 89

state 128

    (72) termB -> / . term
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 171
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    factor                         shift and go to state 88
    empty                          shift and go to state 89

state 129

    (71) term -> factor termB .

    -               reduce using rule 71 (term -> factor termB .)
    +               reduce using rule 71 (term -> factor termB .)
    <               reduce using rule 71 (term -> factor termB .)
    >               reduce using rule 71 (term -> factor termB .)
    =               reduce using rule 71 (term -> factor termB .)
    &               reduce using rule 71 (term -> factor termB .)
    |               reduce using rule 71 (term -> factor termB .)
    ,               reduce using rule 71 (term -> factor termB .)
    ;               reduce using rule 71 (term -> factor termB .)
    ]               reduce using rule 71 (term -> factor termB .)
    )               reduce using rule 71 (term -> factor termB .)


state 130

    (74) termB -> empty .

    -               reduce using rule 74 (termB -> empty .)
    +               reduce using rule 74 (termB -> empty .)
    <               reduce using rule 74 (termB -> empty .)
    >               reduce using rule 74 (termB -> empty .)
    =               reduce using rule 74 (termB -> empty .)
    &               reduce using rule 74 (termB -> empty .)
    |               reduce using rule 74 (termB -> empty .)
    ,               reduce using rule 74 (termB -> empty .)
    ;               reduce using rule 74 (termB -> empty .)
    ]               reduce using rule 74 (termB -> empty .)
    )               reduce using rule 74 (termB -> empty .)


state 131

    (23) declarationD -> , . declarationB declarationC
    (19) declarationB -> . ID dimensionsOpt

    ID              shift and go to state 36

    declarationB                   shift and go to state 172

state 132

    (20) declarationC -> = superexpression declarationD .

    INT             reduce using rule 20 (declarationC -> = superexpression declarationD .)
    FLOAT           reduce using rule 20 (declarationC -> = superexpression declarationD .)
    STRING          reduce using rule 20 (declarationC -> = superexpression declarationD .)
    BOOL            reduce using rule 20 (declarationC -> = superexpression declarationD .)
    DEF             reduce using rule 20 (declarationC -> = superexpression declarationD .)
    MAIN            reduce using rule 20 (declarationC -> = superexpression declarationD .)
    ID              reduce using rule 20 (declarationC -> = superexpression declarationD .)
    PRINT           reduce using rule 20 (declarationC -> = superexpression declarationD .)
    RETURN          reduce using rule 20 (declarationC -> = superexpression declarationD .)
    INPUT           reduce using rule 20 (declarationC -> = superexpression declarationD .)
    IF              reduce using rule 20 (declarationC -> = superexpression declarationD .)
    WHILE           reduce using rule 20 (declarationC -> = superexpression declarationD .)
    FOR             reduce using rule 20 (declarationC -> = superexpression declarationD .)
    #               reduce using rule 20 (declarationC -> = superexpression declarationD .)
    TRACKDECISION   reduce using rule 20 (declarationC -> = superexpression declarationD .)
    FORGETDECISION  reduce using rule 20 (declarationC -> = superexpression declarationD .)
    }               reduce using rule 20 (declarationC -> = superexpression declarationD .)


state 133

    (24) declarationD -> ; .

    INT             reduce using rule 24 (declarationD -> ; .)
    FLOAT           reduce using rule 24 (declarationD -> ; .)
    STRING          reduce using rule 24 (declarationD -> ; .)
    BOOL            reduce using rule 24 (declarationD -> ; .)
    DEF             reduce using rule 24 (declarationD -> ; .)
    MAIN            reduce using rule 24 (declarationD -> ; .)
    ID              reduce using rule 24 (declarationD -> ; .)
    PRINT           reduce using rule 24 (declarationD -> ; .)
    RETURN          reduce using rule 24 (declarationD -> ; .)
    INPUT           reduce using rule 24 (declarationD -> ; .)
    IF              reduce using rule 24 (declarationD -> ; .)
    WHILE           reduce using rule 24 (declarationD -> ; .)
    FOR             reduce using rule 24 (declarationD -> ; .)
    #               reduce using rule 24 (declarationD -> ; .)
    TRACKDECISION   reduce using rule 24 (declarationD -> ; .)
    FORGETDECISION  reduce using rule 24 (declarationD -> ; .)
    }               reduce using rule 24 (declarationD -> ; .)


state 134

    (112) funccall -> ID ( . funccallB funccallC
    (113) funccallB -> . superexpression
    (114) funccallB -> . empty
    (55) superexpression -> . expression superexpressionB
    (124) empty -> .
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -

    ,               reduce using rule 124 (empty -> .)
    )               reduce using rule 124 (empty -> .)
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)
    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87

    funccallB                      shift and go to state 173
    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 162
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95
    empty                          shift and go to state 161

state 135

    (78) factor -> ID seen_ID . dimensionsOpt
    (35) dimensionsOpt -> . dimensions
    (36) dimensionsOpt -> . empty
    (117) dimensions -> . [ superexpression ] dimensionsB
    (124) empty -> .

    [               shift and go to state 51
    /               reduce using rule 124 (empty -> .)
    *               reduce using rule 124 (empty -> .)
    -               reduce using rule 124 (empty -> .)
    +               reduce using rule 124 (empty -> .)
    <               reduce using rule 124 (empty -> .)
    >               reduce using rule 124 (empty -> .)
    =               reduce using rule 124 (empty -> .)
    &               reduce using rule 124 (empty -> .)
    |               reduce using rule 124 (empty -> .)
    ,               reduce using rule 124 (empty -> .)
    ;               reduce using rule 124 (empty -> .)
    ]               reduce using rule 124 (empty -> .)
    )               reduce using rule 124 (empty -> .)

    dimensions                     shift and go to state 50
    dimensionsOpt                  shift and go to state 174
    empty                          shift and go to state 53

state 136

    (69) expB -> + . exp
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    exp                            shift and go to state 175
    factor                         shift and go to state 88
    empty                          shift and go to state 89

state 137

    (68) expB -> - . exp
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    exp                            shift and go to state 176
    factor                         shift and go to state 88
    empty                          shift and go to state 89

state 138

    (67) exp -> term expB .

    <               reduce using rule 67 (exp -> term expB .)
    >               reduce using rule 67 (exp -> term expB .)
    =               reduce using rule 67 (exp -> term expB .)
    &               reduce using rule 67 (exp -> term expB .)
    |               reduce using rule 67 (exp -> term expB .)
    ;               reduce using rule 67 (exp -> term expB .)
    ,               reduce using rule 67 (exp -> term expB .)
    ]               reduce using rule 67 (exp -> term expB .)
    )               reduce using rule 67 (exp -> term expB .)


state 139

    (70) expB -> empty .

    <               reduce using rule 70 (expB -> empty .)
    >               reduce using rule 70 (expB -> empty .)
    =               reduce using rule 70 (expB -> empty .)
    &               reduce using rule 70 (expB -> empty .)
    |               reduce using rule 70 (expB -> empty .)
    ,               reduce using rule 70 (expB -> empty .)
    ;               reduce using rule 70 (expB -> empty .)
    ]               reduce using rule 70 (expB -> empty .)
    )               reduce using rule 70 (expB -> empty .)


state 140

    (59) expression -> exp expressionB .

    &               reduce using rule 59 (expression -> exp expressionB .)
    |               reduce using rule 59 (expression -> exp expressionB .)
    ,               reduce using rule 59 (expression -> exp expressionB .)
    ;               reduce using rule 59 (expression -> exp expressionB .)
    ]               reduce using rule 59 (expression -> exp expressionB .)
    )               reduce using rule 59 (expression -> exp expressionB .)


state 141

    (63) expressionB -> = . = exp

    =               shift and go to state 177


state 142

    (60) expressionB -> < . exp
    (62) expressionB -> < . > exp
    (64) expressionB -> < . = exp
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    >               shift and go to state 179
    =               shift and go to state 178
    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    exp                            shift and go to state 180
    factor                         shift and go to state 88
    empty                          shift and go to state 89

state 143

    (66) expressionB -> empty .

    &               reduce using rule 66 (expressionB -> empty .)
    |               reduce using rule 66 (expressionB -> empty .)
    ,               reduce using rule 66 (expressionB -> empty .)
    ;               reduce using rule 66 (expressionB -> empty .)
    ]               reduce using rule 66 (expressionB -> empty .)
    )               reduce using rule 66 (expressionB -> empty .)


state 144

    (61) expressionB -> > . exp
    (65) expressionB -> > . = exp
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    =               shift and go to state 181
    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    exp                            shift and go to state 182
    factor                         shift and go to state 88
    empty                          shift and go to state 89

state 145

    (56) superexpressionB -> & . & superexpression

    &               shift and go to state 183


state 146

    (55) superexpression -> expression superexpressionB .

    ]               reduce using rule 55 (superexpression -> expression superexpressionB .)
    ,               reduce using rule 55 (superexpression -> expression superexpressionB .)
    )               reduce using rule 55 (superexpression -> expression superexpressionB .)
    ;               reduce using rule 55 (superexpression -> expression superexpressionB .)


state 147

    (57) superexpressionB -> | . | superexpression

    |               shift and go to state 184


state 148

    (58) superexpressionB -> empty .

    ,               reduce using rule 58 (superexpressionB -> empty .)
    ;               reduce using rule 58 (superexpressionB -> empty .)
    ]               reduce using rule 58 (superexpressionB -> empty .)
    )               reduce using rule 58 (superexpressionB -> empty .)


state 149

    (117) dimensions -> [ superexpression ] . dimensionsB
    (118) dimensionsB -> . [ superexpression ]
    (119) dimensionsB -> . empty
    (124) empty -> .

    [               shift and go to state 186
    =               reduce using rule 124 (empty -> .)
    ,               reduce using rule 124 (empty -> .)
    ;               reduce using rule 124 (empty -> .)
    /               reduce using rule 124 (empty -> .)
    *               reduce using rule 124 (empty -> .)
    -               reduce using rule 124 (empty -> .)
    +               reduce using rule 124 (empty -> .)
    <               reduce using rule 124 (empty -> .)
    >               reduce using rule 124 (empty -> .)
    &               reduce using rule 124 (empty -> .)
    |               reduce using rule 124 (empty -> .)
    ]               reduce using rule 124 (empty -> .)
    )               reduce using rule 124 (empty -> .)

    dimensionsB                    shift and go to state 185
    empty                          shift and go to state 187

state 150

    (25) main -> MAIN ( ) block .

    DEF             reduce using rule 25 (main -> MAIN ( ) block .)
    $end            reduce using rule 25 (main -> MAIN ( ) block .)


state 151

    (89) whileloop -> WHILE ( superexpression . ) block

    )               shift and go to state 188


state 152

    (101) outputB -> SCONST . outputC
    (103) outputC -> . )
    (104) outputC -> . , outputB

    )               shift and go to state 189
    ,               shift and go to state 191

    outputC                        shift and go to state 190

state 153

    (102) outputB -> superexpression . outputC
    (103) outputC -> . )
    (104) outputC -> . , outputB

    )               shift and go to state 189
    ,               shift and go to state 191

    outputC                        shift and go to state 192

state 154

    (100) output -> PRINT ( outputB .

    ;               reduce using rule 100 (output -> PRINT ( outputB .)


state 155

    (108) localmsgdirective -> # SHOW SCONST .

    ID              reduce using rule 108 (localmsgdirective -> # SHOW SCONST .)
    PRINT           reduce using rule 108 (localmsgdirective -> # SHOW SCONST .)
    RETURN          reduce using rule 108 (localmsgdirective -> # SHOW SCONST .)
    INPUT           reduce using rule 108 (localmsgdirective -> # SHOW SCONST .)
    IF              reduce using rule 108 (localmsgdirective -> # SHOW SCONST .)
    WHILE           reduce using rule 108 (localmsgdirective -> # SHOW SCONST .)
    FOR             reduce using rule 108 (localmsgdirective -> # SHOW SCONST .)
    INT             reduce using rule 108 (localmsgdirective -> # SHOW SCONST .)
    FLOAT           reduce using rule 108 (localmsgdirective -> # SHOW SCONST .)
    STRING          reduce using rule 108 (localmsgdirective -> # SHOW SCONST .)
    BOOL            reduce using rule 108 (localmsgdirective -> # SHOW SCONST .)
    #               reduce using rule 108 (localmsgdirective -> # SHOW SCONST .)
    TRACKDECISION   reduce using rule 108 (localmsgdirective -> # SHOW SCONST .)
    FORGETDECISION  reduce using rule 108 (localmsgdirective -> # SHOW SCONST .)
    }               reduce using rule 108 (localmsgdirective -> # SHOW SCONST .)


state 156

    (105) localvardirective -> # localvardirectiveB ID .

    ID              reduce using rule 105 (localvardirective -> # localvardirectiveB ID .)
    PRINT           reduce using rule 105 (localvardirective -> # localvardirectiveB ID .)
    RETURN          reduce using rule 105 (localvardirective -> # localvardirectiveB ID .)
    INPUT           reduce using rule 105 (localvardirective -> # localvardirectiveB ID .)
    IF              reduce using rule 105 (localvardirective -> # localvardirectiveB ID .)
    WHILE           reduce using rule 105 (localvardirective -> # localvardirectiveB ID .)
    FOR             reduce using rule 105 (localvardirective -> # localvardirectiveB ID .)
    INT             reduce using rule 105 (localvardirective -> # localvardirectiveB ID .)
    FLOAT           reduce using rule 105 (localvardirective -> # localvardirectiveB ID .)
    STRING          reduce using rule 105 (localvardirective -> # localvardirectiveB ID .)
    BOOL            reduce using rule 105 (localvardirective -> # localvardirectiveB ID .)
    #               reduce using rule 105 (localvardirective -> # localvardirectiveB ID .)
    TRACKDECISION   reduce using rule 105 (localvardirective -> # localvardirectiveB ID .)
    FORGETDECISION  reduce using rule 105 (localvardirective -> # localvardirectiveB ID .)
    }               reduce using rule 105 (localvardirective -> # localvardirectiveB ID .)


state 157

    (33) assign -> ID . dimensionsOpt = superexpression
    (35) dimensionsOpt -> . dimensions
    (36) dimensionsOpt -> . empty
    (117) dimensions -> . [ superexpression ] dimensionsB
    (124) empty -> .

    [               shift and go to state 51
    =               reduce using rule 124 (empty -> .)

    dimensionsOpt                  shift and go to state 193
    dimensions                     shift and go to state 50
    empty                          shift and go to state 53

state 158

    (96) forloop -> FOR ( assign . ; superexpression ; superexpression ) block

    ;               shift and go to state 194


state 159

    (97) input -> INPUT ( ID . inputB )
    (98) inputB -> . , ID inputB
    (99) inputB -> . empty
    (124) empty -> .

    ,               shift and go to state 195
    )               reduce using rule 124 (empty -> .)

    inputB                         shift and go to state 196
    empty                          shift and go to state 197

state 160

    (50) assignfunccallB -> ( funccallB . funccallC
    (115) funccallC -> . , funccallB funccallC
    (116) funccallC -> . )

    ,               shift and go to state 200
    )               shift and go to state 199

    funccallC                      shift and go to state 198

state 161

    (114) funccallB -> empty .
    (81) signB -> empty .

    ,               reduce using rule 114 (funccallB -> empty .)
    )               reduce using rule 114 (funccallB -> empty .)
    FCONST          reduce using rule 81 (signB -> empty .)
    ICONST          reduce using rule 81 (signB -> empty .)
    SCONST          reduce using rule 81 (signB -> empty .)
    TRUE            reduce using rule 81 (signB -> empty .)
    FALSE           reduce using rule 81 (signB -> empty .)


state 162

    (113) funccallB -> superexpression .

    ,               reduce using rule 113 (funccallB -> superexpression .)
    )               reduce using rule 113 (funccallB -> superexpression .)


state 163

    (34) assignB -> dimensionsOpt = . superexpression
    (55) superexpression -> . expression superexpressionB
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 201
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95
    empty                          shift and go to state 89

state 164

    (37) condition -> IF ( superexpression . ) block else

    )               shift and go to state 202


state 165

    (27) func -> DEF returntype ID ( paramsOpt . )

    )               shift and go to state 203


state 166

    (28) paramsOpt -> params . paramsB
    (122) paramsB -> . , params paramsB
    (123) paramsB -> . empty
    (124) empty -> .

    ,               shift and go to state 205
    )               reduce using rule 124 (empty -> .)

    paramsB                        shift and go to state 204
    empty                          shift and go to state 206

state 167

    (29) paramsOpt -> empty .

    )               reduce using rule 29 (paramsOpt -> empty .)


state 168

    (121) params -> type . ID

    ID              shift and go to state 207


state 169

    (76) factor -> ( superexpression ) .

    /               reduce using rule 76 (factor -> ( superexpression ) .)
    *               reduce using rule 76 (factor -> ( superexpression ) .)
    -               reduce using rule 76 (factor -> ( superexpression ) .)
    +               reduce using rule 76 (factor -> ( superexpression ) .)
    <               reduce using rule 76 (factor -> ( superexpression ) .)
    >               reduce using rule 76 (factor -> ( superexpression ) .)
    =               reduce using rule 76 (factor -> ( superexpression ) .)
    &               reduce using rule 76 (factor -> ( superexpression ) .)
    |               reduce using rule 76 (factor -> ( superexpression ) .)
    ,               reduce using rule 76 (factor -> ( superexpression ) .)
    ;               reduce using rule 76 (factor -> ( superexpression ) .)
    ]               reduce using rule 76 (factor -> ( superexpression ) .)
    )               reduce using rule 76 (factor -> ( superexpression ) .)


state 170

    (73) termB -> * term .

    -               reduce using rule 73 (termB -> * term .)
    +               reduce using rule 73 (termB -> * term .)
    <               reduce using rule 73 (termB -> * term .)
    >               reduce using rule 73 (termB -> * term .)
    =               reduce using rule 73 (termB -> * term .)
    &               reduce using rule 73 (termB -> * term .)
    |               reduce using rule 73 (termB -> * term .)
    ,               reduce using rule 73 (termB -> * term .)
    ;               reduce using rule 73 (termB -> * term .)
    ]               reduce using rule 73 (termB -> * term .)
    )               reduce using rule 73 (termB -> * term .)


state 171

    (72) termB -> / term .

    -               reduce using rule 72 (termB -> / term .)
    +               reduce using rule 72 (termB -> / term .)
    <               reduce using rule 72 (termB -> / term .)
    >               reduce using rule 72 (termB -> / term .)
    =               reduce using rule 72 (termB -> / term .)
    &               reduce using rule 72 (termB -> / term .)
    |               reduce using rule 72 (termB -> / term .)
    ,               reduce using rule 72 (termB -> / term .)
    ;               reduce using rule 72 (termB -> / term .)
    ]               reduce using rule 72 (termB -> / term .)
    )               reduce using rule 72 (termB -> / term .)


state 172

    (23) declarationD -> , declarationB . declarationC
    (20) declarationC -> . = superexpression declarationD
    (21) declarationC -> . , declarationB declarationC
    (22) declarationC -> . ;

    =               shift and go to state 48
    ,               shift and go to state 46
    ;               shift and go to state 49

    declarationC                   shift and go to state 208

state 173

    (112) funccall -> ID ( funccallB . funccallC
    (115) funccallC -> . , funccallB funccallC
    (116) funccallC -> . )

    ,               shift and go to state 200
    )               shift and go to state 199

    funccallC                      shift and go to state 209

state 174

    (78) factor -> ID seen_ID dimensionsOpt .

    /               reduce using rule 78 (factor -> ID seen_ID dimensionsOpt .)
    *               reduce using rule 78 (factor -> ID seen_ID dimensionsOpt .)
    -               reduce using rule 78 (factor -> ID seen_ID dimensionsOpt .)
    +               reduce using rule 78 (factor -> ID seen_ID dimensionsOpt .)
    <               reduce using rule 78 (factor -> ID seen_ID dimensionsOpt .)
    >               reduce using rule 78 (factor -> ID seen_ID dimensionsOpt .)
    =               reduce using rule 78 (factor -> ID seen_ID dimensionsOpt .)
    &               reduce using rule 78 (factor -> ID seen_ID dimensionsOpt .)
    |               reduce using rule 78 (factor -> ID seen_ID dimensionsOpt .)
    ,               reduce using rule 78 (factor -> ID seen_ID dimensionsOpt .)
    ;               reduce using rule 78 (factor -> ID seen_ID dimensionsOpt .)
    ]               reduce using rule 78 (factor -> ID seen_ID dimensionsOpt .)
    )               reduce using rule 78 (factor -> ID seen_ID dimensionsOpt .)


state 175

    (69) expB -> + exp .

    <               reduce using rule 69 (expB -> + exp .)
    >               reduce using rule 69 (expB -> + exp .)
    =               reduce using rule 69 (expB -> + exp .)
    &               reduce using rule 69 (expB -> + exp .)
    |               reduce using rule 69 (expB -> + exp .)
    ,               reduce using rule 69 (expB -> + exp .)
    ;               reduce using rule 69 (expB -> + exp .)
    ]               reduce using rule 69 (expB -> + exp .)
    )               reduce using rule 69 (expB -> + exp .)


state 176

    (68) expB -> - exp .

    <               reduce using rule 68 (expB -> - exp .)
    >               reduce using rule 68 (expB -> - exp .)
    =               reduce using rule 68 (expB -> - exp .)
    &               reduce using rule 68 (expB -> - exp .)
    |               reduce using rule 68 (expB -> - exp .)
    ,               reduce using rule 68 (expB -> - exp .)
    ;               reduce using rule 68 (expB -> - exp .)
    ]               reduce using rule 68 (expB -> - exp .)
    )               reduce using rule 68 (expB -> - exp .)


state 177

    (63) expressionB -> = = . exp
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    exp                            shift and go to state 210
    factor                         shift and go to state 88
    empty                          shift and go to state 89

state 178

    (64) expressionB -> < = . exp
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    exp                            shift and go to state 211
    factor                         shift and go to state 88
    empty                          shift and go to state 89

state 179

    (62) expressionB -> < > . exp
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    exp                            shift and go to state 212
    factor                         shift and go to state 88
    empty                          shift and go to state 89

state 180

    (60) expressionB -> < exp .

    &               reduce using rule 60 (expressionB -> < exp .)
    |               reduce using rule 60 (expressionB -> < exp .)
    ,               reduce using rule 60 (expressionB -> < exp .)
    ;               reduce using rule 60 (expressionB -> < exp .)
    ]               reduce using rule 60 (expressionB -> < exp .)
    )               reduce using rule 60 (expressionB -> < exp .)


state 181

    (65) expressionB -> > = . exp
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    exp                            shift and go to state 213
    factor                         shift and go to state 88
    empty                          shift and go to state 89

state 182

    (61) expressionB -> > exp .

    &               reduce using rule 61 (expressionB -> > exp .)
    |               reduce using rule 61 (expressionB -> > exp .)
    ,               reduce using rule 61 (expressionB -> > exp .)
    ;               reduce using rule 61 (expressionB -> > exp .)
    ]               reduce using rule 61 (expressionB -> > exp .)
    )               reduce using rule 61 (expressionB -> > exp .)


state 183

    (56) superexpressionB -> & & . superexpression
    (55) superexpression -> . expression superexpressionB
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 214
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95
    empty                          shift and go to state 89

state 184

    (57) superexpressionB -> | | . superexpression
    (55) superexpression -> . expression superexpressionB
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 215
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95
    empty                          shift and go to state 89

state 185

    (117) dimensions -> [ superexpression ] dimensionsB .

    =               reduce using rule 117 (dimensions -> [ superexpression ] dimensionsB .)
    ,               reduce using rule 117 (dimensions -> [ superexpression ] dimensionsB .)
    ;               reduce using rule 117 (dimensions -> [ superexpression ] dimensionsB .)
    /               reduce using rule 117 (dimensions -> [ superexpression ] dimensionsB .)
    *               reduce using rule 117 (dimensions -> [ superexpression ] dimensionsB .)
    -               reduce using rule 117 (dimensions -> [ superexpression ] dimensionsB .)
    +               reduce using rule 117 (dimensions -> [ superexpression ] dimensionsB .)
    <               reduce using rule 117 (dimensions -> [ superexpression ] dimensionsB .)
    >               reduce using rule 117 (dimensions -> [ superexpression ] dimensionsB .)
    &               reduce using rule 117 (dimensions -> [ superexpression ] dimensionsB .)
    |               reduce using rule 117 (dimensions -> [ superexpression ] dimensionsB .)
    ]               reduce using rule 117 (dimensions -> [ superexpression ] dimensionsB .)
    )               reduce using rule 117 (dimensions -> [ superexpression ] dimensionsB .)


state 186

    (118) dimensionsB -> [ . superexpression ]
    (55) superexpression -> . expression superexpressionB
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 216
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95
    empty                          shift and go to state 89

state 187

    (119) dimensionsB -> empty .

    =               reduce using rule 119 (dimensionsB -> empty .)
    ,               reduce using rule 119 (dimensionsB -> empty .)
    ;               reduce using rule 119 (dimensionsB -> empty .)
    /               reduce using rule 119 (dimensionsB -> empty .)
    *               reduce using rule 119 (dimensionsB -> empty .)
    -               reduce using rule 119 (dimensionsB -> empty .)
    +               reduce using rule 119 (dimensionsB -> empty .)
    <               reduce using rule 119 (dimensionsB -> empty .)
    >               reduce using rule 119 (dimensionsB -> empty .)
    &               reduce using rule 119 (dimensionsB -> empty .)
    |               reduce using rule 119 (dimensionsB -> empty .)
    ]               reduce using rule 119 (dimensionsB -> empty .)
    )               reduce using rule 119 (dimensionsB -> empty .)


state 188

    (89) whileloop -> WHILE ( superexpression ) . block
    (30) block -> . { instructionsOpt }

    {               shift and go to state 41

    block                          shift and go to state 217

state 189

    (103) outputC -> ) .

    ;               reduce using rule 103 (outputC -> ) .)


state 190

    (101) outputB -> SCONST outputC .

    ;               reduce using rule 101 (outputB -> SCONST outputC .)


state 191

    (104) outputC -> , . outputB
    (101) outputB -> . SCONST outputC
    (102) outputB -> . superexpression outputC
    (55) superexpression -> . expression superexpressionB
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

  ! shift/reduce conflict for SCONST resolved as shift
    SCONST          shift and go to state 152
    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

  ! SCONST          [ reduce using rule 124 (empty -> .) ]

    term                           shift and go to state 93
    factor                         shift and go to state 88
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 153
    exp                            shift and go to state 94
    outputB                        shift and go to state 218
    expression                     shift and go to state 95
    empty                          shift and go to state 89

state 192

    (102) outputB -> superexpression outputC .

    ;               reduce using rule 102 (outputB -> superexpression outputC .)


state 193

    (33) assign -> ID dimensionsOpt . = superexpression

    =               shift and go to state 219


state 194

    (96) forloop -> FOR ( assign ; . superexpression ; superexpression ) block
    (55) superexpression -> . expression superexpressionB
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 220
    empty                          shift and go to state 89
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95

state 195

    (98) inputB -> , . ID inputB

    ID              shift and go to state 221


state 196

    (97) input -> INPUT ( ID inputB . )

    )               shift and go to state 222


state 197

    (99) inputB -> empty .

    )               reduce using rule 99 (inputB -> empty .)


state 198

    (50) assignfunccallB -> ( funccallB funccallC .

    ;               reduce using rule 50 (assignfunccallB -> ( funccallB funccallC .)


state 199

    (116) funccallC -> ) .

    /               reduce using rule 116 (funccallC -> ) .)
    *               reduce using rule 116 (funccallC -> ) .)
    -               reduce using rule 116 (funccallC -> ) .)
    +               reduce using rule 116 (funccallC -> ) .)
    <               reduce using rule 116 (funccallC -> ) .)
    >               reduce using rule 116 (funccallC -> ) .)
    =               reduce using rule 116 (funccallC -> ) .)
    &               reduce using rule 116 (funccallC -> ) .)
    |               reduce using rule 116 (funccallC -> ) .)
    ,               reduce using rule 116 (funccallC -> ) .)
    ;               reduce using rule 116 (funccallC -> ) .)
    ]               reduce using rule 116 (funccallC -> ) .)
    )               reduce using rule 116 (funccallC -> ) .)


state 200

    (115) funccallC -> , . funccallB funccallC
    (113) funccallB -> . superexpression
    (114) funccallB -> . empty
    (55) superexpression -> . expression superexpressionB
    (124) empty -> .
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -

    ,               reduce using rule 124 (empty -> .)
    )               reduce using rule 124 (empty -> .)
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)
    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87

    funccallB                      shift and go to state 223
    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 162
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95
    empty                          shift and go to state 161

state 201

    (34) assignB -> dimensionsOpt = superexpression .

    ;               reduce using rule 34 (assignB -> dimensionsOpt = superexpression .)


state 202

    (37) condition -> IF ( superexpression ) . block else
    (30) block -> . { instructionsOpt }

    {               shift and go to state 41

    block                          shift and go to state 224

state 203

    (27) func -> DEF returntype ID ( paramsOpt ) .

    {               reduce using rule 27 (func -> DEF returntype ID ( paramsOpt ) .)


state 204

    (28) paramsOpt -> params paramsB .

    )               reduce using rule 28 (paramsOpt -> params paramsB .)


state 205

    (122) paramsB -> , . params paramsB
    (121) params -> . type ID
    (90) type -> . INT
    (91) type -> . FLOAT
    (92) type -> . STRING
    (93) type -> . BOOL

    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18

    type                           shift and go to state 168
    params                         shift and go to state 225

state 206

    (123) paramsB -> empty .

    )               reduce using rule 123 (paramsB -> empty .)


state 207

    (121) params -> type ID .

    ,               reduce using rule 121 (params -> type ID .)
    )               reduce using rule 121 (params -> type ID .)


state 208

    (23) declarationD -> , declarationB declarationC .

    INT             reduce using rule 23 (declarationD -> , declarationB declarationC .)
    FLOAT           reduce using rule 23 (declarationD -> , declarationB declarationC .)
    STRING          reduce using rule 23 (declarationD -> , declarationB declarationC .)
    BOOL            reduce using rule 23 (declarationD -> , declarationB declarationC .)
    DEF             reduce using rule 23 (declarationD -> , declarationB declarationC .)
    MAIN            reduce using rule 23 (declarationD -> , declarationB declarationC .)
    ID              reduce using rule 23 (declarationD -> , declarationB declarationC .)
    PRINT           reduce using rule 23 (declarationD -> , declarationB declarationC .)
    RETURN          reduce using rule 23 (declarationD -> , declarationB declarationC .)
    INPUT           reduce using rule 23 (declarationD -> , declarationB declarationC .)
    IF              reduce using rule 23 (declarationD -> , declarationB declarationC .)
    WHILE           reduce using rule 23 (declarationD -> , declarationB declarationC .)
    FOR             reduce using rule 23 (declarationD -> , declarationB declarationC .)
    #               reduce using rule 23 (declarationD -> , declarationB declarationC .)
    TRACKDECISION   reduce using rule 23 (declarationD -> , declarationB declarationC .)
    FORGETDECISION  reduce using rule 23 (declarationD -> , declarationB declarationC .)
    }               reduce using rule 23 (declarationD -> , declarationB declarationC .)


state 209

    (112) funccall -> ID ( funccallB funccallC .

    /               reduce using rule 112 (funccall -> ID ( funccallB funccallC .)
    *               reduce using rule 112 (funccall -> ID ( funccallB funccallC .)
    -               reduce using rule 112 (funccall -> ID ( funccallB funccallC .)
    +               reduce using rule 112 (funccall -> ID ( funccallB funccallC .)
    <               reduce using rule 112 (funccall -> ID ( funccallB funccallC .)
    >               reduce using rule 112 (funccall -> ID ( funccallB funccallC .)
    =               reduce using rule 112 (funccall -> ID ( funccallB funccallC .)
    &               reduce using rule 112 (funccall -> ID ( funccallB funccallC .)
    |               reduce using rule 112 (funccall -> ID ( funccallB funccallC .)
    ,               reduce using rule 112 (funccall -> ID ( funccallB funccallC .)
    )               reduce using rule 112 (funccall -> ID ( funccallB funccallC .)
    ]               reduce using rule 112 (funccall -> ID ( funccallB funccallC .)
    ;               reduce using rule 112 (funccall -> ID ( funccallB funccallC .)


state 210

    (63) expressionB -> = = exp .

    &               reduce using rule 63 (expressionB -> = = exp .)
    |               reduce using rule 63 (expressionB -> = = exp .)
    ,               reduce using rule 63 (expressionB -> = = exp .)
    ;               reduce using rule 63 (expressionB -> = = exp .)
    ]               reduce using rule 63 (expressionB -> = = exp .)
    )               reduce using rule 63 (expressionB -> = = exp .)


state 211

    (64) expressionB -> < = exp .

    &               reduce using rule 64 (expressionB -> < = exp .)
    |               reduce using rule 64 (expressionB -> < = exp .)
    ,               reduce using rule 64 (expressionB -> < = exp .)
    ;               reduce using rule 64 (expressionB -> < = exp .)
    ]               reduce using rule 64 (expressionB -> < = exp .)
    )               reduce using rule 64 (expressionB -> < = exp .)


state 212

    (62) expressionB -> < > exp .

    &               reduce using rule 62 (expressionB -> < > exp .)
    |               reduce using rule 62 (expressionB -> < > exp .)
    ,               reduce using rule 62 (expressionB -> < > exp .)
    ;               reduce using rule 62 (expressionB -> < > exp .)
    ]               reduce using rule 62 (expressionB -> < > exp .)
    )               reduce using rule 62 (expressionB -> < > exp .)


state 213

    (65) expressionB -> > = exp .

    &               reduce using rule 65 (expressionB -> > = exp .)
    |               reduce using rule 65 (expressionB -> > = exp .)
    ,               reduce using rule 65 (expressionB -> > = exp .)
    ;               reduce using rule 65 (expressionB -> > = exp .)
    ]               reduce using rule 65 (expressionB -> > = exp .)
    )               reduce using rule 65 (expressionB -> > = exp .)


state 214

    (56) superexpressionB -> & & superexpression .

    ,               reduce using rule 56 (superexpressionB -> & & superexpression .)
    ;               reduce using rule 56 (superexpressionB -> & & superexpression .)
    ]               reduce using rule 56 (superexpressionB -> & & superexpression .)
    )               reduce using rule 56 (superexpressionB -> & & superexpression .)


state 215

    (57) superexpressionB -> | | superexpression .

    ,               reduce using rule 57 (superexpressionB -> | | superexpression .)
    ;               reduce using rule 57 (superexpressionB -> | | superexpression .)
    ]               reduce using rule 57 (superexpressionB -> | | superexpression .)
    )               reduce using rule 57 (superexpressionB -> | | superexpression .)


state 216

    (118) dimensionsB -> [ superexpression . ]

    ]               shift and go to state 226


state 217

    (89) whileloop -> WHILE ( superexpression ) block .

    ID              reduce using rule 89 (whileloop -> WHILE ( superexpression ) block .)
    PRINT           reduce using rule 89 (whileloop -> WHILE ( superexpression ) block .)
    RETURN          reduce using rule 89 (whileloop -> WHILE ( superexpression ) block .)
    INPUT           reduce using rule 89 (whileloop -> WHILE ( superexpression ) block .)
    IF              reduce using rule 89 (whileloop -> WHILE ( superexpression ) block .)
    WHILE           reduce using rule 89 (whileloop -> WHILE ( superexpression ) block .)
    FOR             reduce using rule 89 (whileloop -> WHILE ( superexpression ) block .)
    INT             reduce using rule 89 (whileloop -> WHILE ( superexpression ) block .)
    FLOAT           reduce using rule 89 (whileloop -> WHILE ( superexpression ) block .)
    STRING          reduce using rule 89 (whileloop -> WHILE ( superexpression ) block .)
    BOOL            reduce using rule 89 (whileloop -> WHILE ( superexpression ) block .)
    #               reduce using rule 89 (whileloop -> WHILE ( superexpression ) block .)
    TRACKDECISION   reduce using rule 89 (whileloop -> WHILE ( superexpression ) block .)
    FORGETDECISION  reduce using rule 89 (whileloop -> WHILE ( superexpression ) block .)
    }               reduce using rule 89 (whileloop -> WHILE ( superexpression ) block .)


state 218

    (104) outputC -> , outputB .

    ;               reduce using rule 104 (outputC -> , outputB .)


state 219

    (33) assign -> ID dimensionsOpt = . superexpression
    (55) superexpression -> . expression superexpressionB
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 227
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95
    empty                          shift and go to state 89

state 220

    (96) forloop -> FOR ( assign ; superexpression . ; superexpression ) block

    ;               shift and go to state 228


state 221

    (98) inputB -> , ID . inputB
    (98) inputB -> . , ID inputB
    (99) inputB -> . empty
    (124) empty -> .

    ,               shift and go to state 195
    )               reduce using rule 124 (empty -> .)

    inputB                         shift and go to state 229
    empty                          shift and go to state 197

state 222

    (97) input -> INPUT ( ID inputB ) .

    ;               reduce using rule 97 (input -> INPUT ( ID inputB ) .)


state 223

    (115) funccallC -> , funccallB . funccallC
    (115) funccallC -> . , funccallB funccallC
    (116) funccallC -> . )

    ,               shift and go to state 200
    )               shift and go to state 199

    funccallC                      shift and go to state 230

state 224

    (37) condition -> IF ( superexpression ) block . else
    (38) else -> . ELSE block
    (39) else -> . empty
    (124) empty -> .

    ELSE            shift and go to state 233
    ID              reduce using rule 124 (empty -> .)
    PRINT           reduce using rule 124 (empty -> .)
    RETURN          reduce using rule 124 (empty -> .)
    INPUT           reduce using rule 124 (empty -> .)
    IF              reduce using rule 124 (empty -> .)
    WHILE           reduce using rule 124 (empty -> .)
    FOR             reduce using rule 124 (empty -> .)
    INT             reduce using rule 124 (empty -> .)
    FLOAT           reduce using rule 124 (empty -> .)
    STRING          reduce using rule 124 (empty -> .)
    BOOL            reduce using rule 124 (empty -> .)
    #               reduce using rule 124 (empty -> .)
    TRACKDECISION   reduce using rule 124 (empty -> .)
    FORGETDECISION  reduce using rule 124 (empty -> .)
    }               reduce using rule 124 (empty -> .)

    empty                          shift and go to state 232
    else                           shift and go to state 231

state 225

    (122) paramsB -> , params . paramsB
    (122) paramsB -> . , params paramsB
    (123) paramsB -> . empty
    (124) empty -> .

    ,               shift and go to state 205
    )               reduce using rule 124 (empty -> .)

    paramsB                        shift and go to state 234
    empty                          shift and go to state 206

state 226

    (118) dimensionsB -> [ superexpression ] .

    =               reduce using rule 118 (dimensionsB -> [ superexpression ] .)
    ,               reduce using rule 118 (dimensionsB -> [ superexpression ] .)
    ;               reduce using rule 118 (dimensionsB -> [ superexpression ] .)
    /               reduce using rule 118 (dimensionsB -> [ superexpression ] .)
    *               reduce using rule 118 (dimensionsB -> [ superexpression ] .)
    -               reduce using rule 118 (dimensionsB -> [ superexpression ] .)
    +               reduce using rule 118 (dimensionsB -> [ superexpression ] .)
    <               reduce using rule 118 (dimensionsB -> [ superexpression ] .)
    >               reduce using rule 118 (dimensionsB -> [ superexpression ] .)
    &               reduce using rule 118 (dimensionsB -> [ superexpression ] .)
    |               reduce using rule 118 (dimensionsB -> [ superexpression ] .)
    ]               reduce using rule 118 (dimensionsB -> [ superexpression ] .)
    )               reduce using rule 118 (dimensionsB -> [ superexpression ] .)


state 227

    (33) assign -> ID dimensionsOpt = superexpression .

    ;               reduce using rule 33 (assign -> ID dimensionsOpt = superexpression .)


state 228

    (96) forloop -> FOR ( assign ; superexpression ; . superexpression ) block
    (55) superexpression -> . expression superexpressionB
    (59) expression -> . exp expressionB
    (67) exp -> . term expB
    (71) term -> . factor termB
    (75) factor -> . signB constant
    (76) factor -> . ( superexpression )
    (77) factor -> . funccall
    (78) factor -> . ID seen_ID dimensionsOpt
    (80) signB -> . sign
    (81) signB -> . empty
    (112) funccall -> . ID ( funccallB funccallC
    (87) sign -> . +
    (88) sign -> . -
    (124) empty -> .

    (               shift and go to state 85
    ID              shift and go to state 92
    +               shift and go to state 86
    -               shift and go to state 87
    FCONST          reduce using rule 124 (empty -> .)
    ICONST          reduce using rule 124 (empty -> .)
    SCONST          reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    term                           shift and go to state 93
    funccall                       shift and go to state 90
    signB                          shift and go to state 84
    sign                           shift and go to state 83
    superexpression                shift and go to state 235
    empty                          shift and go to state 89
    exp                            shift and go to state 94
    factor                         shift and go to state 88
    expression                     shift and go to state 95

state 229

    (98) inputB -> , ID inputB .

    )               reduce using rule 98 (inputB -> , ID inputB .)


state 230

    (115) funccallC -> , funccallB funccallC .

    /               reduce using rule 115 (funccallC -> , funccallB funccallC .)
    *               reduce using rule 115 (funccallC -> , funccallB funccallC .)
    -               reduce using rule 115 (funccallC -> , funccallB funccallC .)
    +               reduce using rule 115 (funccallC -> , funccallB funccallC .)
    <               reduce using rule 115 (funccallC -> , funccallB funccallC .)
    >               reduce using rule 115 (funccallC -> , funccallB funccallC .)
    =               reduce using rule 115 (funccallC -> , funccallB funccallC .)
    &               reduce using rule 115 (funccallC -> , funccallB funccallC .)
    |               reduce using rule 115 (funccallC -> , funccallB funccallC .)
    ,               reduce using rule 115 (funccallC -> , funccallB funccallC .)
    ;               reduce using rule 115 (funccallC -> , funccallB funccallC .)
    ]               reduce using rule 115 (funccallC -> , funccallB funccallC .)
    )               reduce using rule 115 (funccallC -> , funccallB funccallC .)


state 231

    (37) condition -> IF ( superexpression ) block else .

    ID              reduce using rule 37 (condition -> IF ( superexpression ) block else .)
    PRINT           reduce using rule 37 (condition -> IF ( superexpression ) block else .)
    RETURN          reduce using rule 37 (condition -> IF ( superexpression ) block else .)
    INPUT           reduce using rule 37 (condition -> IF ( superexpression ) block else .)
    IF              reduce using rule 37 (condition -> IF ( superexpression ) block else .)
    WHILE           reduce using rule 37 (condition -> IF ( superexpression ) block else .)
    FOR             reduce using rule 37 (condition -> IF ( superexpression ) block else .)
    INT             reduce using rule 37 (condition -> IF ( superexpression ) block else .)
    FLOAT           reduce using rule 37 (condition -> IF ( superexpression ) block else .)
    STRING          reduce using rule 37 (condition -> IF ( superexpression ) block else .)
    BOOL            reduce using rule 37 (condition -> IF ( superexpression ) block else .)
    #               reduce using rule 37 (condition -> IF ( superexpression ) block else .)
    TRACKDECISION   reduce using rule 37 (condition -> IF ( superexpression ) block else .)
    FORGETDECISION  reduce using rule 37 (condition -> IF ( superexpression ) block else .)
    }               reduce using rule 37 (condition -> IF ( superexpression ) block else .)


state 232

    (39) else -> empty .

    ID              reduce using rule 39 (else -> empty .)
    PRINT           reduce using rule 39 (else -> empty .)
    RETURN          reduce using rule 39 (else -> empty .)
    INPUT           reduce using rule 39 (else -> empty .)
    IF              reduce using rule 39 (else -> empty .)
    WHILE           reduce using rule 39 (else -> empty .)
    FOR             reduce using rule 39 (else -> empty .)
    INT             reduce using rule 39 (else -> empty .)
    FLOAT           reduce using rule 39 (else -> empty .)
    STRING          reduce using rule 39 (else -> empty .)
    BOOL            reduce using rule 39 (else -> empty .)
    #               reduce using rule 39 (else -> empty .)
    TRACKDECISION   reduce using rule 39 (else -> empty .)
    FORGETDECISION  reduce using rule 39 (else -> empty .)
    }               reduce using rule 39 (else -> empty .)


state 233

    (38) else -> ELSE . block
    (30) block -> . { instructionsOpt }

    {               shift and go to state 41

    block                          shift and go to state 236

state 234

    (122) paramsB -> , params paramsB .

    )               reduce using rule 122 (paramsB -> , params paramsB .)


state 235

    (96) forloop -> FOR ( assign ; superexpression ; superexpression . ) block

    )               shift and go to state 237


state 236

    (38) else -> ELSE block .

    ID              reduce using rule 38 (else -> ELSE block .)
    PRINT           reduce using rule 38 (else -> ELSE block .)
    RETURN          reduce using rule 38 (else -> ELSE block .)
    INPUT           reduce using rule 38 (else -> ELSE block .)
    IF              reduce using rule 38 (else -> ELSE block .)
    WHILE           reduce using rule 38 (else -> ELSE block .)
    FOR             reduce using rule 38 (else -> ELSE block .)
    INT             reduce using rule 38 (else -> ELSE block .)
    FLOAT           reduce using rule 38 (else -> ELSE block .)
    STRING          reduce using rule 38 (else -> ELSE block .)
    BOOL            reduce using rule 38 (else -> ELSE block .)
    #               reduce using rule 38 (else -> ELSE block .)
    TRACKDECISION   reduce using rule 38 (else -> ELSE block .)
    FORGETDECISION  reduce using rule 38 (else -> ELSE block .)
    }               reduce using rule 38 (else -> ELSE block .)


state 237

    (96) forloop -> FOR ( assign ; superexpression ; superexpression ) . block
    (30) block -> . { instructionsOpt }

    {               shift and go to state 41

    block                          shift and go to state 238

state 238

    (96) forloop -> FOR ( assign ; superexpression ; superexpression ) block .

    ID              reduce using rule 96 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    PRINT           reduce using rule 96 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    RETURN          reduce using rule 96 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    INPUT           reduce using rule 96 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    IF              reduce using rule 96 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    WHILE           reduce using rule 96 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    FOR             reduce using rule 96 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    INT             reduce using rule 96 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    FLOAT           reduce using rule 96 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    STRING          reduce using rule 96 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    BOOL            reduce using rule 96 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    #               reduce using rule 96 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    TRACKDECISION   reduce using rule 96 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    FORGETDECISION  reduce using rule 96 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    }               reduce using rule 96 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 41 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 41 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 41 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 41 resolved as shift
WARNING: shift/reduce conflict for IF in state 41 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 41 resolved as shift
WARNING: shift/reduce conflict for FOR in state 41 resolved as shift
WARNING: shift/reduce conflict for INT in state 41 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 41 resolved as shift
WARNING: shift/reduce conflict for STRING in state 41 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 41 resolved as shift
WARNING: shift/reduce conflict for # in state 41 resolved as shift
WARNING: shift/reduce conflict for TRACKDECISION in state 41 resolved as shift
WARNING: shift/reduce conflict for FORGETDECISION in state 41 resolved as shift
WARNING: shift/reduce conflict for ID in state 77 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 77 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 77 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 77 resolved as shift
WARNING: shift/reduce conflict for IF in state 77 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 77 resolved as shift
WARNING: shift/reduce conflict for FOR in state 77 resolved as shift
WARNING: shift/reduce conflict for INT in state 77 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 77 resolved as shift
WARNING: shift/reduce conflict for STRING in state 77 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 77 resolved as shift
WARNING: shift/reduce conflict for # in state 77 resolved as shift
WARNING: shift/reduce conflict for TRACKDECISION in state 77 resolved as shift
WARNING: shift/reduce conflict for FORGETDECISION in state 77 resolved as shift
WARNING: shift/reduce conflict for SCONST in state 101 resolved as shift
WARNING: shift/reduce conflict for SCONST in state 191 resolved as shift
WARNING: reduce/reduce conflict in state 65 resolved using rule (instructionsOpt -> empty)
WARNING: rejected rule (localdecisiondirective -> empty) in state 65
