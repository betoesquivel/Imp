Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL

Grammar

Rule 0     S' -> program
Rule 1     program -> config body
Rule 2     config -> configdirective config
Rule 3     config -> empty
Rule 4     configdirective -> VARSCONFIG = options
Rule 5     configdirective -> DECISIONSCONFIG = options
Rule 6     configdirective -> COMPLEXITYCONFIG = optionsyesno
Rule 7     options -> SOME
Rule 8     options -> ALL
Rule 9     options -> MOST
Rule 10    options -> NONE
Rule 11    optionsyesno -> YES
Rule 12    optionsyesno -> NO
Rule 13    body -> declarationsOpt funcsOpt main funcsOpt
Rule 14    funcsOpt -> func funcsOpt
Rule 15    funcsOpt -> empty
Rule 16    declarationsOpt -> declaration declarationsOpt
Rule 17    declarationsOpt -> empty
Rule 18    declaration -> type declarationB
Rule 19    declarationB -> ID dimensionsOpt declarationC
Rule 20    declarationC -> = superexpression declarationD
Rule 21    declarationC -> , declarationB
Rule 22    declarationC -> ;
Rule 23    declarationD -> , declarationB
Rule 24    declarationD -> ;
Rule 25    main -> MAIN ( ) block
Rule 26    func -> DEF returntype ID ( paramsOpt ) block
Rule 27    paramsOpt -> params
Rule 28    paramsOpt -> empty
Rule 29    block -> { instructionsOpt }
Rule 30    instructionsOpt -> instruction instructionsOpt
Rule 31    instructionsOpt -> empty
Rule 32    assign -> ID dimensionsOpt = superexpression
Rule 33    assignB -> dimensionsOpt = superexpression
Rule 34    dimensionsOpt -> dimensions
Rule 35    dimensionsOpt -> empty
Rule 36    condition -> IF ( superexpression ) block else
Rule 37    else -> ELSE block
Rule 38    else -> empty
Rule 39    instruction -> assignfunccall ;
Rule 40    instruction -> output ;
Rule 41    instruction -> input ;
Rule 42    instruction -> return ;
Rule 43    instruction -> declaration ;
Rule 44    instruction -> condition
Rule 45    instruction -> whileloop
Rule 46    instruction -> forloop
Rule 47    instruction -> localdirective
Rule 48    assignfunccall -> ID assignfunccallB
Rule 49    assignfunccallB -> ( funccallB
Rule 50    assignfunccallB -> assignB
Rule 51    localdirective -> localvardirective
Rule 52    localdirective -> localdecisiondirective
Rule 53    localdirective -> localmsgdirective
Rule 54    superexpression -> expression superexpressionB
Rule 55    superexpressionB -> & & superexpression
Rule 56    superexpressionB -> | | superexpression
Rule 57    superexpressionB -> empty
Rule 58    expression -> exp expressionB
Rule 59    expressionB -> < exp
Rule 60    expressionB -> > exp
Rule 61    expressionB -> < > exp
Rule 62    expressionB -> = = exp
Rule 63    expressionB -> < = exp
Rule 64    expressionB -> > = exp
Rule 65    expressionB -> empty
Rule 66    exp -> term expB
Rule 67    expB -> - exp
Rule 68    expB -> + exp
Rule 69    expB -> empty
Rule 70    term -> factor termB
Rule 71    termB -> / term
Rule 72    termB -> * term
Rule 73    termB -> empty
Rule 74    factor -> signB constant
Rule 75    factor -> ( superexpression )
Rule 76    factor -> funccall
Rule 77    factor -> ID dimensionsOpt
Rule 78    signB -> sign
Rule 79    signB -> empty
Rule 80    constant -> FCONST
Rule 81    constant -> ICONST
Rule 82    constant -> TRUE
Rule 83    constant -> FALSE
Rule 84    sign -> +
Rule 85    sign -> -
Rule 86    whileloop -> WHILE ( superexpression ) block
Rule 87    type -> INT
Rule 88    type -> FLOAT
Rule 89    type -> STRING
Rule 90    returntype -> VOID
Rule 91    returntype -> type
Rule 92    forloop -> FOR ( assign ; superexpression ; superexpression ) block
Rule 93    input -> INPUT ( ID inputB )
Rule 94    inputB -> , ID inputB
Rule 95    inputB -> empty
Rule 96    output -> PRINT ( outputB
Rule 97    outputB -> STRING outputC
Rule 98    outputB -> superexpression outputC
Rule 99    outputC -> )
Rule 100   outputC -> , outputB
Rule 101   localvardirective -> # localvardirectiveB ID
Rule 102   localvardirectiveB -> TRACK
Rule 103   localvardirectiveB -> FORGET
Rule 104   localmsgdirective -> # SHOW STRING
Rule 105   localdecisiondirective -> TRACKDECISION
Rule 106   localdecisiondirective -> FORGETDECISION
Rule 107   localdecisiondirective -> empty
Rule 108   funccall -> DEF ID ( funccallB
Rule 109   funccallB -> superexpression funccallC
Rule 110   funccallB -> )
Rule 111   funccallC -> , superexpression funccallC
Rule 112   funccallC -> )
Rule 113   dimensions -> [ superexpression ] dimensionsB
Rule 114   dimensionsB -> [ superexpression ]
Rule 115   return -> RETURN superexpression
Rule 116   params -> type ID paramsB
Rule 117   paramsB -> , type ID paramsB
Rule 118   paramsB -> empty
Rule 119   empty -> <empty>

Terminals, with rules where they appear

#                    : 101 104
&                    : 55 55
(                    : 25 26 36 49 75 86 92 93 96 108
)                    : 25 26 36 75 86 92 93 99 110 112
*                    : 72
+                    : 68 84
,                    : 21 23 94 100 111 117
-                    : 67 85
/                    : 71
;                    : 22 24 39 40 41 42 43 92 92
<                    : 59 61 63
=                    : 4 5 6 20 32 33 62 62 63 64
>                    : 60 61 64
ALL                  : 8
BOOL                 : 
COMPLEXITYCONFIG     : 6
DECISIONSCONFIG      : 5
DEF                  : 26 108
ELSE                 : 37
FALSE                : 83
FCONST               : 80
FLOAT                : 88
FOR                  : 92
FORGET               : 103
FORGETDECISION       : 106
ICONST               : 81
ID                   : 19 26 32 48 77 93 94 101 108 116 117
IF                   : 36
INPUT                : 93
INT                  : 87
MAIN                 : 25
MOST                 : 9
NO                   : 12
NONE                 : 10
PRINT                : 96
RETURN               : 115
SHOW                 : 104
SOME                 : 7
STRING               : 89 97 104
TRACK                : 102
TRACKDECISION        : 105
TRUE                 : 82
VARSCONFIG           : 4
VOID                 : 90
WHILE                : 86
YES                  : 11
[                    : 113 114
]                    : 113 114
error                : 
{                    : 29
|                    : 56 56
}                    : 29

Nonterminals, with rules where they appear

assign               : 92
assignB              : 50
assignfunccall       : 39
assignfunccallB      : 48
block                : 25 26 36 37 86 92
body                 : 1
condition            : 44
config               : 1 2
configdirective      : 2
constant             : 74
declaration          : 16 43
declarationB         : 18 21 23
declarationC         : 19
declarationD         : 20
declarationsOpt      : 13 16
dimensions           : 34
dimensionsB          : 113
dimensionsOpt        : 19 32 33 77
else                 : 36
empty                : 3 15 17 28 31 35 38 57 65 69 73 79 95 107 118
exp                  : 58 59 60 61 62 63 64 67 68
expB                 : 66
expression           : 54
expressionB          : 58
factor               : 70
forloop              : 46
func                 : 14
funccall             : 76
funccallB            : 49 108
funccallC            : 109 111
funcsOpt             : 13 13 14
input                : 41
inputB               : 93 94
instruction          : 30
instructionsOpt      : 29 30
localdecisiondirective : 52
localdirective       : 47
localmsgdirective    : 53
localvardirective    : 51
localvardirectiveB   : 101
main                 : 13
options              : 4 5
optionsyesno         : 6
output               : 40
outputB              : 96 100
outputC              : 97 98
params               : 27
paramsB              : 116 117
paramsOpt            : 26
program              : 0
return               : 42
returntype           : 26
sign                 : 78
signB                : 74
superexpression      : 20 32 33 36 55 56 75 86 92 92 98 109 111 113 114 115
superexpressionB     : 54
term                 : 66 71 72
termB                : 70
type                 : 18 91 116 117
whileloop            : 45

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . config body
    (2) config -> . configdirective config
    (3) config -> . empty
    (4) configdirective -> . VARSCONFIG = options
    (5) configdirective -> . DECISIONSCONFIG = options
    (6) configdirective -> . COMPLEXITYCONFIG = optionsyesno
    (119) empty -> .

    VARSCONFIG      shift and go to state 2
    DECISIONSCONFIG shift and go to state 1
    COMPLEXITYCONFIG shift and go to state 4
    INT             reduce using rule 119 (empty -> .)
    FLOAT           reduce using rule 119 (empty -> .)
    STRING          reduce using rule 119 (empty -> .)
    DEF             reduce using rule 119 (empty -> .)
    MAIN            reduce using rule 119 (empty -> .)

    configdirective                shift and go to state 3
    program                        shift and go to state 5
    config                         shift and go to state 6
    empty                          shift and go to state 7

state 1

    (5) configdirective -> DECISIONSCONFIG . = options

    =               shift and go to state 8


state 2

    (4) configdirective -> VARSCONFIG . = options

    =               shift and go to state 9


state 3

    (2) config -> configdirective . config
    (2) config -> . configdirective config
    (3) config -> . empty
    (4) configdirective -> . VARSCONFIG = options
    (5) configdirective -> . DECISIONSCONFIG = options
    (6) configdirective -> . COMPLEXITYCONFIG = optionsyesno
    (119) empty -> .

    VARSCONFIG      shift and go to state 2
    DECISIONSCONFIG shift and go to state 1
    COMPLEXITYCONFIG shift and go to state 4
    INT             reduce using rule 119 (empty -> .)
    FLOAT           reduce using rule 119 (empty -> .)
    STRING          reduce using rule 119 (empty -> .)
    DEF             reduce using rule 119 (empty -> .)
    MAIN            reduce using rule 119 (empty -> .)

    config                         shift and go to state 10
    empty                          shift and go to state 7
    configdirective                shift and go to state 3

state 4

    (6) configdirective -> COMPLEXITYCONFIG . = optionsyesno

    =               shift and go to state 11


state 5

    (0) S' -> program .



state 6

    (1) program -> config . body
    (13) body -> . declarationsOpt funcsOpt main funcsOpt
    (16) declarationsOpt -> . declaration declarationsOpt
    (17) declarationsOpt -> . empty
    (18) declaration -> . type declarationB
    (119) empty -> .
    (87) type -> . INT
    (88) type -> . FLOAT
    (89) type -> . STRING

    DEF             reduce using rule 119 (empty -> .)
    MAIN            reduce using rule 119 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14

    body                           shift and go to state 12
    declarationsOpt                shift and go to state 13
    type                           shift and go to state 16
    declaration                    shift and go to state 18
    empty                          shift and go to state 19

state 7

    (3) config -> empty .

    INT             reduce using rule 3 (config -> empty .)
    FLOAT           reduce using rule 3 (config -> empty .)
    STRING          reduce using rule 3 (config -> empty .)
    DEF             reduce using rule 3 (config -> empty .)
    MAIN            reduce using rule 3 (config -> empty .)


state 8

    (5) configdirective -> DECISIONSCONFIG = . options
    (7) options -> . SOME
    (8) options -> . ALL
    (9) options -> . MOST
    (10) options -> . NONE

    SOME            shift and go to state 21
    ALL             shift and go to state 20
    MOST            shift and go to state 23
    NONE            shift and go to state 22

    options                        shift and go to state 24

state 9

    (4) configdirective -> VARSCONFIG = . options
    (7) options -> . SOME
    (8) options -> . ALL
    (9) options -> . MOST
    (10) options -> . NONE

    SOME            shift and go to state 21
    ALL             shift and go to state 20
    MOST            shift and go to state 23
    NONE            shift and go to state 22

    options                        shift and go to state 25

state 10

    (2) config -> configdirective config .

    INT             reduce using rule 2 (config -> configdirective config .)
    FLOAT           reduce using rule 2 (config -> configdirective config .)
    STRING          reduce using rule 2 (config -> configdirective config .)
    DEF             reduce using rule 2 (config -> configdirective config .)
    MAIN            reduce using rule 2 (config -> configdirective config .)


state 11

    (6) configdirective -> COMPLEXITYCONFIG = . optionsyesno
    (11) optionsyesno -> . YES
    (12) optionsyesno -> . NO

    YES             shift and go to state 26
    NO              shift and go to state 28

    optionsyesno                   shift and go to state 27

state 12

    (1) program -> config body .

    $end            reduce using rule 1 (program -> config body .)


state 13

    (13) body -> declarationsOpt . funcsOpt main funcsOpt
    (14) funcsOpt -> . func funcsOpt
    (15) funcsOpt -> . empty
    (26) func -> . DEF returntype ID ( paramsOpt ) block
    (119) empty -> .

    DEF             shift and go to state 32
    MAIN            reduce using rule 119 (empty -> .)

    funcsOpt                       shift and go to state 29
    func                           shift and go to state 31
    empty                          shift and go to state 30

state 14

    (89) type -> STRING .

    ID              reduce using rule 89 (type -> STRING .)


state 15

    (87) type -> INT .

    ID              reduce using rule 87 (type -> INT .)


state 16

    (18) declaration -> type . declarationB
    (19) declarationB -> . ID dimensionsOpt declarationC

    ID              shift and go to state 34

    declarationB                   shift and go to state 33

state 17

    (88) type -> FLOAT .

    ID              reduce using rule 88 (type -> FLOAT .)


state 18

    (16) declarationsOpt -> declaration . declarationsOpt
    (16) declarationsOpt -> . declaration declarationsOpt
    (17) declarationsOpt -> . empty
    (18) declaration -> . type declarationB
    (119) empty -> .
    (87) type -> . INT
    (88) type -> . FLOAT
    (89) type -> . STRING

    DEF             reduce using rule 119 (empty -> .)
    MAIN            reduce using rule 119 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14

    declarationsOpt                shift and go to state 35
    type                           shift and go to state 16
    empty                          shift and go to state 19
    declaration                    shift and go to state 18

state 19

    (17) declarationsOpt -> empty .

    DEF             reduce using rule 17 (declarationsOpt -> empty .)
    MAIN            reduce using rule 17 (declarationsOpt -> empty .)


state 20

    (8) options -> ALL .

    VARSCONFIG      reduce using rule 8 (options -> ALL .)
    DECISIONSCONFIG reduce using rule 8 (options -> ALL .)
    COMPLEXITYCONFIG reduce using rule 8 (options -> ALL .)
    INT             reduce using rule 8 (options -> ALL .)
    FLOAT           reduce using rule 8 (options -> ALL .)
    STRING          reduce using rule 8 (options -> ALL .)
    DEF             reduce using rule 8 (options -> ALL .)
    MAIN            reduce using rule 8 (options -> ALL .)


state 21

    (7) options -> SOME .

    VARSCONFIG      reduce using rule 7 (options -> SOME .)
    DECISIONSCONFIG reduce using rule 7 (options -> SOME .)
    COMPLEXITYCONFIG reduce using rule 7 (options -> SOME .)
    INT             reduce using rule 7 (options -> SOME .)
    FLOAT           reduce using rule 7 (options -> SOME .)
    STRING          reduce using rule 7 (options -> SOME .)
    DEF             reduce using rule 7 (options -> SOME .)
    MAIN            reduce using rule 7 (options -> SOME .)


state 22

    (10) options -> NONE .

    VARSCONFIG      reduce using rule 10 (options -> NONE .)
    DECISIONSCONFIG reduce using rule 10 (options -> NONE .)
    COMPLEXITYCONFIG reduce using rule 10 (options -> NONE .)
    INT             reduce using rule 10 (options -> NONE .)
    FLOAT           reduce using rule 10 (options -> NONE .)
    STRING          reduce using rule 10 (options -> NONE .)
    DEF             reduce using rule 10 (options -> NONE .)
    MAIN            reduce using rule 10 (options -> NONE .)


state 23

    (9) options -> MOST .

    VARSCONFIG      reduce using rule 9 (options -> MOST .)
    DECISIONSCONFIG reduce using rule 9 (options -> MOST .)
    COMPLEXITYCONFIG reduce using rule 9 (options -> MOST .)
    INT             reduce using rule 9 (options -> MOST .)
    FLOAT           reduce using rule 9 (options -> MOST .)
    STRING          reduce using rule 9 (options -> MOST .)
    DEF             reduce using rule 9 (options -> MOST .)
    MAIN            reduce using rule 9 (options -> MOST .)


state 24

    (5) configdirective -> DECISIONSCONFIG = options .

    VARSCONFIG      reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    DECISIONSCONFIG reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    COMPLEXITYCONFIG reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    INT             reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    FLOAT           reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    STRING          reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    DEF             reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    MAIN            reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)


state 25

    (4) configdirective -> VARSCONFIG = options .

    VARSCONFIG      reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    DECISIONSCONFIG reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    COMPLEXITYCONFIG reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    INT             reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    FLOAT           reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    STRING          reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    DEF             reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    MAIN            reduce using rule 4 (configdirective -> VARSCONFIG = options .)


state 26

    (11) optionsyesno -> YES .

    VARSCONFIG      reduce using rule 11 (optionsyesno -> YES .)
    DECISIONSCONFIG reduce using rule 11 (optionsyesno -> YES .)
    COMPLEXITYCONFIG reduce using rule 11 (optionsyesno -> YES .)
    INT             reduce using rule 11 (optionsyesno -> YES .)
    FLOAT           reduce using rule 11 (optionsyesno -> YES .)
    STRING          reduce using rule 11 (optionsyesno -> YES .)
    DEF             reduce using rule 11 (optionsyesno -> YES .)
    MAIN            reduce using rule 11 (optionsyesno -> YES .)


state 27

    (6) configdirective -> COMPLEXITYCONFIG = optionsyesno .

    VARSCONFIG      reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    DECISIONSCONFIG reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    COMPLEXITYCONFIG reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    INT             reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    FLOAT           reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    STRING          reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    DEF             reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    MAIN            reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)


state 28

    (12) optionsyesno -> NO .

    VARSCONFIG      reduce using rule 12 (optionsyesno -> NO .)
    DECISIONSCONFIG reduce using rule 12 (optionsyesno -> NO .)
    COMPLEXITYCONFIG reduce using rule 12 (optionsyesno -> NO .)
    INT             reduce using rule 12 (optionsyesno -> NO .)
    FLOAT           reduce using rule 12 (optionsyesno -> NO .)
    STRING          reduce using rule 12 (optionsyesno -> NO .)
    DEF             reduce using rule 12 (optionsyesno -> NO .)
    MAIN            reduce using rule 12 (optionsyesno -> NO .)


state 29

    (13) body -> declarationsOpt funcsOpt . main funcsOpt
    (25) main -> . MAIN ( ) block

    MAIN            shift and go to state 36

    main                           shift and go to state 37

state 30

    (15) funcsOpt -> empty .

    MAIN            reduce using rule 15 (funcsOpt -> empty .)
    $end            reduce using rule 15 (funcsOpt -> empty .)


state 31

    (14) funcsOpt -> func . funcsOpt
    (14) funcsOpt -> . func funcsOpt
    (15) funcsOpt -> . empty
    (26) func -> . DEF returntype ID ( paramsOpt ) block
    (119) empty -> .

    DEF             shift and go to state 32
    MAIN            reduce using rule 119 (empty -> .)
    $end            reduce using rule 119 (empty -> .)

    funcsOpt                       shift and go to state 38
    empty                          shift and go to state 30
    func                           shift and go to state 31

state 32

    (26) func -> DEF . returntype ID ( paramsOpt ) block
    (90) returntype -> . VOID
    (91) returntype -> . type
    (87) type -> . INT
    (88) type -> . FLOAT
    (89) type -> . STRING

    VOID            shift and go to state 39
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14

    returntype                     shift and go to state 40
    type                           shift and go to state 41

state 33

    (18) declaration -> type declarationB .

    INT             reduce using rule 18 (declaration -> type declarationB .)
    FLOAT           reduce using rule 18 (declaration -> type declarationB .)
    STRING          reduce using rule 18 (declaration -> type declarationB .)
    DEF             reduce using rule 18 (declaration -> type declarationB .)
    MAIN            reduce using rule 18 (declaration -> type declarationB .)
    ;               reduce using rule 18 (declaration -> type declarationB .)


state 34

    (19) declarationB -> ID . dimensionsOpt declarationC
    (34) dimensionsOpt -> . dimensions
    (35) dimensionsOpt -> . empty
    (113) dimensions -> . [ superexpression ] dimensionsB
    (119) empty -> .

    [               shift and go to state 44
    =               reduce using rule 119 (empty -> .)
    ,               reduce using rule 119 (empty -> .)
    ;               reduce using rule 119 (empty -> .)

    dimensionsOpt                  shift and go to state 42
    dimensions                     shift and go to state 43
    empty                          shift and go to state 45

state 35

    (16) declarationsOpt -> declaration declarationsOpt .

    DEF             reduce using rule 16 (declarationsOpt -> declaration declarationsOpt .)
    MAIN            reduce using rule 16 (declarationsOpt -> declaration declarationsOpt .)


state 36

    (25) main -> MAIN . ( ) block

    (               shift and go to state 46


state 37

    (13) body -> declarationsOpt funcsOpt main . funcsOpt
    (14) funcsOpt -> . func funcsOpt
    (15) funcsOpt -> . empty
    (26) func -> . DEF returntype ID ( paramsOpt ) block
    (119) empty -> .

    DEF             shift and go to state 32
    $end            reduce using rule 119 (empty -> .)

    funcsOpt                       shift and go to state 47
    func                           shift and go to state 31
    empty                          shift and go to state 30

state 38

    (14) funcsOpt -> func funcsOpt .

    MAIN            reduce using rule 14 (funcsOpt -> func funcsOpt .)
    $end            reduce using rule 14 (funcsOpt -> func funcsOpt .)


state 39

    (90) returntype -> VOID .

    ID              reduce using rule 90 (returntype -> VOID .)


state 40

    (26) func -> DEF returntype . ID ( paramsOpt ) block

    ID              shift and go to state 48


state 41

    (91) returntype -> type .

    ID              reduce using rule 91 (returntype -> type .)


state 42

    (19) declarationB -> ID dimensionsOpt . declarationC
    (20) declarationC -> . = superexpression declarationD
    (21) declarationC -> . , declarationB
    (22) declarationC -> . ;

    =               shift and go to state 49
    ,               shift and go to state 50
    ;               shift and go to state 51

    declarationC                   shift and go to state 52

state 43

    (34) dimensionsOpt -> dimensions .

    =               reduce using rule 34 (dimensionsOpt -> dimensions .)
    ,               reduce using rule 34 (dimensionsOpt -> dimensions .)
    ;               reduce using rule 34 (dimensionsOpt -> dimensions .)
    /               reduce using rule 34 (dimensionsOpt -> dimensions .)
    *               reduce using rule 34 (dimensionsOpt -> dimensions .)
    -               reduce using rule 34 (dimensionsOpt -> dimensions .)
    +               reduce using rule 34 (dimensionsOpt -> dimensions .)
    <               reduce using rule 34 (dimensionsOpt -> dimensions .)
    >               reduce using rule 34 (dimensionsOpt -> dimensions .)
    &               reduce using rule 34 (dimensionsOpt -> dimensions .)
    |               reduce using rule 34 (dimensionsOpt -> dimensions .)
    ]               reduce using rule 34 (dimensionsOpt -> dimensions .)
    )               reduce using rule 34 (dimensionsOpt -> dimensions .)


state 44

    (113) dimensions -> [ . superexpression ] dimensionsB
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 62
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66
    empty                          shift and go to state 60

state 45

    (35) dimensionsOpt -> empty .

    =               reduce using rule 35 (dimensionsOpt -> empty .)
    ,               reduce using rule 35 (dimensionsOpt -> empty .)
    ;               reduce using rule 35 (dimensionsOpt -> empty .)
    /               reduce using rule 35 (dimensionsOpt -> empty .)
    *               reduce using rule 35 (dimensionsOpt -> empty .)
    -               reduce using rule 35 (dimensionsOpt -> empty .)
    +               reduce using rule 35 (dimensionsOpt -> empty .)
    <               reduce using rule 35 (dimensionsOpt -> empty .)
    >               reduce using rule 35 (dimensionsOpt -> empty .)
    &               reduce using rule 35 (dimensionsOpt -> empty .)
    |               reduce using rule 35 (dimensionsOpt -> empty .)
    ]               reduce using rule 35 (dimensionsOpt -> empty .)
    )               reduce using rule 35 (dimensionsOpt -> empty .)


state 46

    (25) main -> MAIN ( . ) block

    )               shift and go to state 67


state 47

    (13) body -> declarationsOpt funcsOpt main funcsOpt .

    $end            reduce using rule 13 (body -> declarationsOpt funcsOpt main funcsOpt .)


state 48

    (26) func -> DEF returntype ID . ( paramsOpt ) block

    (               shift and go to state 68


state 49

    (20) declarationC -> = . superexpression declarationD
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 69
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66
    empty                          shift and go to state 60

state 50

    (21) declarationC -> , . declarationB
    (19) declarationB -> . ID dimensionsOpt declarationC

    ID              shift and go to state 34

    declarationB                   shift and go to state 70

state 51

    (22) declarationC -> ; .

    INT             reduce using rule 22 (declarationC -> ; .)
    FLOAT           reduce using rule 22 (declarationC -> ; .)
    STRING          reduce using rule 22 (declarationC -> ; .)
    DEF             reduce using rule 22 (declarationC -> ; .)
    MAIN            reduce using rule 22 (declarationC -> ; .)
    ;               reduce using rule 22 (declarationC -> ; .)


state 52

    (19) declarationB -> ID dimensionsOpt declarationC .

    INT             reduce using rule 19 (declarationB -> ID dimensionsOpt declarationC .)
    FLOAT           reduce using rule 19 (declarationB -> ID dimensionsOpt declarationC .)
    STRING          reduce using rule 19 (declarationB -> ID dimensionsOpt declarationC .)
    DEF             reduce using rule 19 (declarationB -> ID dimensionsOpt declarationC .)
    MAIN            reduce using rule 19 (declarationB -> ID dimensionsOpt declarationC .)
    ;               reduce using rule 19 (declarationB -> ID dimensionsOpt declarationC .)


state 53

    (78) signB -> sign .

    FCONST          reduce using rule 78 (signB -> sign .)
    ICONST          reduce using rule 78 (signB -> sign .)
    TRUE            reduce using rule 78 (signB -> sign .)
    FALSE           reduce using rule 78 (signB -> sign .)


state 54

    (108) funccall -> DEF . ID ( funccallB

    ID              shift and go to state 71


state 55

    (74) factor -> signB . constant
    (80) constant -> . FCONST
    (81) constant -> . ICONST
    (82) constant -> . TRUE
    (83) constant -> . FALSE

    FCONST          shift and go to state 73
    ICONST          shift and go to state 74
    TRUE            shift and go to state 76
    FALSE           shift and go to state 72

    constant                       shift and go to state 75

state 56

    (75) factor -> ( . superexpression )
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 77
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66
    empty                          shift and go to state 60

state 57

    (84) sign -> + .

    FCONST          reduce using rule 84 (sign -> + .)
    ICONST          reduce using rule 84 (sign -> + .)
    TRUE            reduce using rule 84 (sign -> + .)
    FALSE           reduce using rule 84 (sign -> + .)


state 58

    (85) sign -> - .

    FCONST          reduce using rule 85 (sign -> - .)
    ICONST          reduce using rule 85 (sign -> - .)
    TRUE            reduce using rule 85 (sign -> - .)
    FALSE           reduce using rule 85 (sign -> - .)


state 59

    (70) term -> factor . termB
    (71) termB -> . / term
    (72) termB -> . * term
    (73) termB -> . empty
    (119) empty -> .

    /               shift and go to state 79
    *               shift and go to state 78
    -               reduce using rule 119 (empty -> .)
    +               reduce using rule 119 (empty -> .)
    <               reduce using rule 119 (empty -> .)
    >               reduce using rule 119 (empty -> .)
    =               reduce using rule 119 (empty -> .)
    &               reduce using rule 119 (empty -> .)
    |               reduce using rule 119 (empty -> .)
    ]               reduce using rule 119 (empty -> .)
    ,               reduce using rule 119 (empty -> .)
    ;               reduce using rule 119 (empty -> .)
    )               reduce using rule 119 (empty -> .)

    termB                          shift and go to state 80
    empty                          shift and go to state 81

state 60

    (79) signB -> empty .

    FCONST          reduce using rule 79 (signB -> empty .)
    ICONST          reduce using rule 79 (signB -> empty .)
    TRUE            reduce using rule 79 (signB -> empty .)
    FALSE           reduce using rule 79 (signB -> empty .)


state 61

    (76) factor -> funccall .

    /               reduce using rule 76 (factor -> funccall .)
    *               reduce using rule 76 (factor -> funccall .)
    -               reduce using rule 76 (factor -> funccall .)
    +               reduce using rule 76 (factor -> funccall .)
    <               reduce using rule 76 (factor -> funccall .)
    >               reduce using rule 76 (factor -> funccall .)
    =               reduce using rule 76 (factor -> funccall .)
    &               reduce using rule 76 (factor -> funccall .)
    |               reduce using rule 76 (factor -> funccall .)
    ;               reduce using rule 76 (factor -> funccall .)
    ]               reduce using rule 76 (factor -> funccall .)
    ,               reduce using rule 76 (factor -> funccall .)
    )               reduce using rule 76 (factor -> funccall .)


state 62

    (113) dimensions -> [ superexpression . ] dimensionsB

    ]               shift and go to state 82


state 63

    (77) factor -> ID . dimensionsOpt
    (34) dimensionsOpt -> . dimensions
    (35) dimensionsOpt -> . empty
    (113) dimensions -> . [ superexpression ] dimensionsB
    (119) empty -> .

    [               shift and go to state 44
    /               reduce using rule 119 (empty -> .)
    *               reduce using rule 119 (empty -> .)
    -               reduce using rule 119 (empty -> .)
    +               reduce using rule 119 (empty -> .)
    <               reduce using rule 119 (empty -> .)
    >               reduce using rule 119 (empty -> .)
    =               reduce using rule 119 (empty -> .)
    &               reduce using rule 119 (empty -> .)
    |               reduce using rule 119 (empty -> .)
    ]               reduce using rule 119 (empty -> .)
    ,               reduce using rule 119 (empty -> .)
    ;               reduce using rule 119 (empty -> .)
    )               reduce using rule 119 (empty -> .)

    dimensionsOpt                  shift and go to state 83
    dimensions                     shift and go to state 43
    empty                          shift and go to state 45

state 64

    (66) exp -> term . expB
    (67) expB -> . - exp
    (68) expB -> . + exp
    (69) expB -> . empty
    (119) empty -> .

    -               shift and go to state 85
    +               shift and go to state 84
    <               reduce using rule 119 (empty -> .)
    >               reduce using rule 119 (empty -> .)
    =               reduce using rule 119 (empty -> .)
    &               reduce using rule 119 (empty -> .)
    |               reduce using rule 119 (empty -> .)
    ]               reduce using rule 119 (empty -> .)
    ,               reduce using rule 119 (empty -> .)
    ;               reduce using rule 119 (empty -> .)
    )               reduce using rule 119 (empty -> .)

    expB                           shift and go to state 86
    empty                          shift and go to state 87

state 65

    (58) expression -> exp . expressionB
    (59) expressionB -> . < exp
    (60) expressionB -> . > exp
    (61) expressionB -> . < > exp
    (62) expressionB -> . = = exp
    (63) expressionB -> . < = exp
    (64) expressionB -> . > = exp
    (65) expressionB -> . empty
    (119) empty -> .

    <               shift and go to state 90
    >               shift and go to state 92
    =               shift and go to state 89
    &               reduce using rule 119 (empty -> .)
    |               reduce using rule 119 (empty -> .)
    ]               reduce using rule 119 (empty -> .)
    ,               reduce using rule 119 (empty -> .)
    ;               reduce using rule 119 (empty -> .)
    )               reduce using rule 119 (empty -> .)

    expressionB                    shift and go to state 88
    empty                          shift and go to state 91

state 66

    (54) superexpression -> expression . superexpressionB
    (55) superexpressionB -> . & & superexpression
    (56) superexpressionB -> . | | superexpression
    (57) superexpressionB -> . empty
    (119) empty -> .

    &               shift and go to state 93
    |               shift and go to state 95
    ]               reduce using rule 119 (empty -> .)
    ,               reduce using rule 119 (empty -> .)
    ;               reduce using rule 119 (empty -> .)
    )               reduce using rule 119 (empty -> .)

    empty                          shift and go to state 96
    superexpressionB               shift and go to state 94

state 67

    (25) main -> MAIN ( ) . block
    (29) block -> . { instructionsOpt }

    {               shift and go to state 97

    block                          shift and go to state 98

state 68

    (26) func -> DEF returntype ID ( . paramsOpt ) block
    (27) paramsOpt -> . params
    (28) paramsOpt -> . empty
    (116) params -> . type ID paramsB
    (119) empty -> .
    (87) type -> . INT
    (88) type -> . FLOAT
    (89) type -> . STRING

    )               reduce using rule 119 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14

    paramsOpt                      shift and go to state 99
    params                         shift and go to state 101
    type                           shift and go to state 102
    empty                          shift and go to state 100

state 69

    (20) declarationC -> = superexpression . declarationD
    (23) declarationD -> . , declarationB
    (24) declarationD -> . ;

    ,               shift and go to state 103
    ;               shift and go to state 105

    declarationD                   shift and go to state 104

state 70

    (21) declarationC -> , declarationB .

    INT             reduce using rule 21 (declarationC -> , declarationB .)
    FLOAT           reduce using rule 21 (declarationC -> , declarationB .)
    STRING          reduce using rule 21 (declarationC -> , declarationB .)
    DEF             reduce using rule 21 (declarationC -> , declarationB .)
    MAIN            reduce using rule 21 (declarationC -> , declarationB .)
    ;               reduce using rule 21 (declarationC -> , declarationB .)


state 71

    (108) funccall -> DEF ID . ( funccallB

    (               shift and go to state 106


state 72

    (83) constant -> FALSE .

    /               reduce using rule 83 (constant -> FALSE .)
    *               reduce using rule 83 (constant -> FALSE .)
    -               reduce using rule 83 (constant -> FALSE .)
    +               reduce using rule 83 (constant -> FALSE .)
    <               reduce using rule 83 (constant -> FALSE .)
    >               reduce using rule 83 (constant -> FALSE .)
    =               reduce using rule 83 (constant -> FALSE .)
    &               reduce using rule 83 (constant -> FALSE .)
    |               reduce using rule 83 (constant -> FALSE .)
    ]               reduce using rule 83 (constant -> FALSE .)
    ,               reduce using rule 83 (constant -> FALSE .)
    ;               reduce using rule 83 (constant -> FALSE .)
    )               reduce using rule 83 (constant -> FALSE .)


state 73

    (80) constant -> FCONST .

    /               reduce using rule 80 (constant -> FCONST .)
    *               reduce using rule 80 (constant -> FCONST .)
    -               reduce using rule 80 (constant -> FCONST .)
    +               reduce using rule 80 (constant -> FCONST .)
    <               reduce using rule 80 (constant -> FCONST .)
    >               reduce using rule 80 (constant -> FCONST .)
    =               reduce using rule 80 (constant -> FCONST .)
    &               reduce using rule 80 (constant -> FCONST .)
    |               reduce using rule 80 (constant -> FCONST .)
    ]               reduce using rule 80 (constant -> FCONST .)
    ,               reduce using rule 80 (constant -> FCONST .)
    ;               reduce using rule 80 (constant -> FCONST .)
    )               reduce using rule 80 (constant -> FCONST .)


state 74

    (81) constant -> ICONST .

    /               reduce using rule 81 (constant -> ICONST .)
    *               reduce using rule 81 (constant -> ICONST .)
    -               reduce using rule 81 (constant -> ICONST .)
    +               reduce using rule 81 (constant -> ICONST .)
    <               reduce using rule 81 (constant -> ICONST .)
    >               reduce using rule 81 (constant -> ICONST .)
    =               reduce using rule 81 (constant -> ICONST .)
    &               reduce using rule 81 (constant -> ICONST .)
    |               reduce using rule 81 (constant -> ICONST .)
    ]               reduce using rule 81 (constant -> ICONST .)
    ,               reduce using rule 81 (constant -> ICONST .)
    ;               reduce using rule 81 (constant -> ICONST .)
    )               reduce using rule 81 (constant -> ICONST .)


state 75

    (74) factor -> signB constant .

    /               reduce using rule 74 (factor -> signB constant .)
    *               reduce using rule 74 (factor -> signB constant .)
    -               reduce using rule 74 (factor -> signB constant .)
    +               reduce using rule 74 (factor -> signB constant .)
    <               reduce using rule 74 (factor -> signB constant .)
    >               reduce using rule 74 (factor -> signB constant .)
    =               reduce using rule 74 (factor -> signB constant .)
    &               reduce using rule 74 (factor -> signB constant .)
    |               reduce using rule 74 (factor -> signB constant .)
    ;               reduce using rule 74 (factor -> signB constant .)
    ]               reduce using rule 74 (factor -> signB constant .)
    ,               reduce using rule 74 (factor -> signB constant .)
    )               reduce using rule 74 (factor -> signB constant .)


state 76

    (82) constant -> TRUE .

    /               reduce using rule 82 (constant -> TRUE .)
    *               reduce using rule 82 (constant -> TRUE .)
    -               reduce using rule 82 (constant -> TRUE .)
    +               reduce using rule 82 (constant -> TRUE .)
    <               reduce using rule 82 (constant -> TRUE .)
    >               reduce using rule 82 (constant -> TRUE .)
    =               reduce using rule 82 (constant -> TRUE .)
    &               reduce using rule 82 (constant -> TRUE .)
    |               reduce using rule 82 (constant -> TRUE .)
    ]               reduce using rule 82 (constant -> TRUE .)
    ,               reduce using rule 82 (constant -> TRUE .)
    ;               reduce using rule 82 (constant -> TRUE .)
    )               reduce using rule 82 (constant -> TRUE .)


state 77

    (75) factor -> ( superexpression . )

    )               shift and go to state 107


state 78

    (72) termB -> * . term
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 108
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    factor                         shift and go to state 59
    empty                          shift and go to state 60

state 79

    (71) termB -> / . term
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 109
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    factor                         shift and go to state 59
    empty                          shift and go to state 60

state 80

    (70) term -> factor termB .

    -               reduce using rule 70 (term -> factor termB .)
    +               reduce using rule 70 (term -> factor termB .)
    <               reduce using rule 70 (term -> factor termB .)
    >               reduce using rule 70 (term -> factor termB .)
    =               reduce using rule 70 (term -> factor termB .)
    &               reduce using rule 70 (term -> factor termB .)
    |               reduce using rule 70 (term -> factor termB .)
    )               reduce using rule 70 (term -> factor termB .)
    ]               reduce using rule 70 (term -> factor termB .)
    ,               reduce using rule 70 (term -> factor termB .)
    ;               reduce using rule 70 (term -> factor termB .)


state 81

    (73) termB -> empty .

    -               reduce using rule 73 (termB -> empty .)
    +               reduce using rule 73 (termB -> empty .)
    <               reduce using rule 73 (termB -> empty .)
    >               reduce using rule 73 (termB -> empty .)
    =               reduce using rule 73 (termB -> empty .)
    &               reduce using rule 73 (termB -> empty .)
    |               reduce using rule 73 (termB -> empty .)
    ]               reduce using rule 73 (termB -> empty .)
    ,               reduce using rule 73 (termB -> empty .)
    ;               reduce using rule 73 (termB -> empty .)
    )               reduce using rule 73 (termB -> empty .)


state 82

    (113) dimensions -> [ superexpression ] . dimensionsB
    (114) dimensionsB -> . [ superexpression ]

    [               shift and go to state 111

    dimensionsB                    shift and go to state 110

state 83

    (77) factor -> ID dimensionsOpt .

    /               reduce using rule 77 (factor -> ID dimensionsOpt .)
    *               reduce using rule 77 (factor -> ID dimensionsOpt .)
    -               reduce using rule 77 (factor -> ID dimensionsOpt .)
    +               reduce using rule 77 (factor -> ID dimensionsOpt .)
    <               reduce using rule 77 (factor -> ID dimensionsOpt .)
    >               reduce using rule 77 (factor -> ID dimensionsOpt .)
    =               reduce using rule 77 (factor -> ID dimensionsOpt .)
    &               reduce using rule 77 (factor -> ID dimensionsOpt .)
    |               reduce using rule 77 (factor -> ID dimensionsOpt .)
    ;               reduce using rule 77 (factor -> ID dimensionsOpt .)
    ]               reduce using rule 77 (factor -> ID dimensionsOpt .)
    ,               reduce using rule 77 (factor -> ID dimensionsOpt .)
    )               reduce using rule 77 (factor -> ID dimensionsOpt .)


state 84

    (68) expB -> + . exp
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    exp                            shift and go to state 112
    factor                         shift and go to state 59
    empty                          shift and go to state 60

state 85

    (67) expB -> - . exp
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    exp                            shift and go to state 113
    factor                         shift and go to state 59
    empty                          shift and go to state 60

state 86

    (66) exp -> term expB .

    <               reduce using rule 66 (exp -> term expB .)
    >               reduce using rule 66 (exp -> term expB .)
    =               reduce using rule 66 (exp -> term expB .)
    &               reduce using rule 66 (exp -> term expB .)
    |               reduce using rule 66 (exp -> term expB .)
    ;               reduce using rule 66 (exp -> term expB .)
    ]               reduce using rule 66 (exp -> term expB .)
    ,               reduce using rule 66 (exp -> term expB .)
    )               reduce using rule 66 (exp -> term expB .)


state 87

    (69) expB -> empty .

    <               reduce using rule 69 (expB -> empty .)
    >               reduce using rule 69 (expB -> empty .)
    =               reduce using rule 69 (expB -> empty .)
    &               reduce using rule 69 (expB -> empty .)
    |               reduce using rule 69 (expB -> empty .)
    ]               reduce using rule 69 (expB -> empty .)
    ,               reduce using rule 69 (expB -> empty .)
    ;               reduce using rule 69 (expB -> empty .)
    )               reduce using rule 69 (expB -> empty .)


state 88

    (58) expression -> exp expressionB .

    &               reduce using rule 58 (expression -> exp expressionB .)
    |               reduce using rule 58 (expression -> exp expressionB .)
    ,               reduce using rule 58 (expression -> exp expressionB .)
    )               reduce using rule 58 (expression -> exp expressionB .)
    ;               reduce using rule 58 (expression -> exp expressionB .)
    ]               reduce using rule 58 (expression -> exp expressionB .)


state 89

    (62) expressionB -> = . = exp

    =               shift and go to state 114


state 90

    (59) expressionB -> < . exp
    (61) expressionB -> < . > exp
    (63) expressionB -> < . = exp
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    >               shift and go to state 116
    =               shift and go to state 115
    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    exp                            shift and go to state 117
    factor                         shift and go to state 59
    empty                          shift and go to state 60

state 91

    (65) expressionB -> empty .

    &               reduce using rule 65 (expressionB -> empty .)
    |               reduce using rule 65 (expressionB -> empty .)
    ]               reduce using rule 65 (expressionB -> empty .)
    ,               reduce using rule 65 (expressionB -> empty .)
    ;               reduce using rule 65 (expressionB -> empty .)
    )               reduce using rule 65 (expressionB -> empty .)


state 92

    (60) expressionB -> > . exp
    (64) expressionB -> > . = exp
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    =               shift and go to state 119
    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    exp                            shift and go to state 118
    factor                         shift and go to state 59
    empty                          shift and go to state 60

state 93

    (55) superexpressionB -> & . & superexpression

    &               shift and go to state 120


state 94

    (54) superexpression -> expression superexpressionB .

    )               reduce using rule 54 (superexpression -> expression superexpressionB .)
    ;               reduce using rule 54 (superexpression -> expression superexpressionB .)
    ,               reduce using rule 54 (superexpression -> expression superexpressionB .)
    ]               reduce using rule 54 (superexpression -> expression superexpressionB .)


state 95

    (56) superexpressionB -> | . | superexpression

    |               shift and go to state 121


state 96

    (57) superexpressionB -> empty .

    ]               reduce using rule 57 (superexpressionB -> empty .)
    ,               reduce using rule 57 (superexpressionB -> empty .)
    ;               reduce using rule 57 (superexpressionB -> empty .)
    )               reduce using rule 57 (superexpressionB -> empty .)


state 97

    (29) block -> { . instructionsOpt }
    (30) instructionsOpt -> . instruction instructionsOpt
    (31) instructionsOpt -> . empty
    (39) instruction -> . assignfunccall ;
    (40) instruction -> . output ;
    (41) instruction -> . input ;
    (42) instruction -> . return ;
    (43) instruction -> . declaration ;
    (44) instruction -> . condition
    (45) instruction -> . whileloop
    (46) instruction -> . forloop
    (47) instruction -> . localdirective
    (119) empty -> .
    (48) assignfunccall -> . ID assignfunccallB
    (96) output -> . PRINT ( outputB
    (93) input -> . INPUT ( ID inputB )
    (115) return -> . RETURN superexpression
    (18) declaration -> . type declarationB
    (36) condition -> . IF ( superexpression ) block else
    (86) whileloop -> . WHILE ( superexpression ) block
    (92) forloop -> . FOR ( assign ; superexpression ; superexpression ) block
    (51) localdirective -> . localvardirective
    (52) localdirective -> . localdecisiondirective
    (53) localdirective -> . localmsgdirective
    (87) type -> . INT
    (88) type -> . FLOAT
    (89) type -> . STRING
    (101) localvardirective -> . # localvardirectiveB ID
    (105) localdecisiondirective -> . TRACKDECISION
    (106) localdecisiondirective -> . FORGETDECISION
    (107) localdecisiondirective -> . empty
    (104) localmsgdirective -> . # SHOW STRING

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for TRACKDECISION resolved as shift
  ! shift/reduce conflict for FORGETDECISION resolved as shift
    }               reduce using rule 119 (empty -> .)
    ID              shift and go to state 140
    PRINT           shift and go to state 125
    INPUT           shift and go to state 139
    RETURN          shift and go to state 122
    IF              shift and go to state 142
    WHILE           shift and go to state 124
    FOR             shift and go to state 134
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    #               shift and go to state 127
    TRACKDECISION   shift and go to state 129
    FORGETDECISION  shift and go to state 136

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! PRINT           [ reduce using rule 119 (empty -> .) ]
  ! INPUT           [ reduce using rule 119 (empty -> .) ]
  ! RETURN          [ reduce using rule 119 (empty -> .) ]
  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! INT             [ reduce using rule 119 (empty -> .) ]
  ! FLOAT           [ reduce using rule 119 (empty -> .) ]
  ! STRING          [ reduce using rule 119 (empty -> .) ]
  ! #               [ reduce using rule 119 (empty -> .) ]
  ! TRACKDECISION   [ reduce using rule 119 (empty -> .) ]
  ! FORGETDECISION  [ reduce using rule 119 (empty -> .) ]

    assignfunccall                 shift and go to state 123
    whileloop                      shift and go to state 126
    localvardirective              shift and go to state 128
    input                          shift and go to state 130
    type                           shift and go to state 16
    empty                          shift and go to state 131
    forloop                        shift and go to state 132
    return                         shift and go to state 133
    instructionsOpt                shift and go to state 135
    localdirective                 shift and go to state 137
    declaration                    shift and go to state 138
    condition                      shift and go to state 141
    instruction                    shift and go to state 143
    localmsgdirective              shift and go to state 144
    localdecisiondirective         shift and go to state 145
    output                         shift and go to state 146

state 98

    (25) main -> MAIN ( ) block .

    DEF             reduce using rule 25 (main -> MAIN ( ) block .)
    $end            reduce using rule 25 (main -> MAIN ( ) block .)


state 99

    (26) func -> DEF returntype ID ( paramsOpt . ) block

    )               shift and go to state 147


state 100

    (28) paramsOpt -> empty .

    )               reduce using rule 28 (paramsOpt -> empty .)


state 101

    (27) paramsOpt -> params .

    )               reduce using rule 27 (paramsOpt -> params .)


state 102

    (116) params -> type . ID paramsB

    ID              shift and go to state 148


state 103

    (23) declarationD -> , . declarationB
    (19) declarationB -> . ID dimensionsOpt declarationC

    ID              shift and go to state 34

    declarationB                   shift and go to state 149

state 104

    (20) declarationC -> = superexpression declarationD .

    INT             reduce using rule 20 (declarationC -> = superexpression declarationD .)
    FLOAT           reduce using rule 20 (declarationC -> = superexpression declarationD .)
    STRING          reduce using rule 20 (declarationC -> = superexpression declarationD .)
    DEF             reduce using rule 20 (declarationC -> = superexpression declarationD .)
    MAIN            reduce using rule 20 (declarationC -> = superexpression declarationD .)
    ;               reduce using rule 20 (declarationC -> = superexpression declarationD .)


state 105

    (24) declarationD -> ; .

    INT             reduce using rule 24 (declarationD -> ; .)
    FLOAT           reduce using rule 24 (declarationD -> ; .)
    STRING          reduce using rule 24 (declarationD -> ; .)
    DEF             reduce using rule 24 (declarationD -> ; .)
    MAIN            reduce using rule 24 (declarationD -> ; .)
    ;               reduce using rule 24 (declarationD -> ; .)


state 106

    (108) funccall -> DEF ID ( . funccallB
    (109) funccallB -> . superexpression funccallC
    (110) funccallB -> . )
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    )               shift and go to state 151
    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    funccallB                      shift and go to state 150
    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 152
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66
    empty                          shift and go to state 60

state 107

    (75) factor -> ( superexpression ) .

    /               reduce using rule 75 (factor -> ( superexpression ) .)
    *               reduce using rule 75 (factor -> ( superexpression ) .)
    -               reduce using rule 75 (factor -> ( superexpression ) .)
    +               reduce using rule 75 (factor -> ( superexpression ) .)
    <               reduce using rule 75 (factor -> ( superexpression ) .)
    >               reduce using rule 75 (factor -> ( superexpression ) .)
    =               reduce using rule 75 (factor -> ( superexpression ) .)
    &               reduce using rule 75 (factor -> ( superexpression ) .)
    |               reduce using rule 75 (factor -> ( superexpression ) .)
    ;               reduce using rule 75 (factor -> ( superexpression ) .)
    ]               reduce using rule 75 (factor -> ( superexpression ) .)
    ,               reduce using rule 75 (factor -> ( superexpression ) .)
    )               reduce using rule 75 (factor -> ( superexpression ) .)


state 108

    (72) termB -> * term .

    -               reduce using rule 72 (termB -> * term .)
    +               reduce using rule 72 (termB -> * term .)
    <               reduce using rule 72 (termB -> * term .)
    >               reduce using rule 72 (termB -> * term .)
    =               reduce using rule 72 (termB -> * term .)
    &               reduce using rule 72 (termB -> * term .)
    |               reduce using rule 72 (termB -> * term .)
    ]               reduce using rule 72 (termB -> * term .)
    ,               reduce using rule 72 (termB -> * term .)
    ;               reduce using rule 72 (termB -> * term .)
    )               reduce using rule 72 (termB -> * term .)


state 109

    (71) termB -> / term .

    -               reduce using rule 71 (termB -> / term .)
    +               reduce using rule 71 (termB -> / term .)
    <               reduce using rule 71 (termB -> / term .)
    >               reduce using rule 71 (termB -> / term .)
    =               reduce using rule 71 (termB -> / term .)
    &               reduce using rule 71 (termB -> / term .)
    |               reduce using rule 71 (termB -> / term .)
    ]               reduce using rule 71 (termB -> / term .)
    ,               reduce using rule 71 (termB -> / term .)
    ;               reduce using rule 71 (termB -> / term .)
    )               reduce using rule 71 (termB -> / term .)


state 110

    (113) dimensions -> [ superexpression ] dimensionsB .

    =               reduce using rule 113 (dimensions -> [ superexpression ] dimensionsB .)
    ,               reduce using rule 113 (dimensions -> [ superexpression ] dimensionsB .)
    ;               reduce using rule 113 (dimensions -> [ superexpression ] dimensionsB .)
    /               reduce using rule 113 (dimensions -> [ superexpression ] dimensionsB .)
    *               reduce using rule 113 (dimensions -> [ superexpression ] dimensionsB .)
    -               reduce using rule 113 (dimensions -> [ superexpression ] dimensionsB .)
    +               reduce using rule 113 (dimensions -> [ superexpression ] dimensionsB .)
    <               reduce using rule 113 (dimensions -> [ superexpression ] dimensionsB .)
    >               reduce using rule 113 (dimensions -> [ superexpression ] dimensionsB .)
    &               reduce using rule 113 (dimensions -> [ superexpression ] dimensionsB .)
    |               reduce using rule 113 (dimensions -> [ superexpression ] dimensionsB .)
    ]               reduce using rule 113 (dimensions -> [ superexpression ] dimensionsB .)
    )               reduce using rule 113 (dimensions -> [ superexpression ] dimensionsB .)


state 111

    (114) dimensionsB -> [ . superexpression ]
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 153
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66
    empty                          shift and go to state 60

state 112

    (68) expB -> + exp .

    <               reduce using rule 68 (expB -> + exp .)
    >               reduce using rule 68 (expB -> + exp .)
    =               reduce using rule 68 (expB -> + exp .)
    &               reduce using rule 68 (expB -> + exp .)
    |               reduce using rule 68 (expB -> + exp .)
    ]               reduce using rule 68 (expB -> + exp .)
    ,               reduce using rule 68 (expB -> + exp .)
    ;               reduce using rule 68 (expB -> + exp .)
    )               reduce using rule 68 (expB -> + exp .)


state 113

    (67) expB -> - exp .

    <               reduce using rule 67 (expB -> - exp .)
    >               reduce using rule 67 (expB -> - exp .)
    =               reduce using rule 67 (expB -> - exp .)
    &               reduce using rule 67 (expB -> - exp .)
    |               reduce using rule 67 (expB -> - exp .)
    ]               reduce using rule 67 (expB -> - exp .)
    ,               reduce using rule 67 (expB -> - exp .)
    ;               reduce using rule 67 (expB -> - exp .)
    )               reduce using rule 67 (expB -> - exp .)


state 114

    (62) expressionB -> = = . exp
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    exp                            shift and go to state 154
    factor                         shift and go to state 59
    empty                          shift and go to state 60

state 115

    (63) expressionB -> < = . exp
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    exp                            shift and go to state 155
    factor                         shift and go to state 59
    empty                          shift and go to state 60

state 116

    (61) expressionB -> < > . exp
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    exp                            shift and go to state 156
    factor                         shift and go to state 59
    empty                          shift and go to state 60

state 117

    (59) expressionB -> < exp .

    &               reduce using rule 59 (expressionB -> < exp .)
    |               reduce using rule 59 (expressionB -> < exp .)
    ]               reduce using rule 59 (expressionB -> < exp .)
    ,               reduce using rule 59 (expressionB -> < exp .)
    ;               reduce using rule 59 (expressionB -> < exp .)
    )               reduce using rule 59 (expressionB -> < exp .)


state 118

    (60) expressionB -> > exp .

    &               reduce using rule 60 (expressionB -> > exp .)
    |               reduce using rule 60 (expressionB -> > exp .)
    ]               reduce using rule 60 (expressionB -> > exp .)
    ,               reduce using rule 60 (expressionB -> > exp .)
    ;               reduce using rule 60 (expressionB -> > exp .)
    )               reduce using rule 60 (expressionB -> > exp .)


state 119

    (64) expressionB -> > = . exp
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    exp                            shift and go to state 157
    factor                         shift and go to state 59
    empty                          shift and go to state 60

state 120

    (55) superexpressionB -> & & . superexpression
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 158
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66
    empty                          shift and go to state 60

state 121

    (56) superexpressionB -> | | . superexpression
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 159
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66
    empty                          shift and go to state 60

state 122

    (115) return -> RETURN . superexpression
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 160
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66
    empty                          shift and go to state 60

state 123

    (39) instruction -> assignfunccall . ;

    ;               shift and go to state 161


state 124

    (86) whileloop -> WHILE . ( superexpression ) block

    (               shift and go to state 162


state 125

    (96) output -> PRINT . ( outputB

    (               shift and go to state 163


state 126

    (45) instruction -> whileloop .

    ID              reduce using rule 45 (instruction -> whileloop .)
    PRINT           reduce using rule 45 (instruction -> whileloop .)
    INPUT           reduce using rule 45 (instruction -> whileloop .)
    RETURN          reduce using rule 45 (instruction -> whileloop .)
    IF              reduce using rule 45 (instruction -> whileloop .)
    WHILE           reduce using rule 45 (instruction -> whileloop .)
    FOR             reduce using rule 45 (instruction -> whileloop .)
    INT             reduce using rule 45 (instruction -> whileloop .)
    FLOAT           reduce using rule 45 (instruction -> whileloop .)
    STRING          reduce using rule 45 (instruction -> whileloop .)
    #               reduce using rule 45 (instruction -> whileloop .)
    TRACKDECISION   reduce using rule 45 (instruction -> whileloop .)
    FORGETDECISION  reduce using rule 45 (instruction -> whileloop .)
    }               reduce using rule 45 (instruction -> whileloop .)


state 127

    (101) localvardirective -> # . localvardirectiveB ID
    (104) localmsgdirective -> # . SHOW STRING
    (102) localvardirectiveB -> . TRACK
    (103) localvardirectiveB -> . FORGET

    SHOW            shift and go to state 164
    TRACK           shift and go to state 165
    FORGET          shift and go to state 167

    localvardirectiveB             shift and go to state 166

state 128

    (51) localdirective -> localvardirective .

    ID              reduce using rule 51 (localdirective -> localvardirective .)
    PRINT           reduce using rule 51 (localdirective -> localvardirective .)
    INPUT           reduce using rule 51 (localdirective -> localvardirective .)
    RETURN          reduce using rule 51 (localdirective -> localvardirective .)
    IF              reduce using rule 51 (localdirective -> localvardirective .)
    WHILE           reduce using rule 51 (localdirective -> localvardirective .)
    FOR             reduce using rule 51 (localdirective -> localvardirective .)
    INT             reduce using rule 51 (localdirective -> localvardirective .)
    FLOAT           reduce using rule 51 (localdirective -> localvardirective .)
    STRING          reduce using rule 51 (localdirective -> localvardirective .)
    #               reduce using rule 51 (localdirective -> localvardirective .)
    TRACKDECISION   reduce using rule 51 (localdirective -> localvardirective .)
    FORGETDECISION  reduce using rule 51 (localdirective -> localvardirective .)
    }               reduce using rule 51 (localdirective -> localvardirective .)


state 129

    (105) localdecisiondirective -> TRACKDECISION .

    ID              reduce using rule 105 (localdecisiondirective -> TRACKDECISION .)
    PRINT           reduce using rule 105 (localdecisiondirective -> TRACKDECISION .)
    INPUT           reduce using rule 105 (localdecisiondirective -> TRACKDECISION .)
    RETURN          reduce using rule 105 (localdecisiondirective -> TRACKDECISION .)
    IF              reduce using rule 105 (localdecisiondirective -> TRACKDECISION .)
    WHILE           reduce using rule 105 (localdecisiondirective -> TRACKDECISION .)
    FOR             reduce using rule 105 (localdecisiondirective -> TRACKDECISION .)
    INT             reduce using rule 105 (localdecisiondirective -> TRACKDECISION .)
    FLOAT           reduce using rule 105 (localdecisiondirective -> TRACKDECISION .)
    STRING          reduce using rule 105 (localdecisiondirective -> TRACKDECISION .)
    #               reduce using rule 105 (localdecisiondirective -> TRACKDECISION .)
    TRACKDECISION   reduce using rule 105 (localdecisiondirective -> TRACKDECISION .)
    FORGETDECISION  reduce using rule 105 (localdecisiondirective -> TRACKDECISION .)
    }               reduce using rule 105 (localdecisiondirective -> TRACKDECISION .)


state 130

    (41) instruction -> input . ;

    ;               shift and go to state 168


state 131

    (31) instructionsOpt -> empty .
    (107) localdecisiondirective -> empty .

  ! reduce/reduce conflict for } resolved using rule 31 (instructionsOpt -> empty .)
    }               reduce using rule 31 (instructionsOpt -> empty .)
    ID              reduce using rule 107 (localdecisiondirective -> empty .)
    PRINT           reduce using rule 107 (localdecisiondirective -> empty .)
    INPUT           reduce using rule 107 (localdecisiondirective -> empty .)
    RETURN          reduce using rule 107 (localdecisiondirective -> empty .)
    IF              reduce using rule 107 (localdecisiondirective -> empty .)
    WHILE           reduce using rule 107 (localdecisiondirective -> empty .)
    FOR             reduce using rule 107 (localdecisiondirective -> empty .)
    INT             reduce using rule 107 (localdecisiondirective -> empty .)
    FLOAT           reduce using rule 107 (localdecisiondirective -> empty .)
    STRING          reduce using rule 107 (localdecisiondirective -> empty .)
    #               reduce using rule 107 (localdecisiondirective -> empty .)
    TRACKDECISION   reduce using rule 107 (localdecisiondirective -> empty .)
    FORGETDECISION  reduce using rule 107 (localdecisiondirective -> empty .)

  ! }               [ reduce using rule 107 (localdecisiondirective -> empty .) ]


state 132

    (46) instruction -> forloop .

    ID              reduce using rule 46 (instruction -> forloop .)
    PRINT           reduce using rule 46 (instruction -> forloop .)
    INPUT           reduce using rule 46 (instruction -> forloop .)
    RETURN          reduce using rule 46 (instruction -> forloop .)
    IF              reduce using rule 46 (instruction -> forloop .)
    WHILE           reduce using rule 46 (instruction -> forloop .)
    FOR             reduce using rule 46 (instruction -> forloop .)
    INT             reduce using rule 46 (instruction -> forloop .)
    FLOAT           reduce using rule 46 (instruction -> forloop .)
    STRING          reduce using rule 46 (instruction -> forloop .)
    #               reduce using rule 46 (instruction -> forloop .)
    TRACKDECISION   reduce using rule 46 (instruction -> forloop .)
    FORGETDECISION  reduce using rule 46 (instruction -> forloop .)
    }               reduce using rule 46 (instruction -> forloop .)


state 133

    (42) instruction -> return . ;

    ;               shift and go to state 169


state 134

    (92) forloop -> FOR . ( assign ; superexpression ; superexpression ) block

    (               shift and go to state 170


state 135

    (29) block -> { instructionsOpt . }

    }               shift and go to state 171


state 136

    (106) localdecisiondirective -> FORGETDECISION .

    ID              reduce using rule 106 (localdecisiondirective -> FORGETDECISION .)
    PRINT           reduce using rule 106 (localdecisiondirective -> FORGETDECISION .)
    INPUT           reduce using rule 106 (localdecisiondirective -> FORGETDECISION .)
    RETURN          reduce using rule 106 (localdecisiondirective -> FORGETDECISION .)
    IF              reduce using rule 106 (localdecisiondirective -> FORGETDECISION .)
    WHILE           reduce using rule 106 (localdecisiondirective -> FORGETDECISION .)
    FOR             reduce using rule 106 (localdecisiondirective -> FORGETDECISION .)
    INT             reduce using rule 106 (localdecisiondirective -> FORGETDECISION .)
    FLOAT           reduce using rule 106 (localdecisiondirective -> FORGETDECISION .)
    STRING          reduce using rule 106 (localdecisiondirective -> FORGETDECISION .)
    #               reduce using rule 106 (localdecisiondirective -> FORGETDECISION .)
    TRACKDECISION   reduce using rule 106 (localdecisiondirective -> FORGETDECISION .)
    FORGETDECISION  reduce using rule 106 (localdecisiondirective -> FORGETDECISION .)
    }               reduce using rule 106 (localdecisiondirective -> FORGETDECISION .)


state 137

    (47) instruction -> localdirective .

    ID              reduce using rule 47 (instruction -> localdirective .)
    PRINT           reduce using rule 47 (instruction -> localdirective .)
    INPUT           reduce using rule 47 (instruction -> localdirective .)
    RETURN          reduce using rule 47 (instruction -> localdirective .)
    IF              reduce using rule 47 (instruction -> localdirective .)
    WHILE           reduce using rule 47 (instruction -> localdirective .)
    FOR             reduce using rule 47 (instruction -> localdirective .)
    INT             reduce using rule 47 (instruction -> localdirective .)
    FLOAT           reduce using rule 47 (instruction -> localdirective .)
    STRING          reduce using rule 47 (instruction -> localdirective .)
    #               reduce using rule 47 (instruction -> localdirective .)
    TRACKDECISION   reduce using rule 47 (instruction -> localdirective .)
    FORGETDECISION  reduce using rule 47 (instruction -> localdirective .)
    }               reduce using rule 47 (instruction -> localdirective .)


state 138

    (43) instruction -> declaration . ;

    ;               shift and go to state 172


state 139

    (93) input -> INPUT . ( ID inputB )

    (               shift and go to state 173


state 140

    (48) assignfunccall -> ID . assignfunccallB
    (49) assignfunccallB -> . ( funccallB
    (50) assignfunccallB -> . assignB
    (33) assignB -> . dimensionsOpt = superexpression
    (34) dimensionsOpt -> . dimensions
    (35) dimensionsOpt -> . empty
    (113) dimensions -> . [ superexpression ] dimensionsB
    (119) empty -> .

    (               shift and go to state 175
    [               shift and go to state 44
    =               reduce using rule 119 (empty -> .)

    dimensions                     shift and go to state 43
    assignfunccallB                shift and go to state 174
    assignB                        shift and go to state 176
    dimensionsOpt                  shift and go to state 177
    empty                          shift and go to state 45

state 141

    (44) instruction -> condition .

    ID              reduce using rule 44 (instruction -> condition .)
    PRINT           reduce using rule 44 (instruction -> condition .)
    INPUT           reduce using rule 44 (instruction -> condition .)
    RETURN          reduce using rule 44 (instruction -> condition .)
    IF              reduce using rule 44 (instruction -> condition .)
    WHILE           reduce using rule 44 (instruction -> condition .)
    FOR             reduce using rule 44 (instruction -> condition .)
    INT             reduce using rule 44 (instruction -> condition .)
    FLOAT           reduce using rule 44 (instruction -> condition .)
    STRING          reduce using rule 44 (instruction -> condition .)
    #               reduce using rule 44 (instruction -> condition .)
    TRACKDECISION   reduce using rule 44 (instruction -> condition .)
    FORGETDECISION  reduce using rule 44 (instruction -> condition .)
    }               reduce using rule 44 (instruction -> condition .)


state 142

    (36) condition -> IF . ( superexpression ) block else

    (               shift and go to state 178


state 143

    (30) instructionsOpt -> instruction . instructionsOpt
    (30) instructionsOpt -> . instruction instructionsOpt
    (31) instructionsOpt -> . empty
    (39) instruction -> . assignfunccall ;
    (40) instruction -> . output ;
    (41) instruction -> . input ;
    (42) instruction -> . return ;
    (43) instruction -> . declaration ;
    (44) instruction -> . condition
    (45) instruction -> . whileloop
    (46) instruction -> . forloop
    (47) instruction -> . localdirective
    (119) empty -> .
    (48) assignfunccall -> . ID assignfunccallB
    (96) output -> . PRINT ( outputB
    (93) input -> . INPUT ( ID inputB )
    (115) return -> . RETURN superexpression
    (18) declaration -> . type declarationB
    (36) condition -> . IF ( superexpression ) block else
    (86) whileloop -> . WHILE ( superexpression ) block
    (92) forloop -> . FOR ( assign ; superexpression ; superexpression ) block
    (51) localdirective -> . localvardirective
    (52) localdirective -> . localdecisiondirective
    (53) localdirective -> . localmsgdirective
    (87) type -> . INT
    (88) type -> . FLOAT
    (89) type -> . STRING
    (101) localvardirective -> . # localvardirectiveB ID
    (105) localdecisiondirective -> . TRACKDECISION
    (106) localdecisiondirective -> . FORGETDECISION
    (107) localdecisiondirective -> . empty
    (104) localmsgdirective -> . # SHOW STRING

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for TRACKDECISION resolved as shift
  ! shift/reduce conflict for FORGETDECISION resolved as shift
    }               reduce using rule 119 (empty -> .)
    ID              shift and go to state 140
    PRINT           shift and go to state 125
    INPUT           shift and go to state 139
    RETURN          shift and go to state 122
    IF              shift and go to state 142
    WHILE           shift and go to state 124
    FOR             shift and go to state 134
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    #               shift and go to state 127
    TRACKDECISION   shift and go to state 129
    FORGETDECISION  shift and go to state 136

  ! ID              [ reduce using rule 119 (empty -> .) ]
  ! PRINT           [ reduce using rule 119 (empty -> .) ]
  ! INPUT           [ reduce using rule 119 (empty -> .) ]
  ! RETURN          [ reduce using rule 119 (empty -> .) ]
  ! IF              [ reduce using rule 119 (empty -> .) ]
  ! WHILE           [ reduce using rule 119 (empty -> .) ]
  ! FOR             [ reduce using rule 119 (empty -> .) ]
  ! INT             [ reduce using rule 119 (empty -> .) ]
  ! FLOAT           [ reduce using rule 119 (empty -> .) ]
  ! STRING          [ reduce using rule 119 (empty -> .) ]
  ! #               [ reduce using rule 119 (empty -> .) ]
  ! TRACKDECISION   [ reduce using rule 119 (empty -> .) ]
  ! FORGETDECISION  [ reduce using rule 119 (empty -> .) ]

    assignfunccall                 shift and go to state 123
    whileloop                      shift and go to state 126
    localvardirective              shift and go to state 128
    input                          shift and go to state 130
    type                           shift and go to state 16
    empty                          shift and go to state 131
    forloop                        shift and go to state 132
    return                         shift and go to state 133
    instructionsOpt                shift and go to state 179
    localdirective                 shift and go to state 137
    declaration                    shift and go to state 138
    condition                      shift and go to state 141
    instruction                    shift and go to state 143
    localmsgdirective              shift and go to state 144
    localdecisiondirective         shift and go to state 145
    output                         shift and go to state 146

state 144

    (53) localdirective -> localmsgdirective .

    ID              reduce using rule 53 (localdirective -> localmsgdirective .)
    PRINT           reduce using rule 53 (localdirective -> localmsgdirective .)
    INPUT           reduce using rule 53 (localdirective -> localmsgdirective .)
    RETURN          reduce using rule 53 (localdirective -> localmsgdirective .)
    IF              reduce using rule 53 (localdirective -> localmsgdirective .)
    WHILE           reduce using rule 53 (localdirective -> localmsgdirective .)
    FOR             reduce using rule 53 (localdirective -> localmsgdirective .)
    INT             reduce using rule 53 (localdirective -> localmsgdirective .)
    FLOAT           reduce using rule 53 (localdirective -> localmsgdirective .)
    STRING          reduce using rule 53 (localdirective -> localmsgdirective .)
    #               reduce using rule 53 (localdirective -> localmsgdirective .)
    TRACKDECISION   reduce using rule 53 (localdirective -> localmsgdirective .)
    FORGETDECISION  reduce using rule 53 (localdirective -> localmsgdirective .)
    }               reduce using rule 53 (localdirective -> localmsgdirective .)


state 145

    (52) localdirective -> localdecisiondirective .

    ID              reduce using rule 52 (localdirective -> localdecisiondirective .)
    PRINT           reduce using rule 52 (localdirective -> localdecisiondirective .)
    INPUT           reduce using rule 52 (localdirective -> localdecisiondirective .)
    RETURN          reduce using rule 52 (localdirective -> localdecisiondirective .)
    IF              reduce using rule 52 (localdirective -> localdecisiondirective .)
    WHILE           reduce using rule 52 (localdirective -> localdecisiondirective .)
    FOR             reduce using rule 52 (localdirective -> localdecisiondirective .)
    INT             reduce using rule 52 (localdirective -> localdecisiondirective .)
    FLOAT           reduce using rule 52 (localdirective -> localdecisiondirective .)
    STRING          reduce using rule 52 (localdirective -> localdecisiondirective .)
    #               reduce using rule 52 (localdirective -> localdecisiondirective .)
    TRACKDECISION   reduce using rule 52 (localdirective -> localdecisiondirective .)
    FORGETDECISION  reduce using rule 52 (localdirective -> localdecisiondirective .)
    }               reduce using rule 52 (localdirective -> localdecisiondirective .)


state 146

    (40) instruction -> output . ;

    ;               shift and go to state 180


state 147

    (26) func -> DEF returntype ID ( paramsOpt ) . block
    (29) block -> . { instructionsOpt }

    {               shift and go to state 97

    block                          shift and go to state 181

state 148

    (116) params -> type ID . paramsB
    (117) paramsB -> . , type ID paramsB
    (118) paramsB -> . empty
    (119) empty -> .

    ,               shift and go to state 184
    )               reduce using rule 119 (empty -> .)

    paramsB                        shift and go to state 182
    empty                          shift and go to state 183

state 149

    (23) declarationD -> , declarationB .

    INT             reduce using rule 23 (declarationD -> , declarationB .)
    FLOAT           reduce using rule 23 (declarationD -> , declarationB .)
    STRING          reduce using rule 23 (declarationD -> , declarationB .)
    DEF             reduce using rule 23 (declarationD -> , declarationB .)
    MAIN            reduce using rule 23 (declarationD -> , declarationB .)
    ;               reduce using rule 23 (declarationD -> , declarationB .)


state 150

    (108) funccall -> DEF ID ( funccallB .

    /               reduce using rule 108 (funccall -> DEF ID ( funccallB .)
    *               reduce using rule 108 (funccall -> DEF ID ( funccallB .)
    -               reduce using rule 108 (funccall -> DEF ID ( funccallB .)
    +               reduce using rule 108 (funccall -> DEF ID ( funccallB .)
    <               reduce using rule 108 (funccall -> DEF ID ( funccallB .)
    >               reduce using rule 108 (funccall -> DEF ID ( funccallB .)
    =               reduce using rule 108 (funccall -> DEF ID ( funccallB .)
    &               reduce using rule 108 (funccall -> DEF ID ( funccallB .)
    |               reduce using rule 108 (funccall -> DEF ID ( funccallB .)
    )               reduce using rule 108 (funccall -> DEF ID ( funccallB .)
    ,               reduce using rule 108 (funccall -> DEF ID ( funccallB .)
    ]               reduce using rule 108 (funccall -> DEF ID ( funccallB .)
    ;               reduce using rule 108 (funccall -> DEF ID ( funccallB .)


state 151

    (110) funccallB -> ) .

    ;               reduce using rule 110 (funccallB -> ) .)
    /               reduce using rule 110 (funccallB -> ) .)
    *               reduce using rule 110 (funccallB -> ) .)
    -               reduce using rule 110 (funccallB -> ) .)
    +               reduce using rule 110 (funccallB -> ) .)
    <               reduce using rule 110 (funccallB -> ) .)
    >               reduce using rule 110 (funccallB -> ) .)
    =               reduce using rule 110 (funccallB -> ) .)
    &               reduce using rule 110 (funccallB -> ) .)
    |               reduce using rule 110 (funccallB -> ) .)
    ]               reduce using rule 110 (funccallB -> ) .)
    ,               reduce using rule 110 (funccallB -> ) .)
    )               reduce using rule 110 (funccallB -> ) .)


state 152

    (109) funccallB -> superexpression . funccallC
    (111) funccallC -> . , superexpression funccallC
    (112) funccallC -> . )

    ,               shift and go to state 187
    )               shift and go to state 186

    funccallC                      shift and go to state 185

state 153

    (114) dimensionsB -> [ superexpression . ]

    ]               shift and go to state 188


state 154

    (62) expressionB -> = = exp .

    &               reduce using rule 62 (expressionB -> = = exp .)
    |               reduce using rule 62 (expressionB -> = = exp .)
    ]               reduce using rule 62 (expressionB -> = = exp .)
    ,               reduce using rule 62 (expressionB -> = = exp .)
    ;               reduce using rule 62 (expressionB -> = = exp .)
    )               reduce using rule 62 (expressionB -> = = exp .)


state 155

    (63) expressionB -> < = exp .

    &               reduce using rule 63 (expressionB -> < = exp .)
    |               reduce using rule 63 (expressionB -> < = exp .)
    ]               reduce using rule 63 (expressionB -> < = exp .)
    ,               reduce using rule 63 (expressionB -> < = exp .)
    ;               reduce using rule 63 (expressionB -> < = exp .)
    )               reduce using rule 63 (expressionB -> < = exp .)


state 156

    (61) expressionB -> < > exp .

    &               reduce using rule 61 (expressionB -> < > exp .)
    |               reduce using rule 61 (expressionB -> < > exp .)
    ]               reduce using rule 61 (expressionB -> < > exp .)
    ,               reduce using rule 61 (expressionB -> < > exp .)
    ;               reduce using rule 61 (expressionB -> < > exp .)
    )               reduce using rule 61 (expressionB -> < > exp .)


state 157

    (64) expressionB -> > = exp .

    &               reduce using rule 64 (expressionB -> > = exp .)
    |               reduce using rule 64 (expressionB -> > = exp .)
    ]               reduce using rule 64 (expressionB -> > = exp .)
    ,               reduce using rule 64 (expressionB -> > = exp .)
    ;               reduce using rule 64 (expressionB -> > = exp .)
    )               reduce using rule 64 (expressionB -> > = exp .)


state 158

    (55) superexpressionB -> & & superexpression .

    ]               reduce using rule 55 (superexpressionB -> & & superexpression .)
    ,               reduce using rule 55 (superexpressionB -> & & superexpression .)
    ;               reduce using rule 55 (superexpressionB -> & & superexpression .)
    )               reduce using rule 55 (superexpressionB -> & & superexpression .)


state 159

    (56) superexpressionB -> | | superexpression .

    ]               reduce using rule 56 (superexpressionB -> | | superexpression .)
    ,               reduce using rule 56 (superexpressionB -> | | superexpression .)
    ;               reduce using rule 56 (superexpressionB -> | | superexpression .)
    )               reduce using rule 56 (superexpressionB -> | | superexpression .)


state 160

    (115) return -> RETURN superexpression .

    ;               reduce using rule 115 (return -> RETURN superexpression .)


state 161

    (39) instruction -> assignfunccall ; .

    ID              reduce using rule 39 (instruction -> assignfunccall ; .)
    PRINT           reduce using rule 39 (instruction -> assignfunccall ; .)
    INPUT           reduce using rule 39 (instruction -> assignfunccall ; .)
    RETURN          reduce using rule 39 (instruction -> assignfunccall ; .)
    IF              reduce using rule 39 (instruction -> assignfunccall ; .)
    WHILE           reduce using rule 39 (instruction -> assignfunccall ; .)
    FOR             reduce using rule 39 (instruction -> assignfunccall ; .)
    INT             reduce using rule 39 (instruction -> assignfunccall ; .)
    FLOAT           reduce using rule 39 (instruction -> assignfunccall ; .)
    STRING          reduce using rule 39 (instruction -> assignfunccall ; .)
    #               reduce using rule 39 (instruction -> assignfunccall ; .)
    TRACKDECISION   reduce using rule 39 (instruction -> assignfunccall ; .)
    FORGETDECISION  reduce using rule 39 (instruction -> assignfunccall ; .)
    }               reduce using rule 39 (instruction -> assignfunccall ; .)


state 162

    (86) whileloop -> WHILE ( . superexpression ) block
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 189
    empty                          shift and go to state 60
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66

state 163

    (96) output -> PRINT ( . outputB
    (97) outputB -> . STRING outputC
    (98) outputB -> . superexpression outputC
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    STRING          shift and go to state 190
    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    factor                         shift and go to state 59
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 191
    exp                            shift and go to state 65
    outputB                        shift and go to state 192
    expression                     shift and go to state 66
    empty                          shift and go to state 60

state 164

    (104) localmsgdirective -> # SHOW . STRING

    STRING          shift and go to state 193


state 165

    (102) localvardirectiveB -> TRACK .

    ID              reduce using rule 102 (localvardirectiveB -> TRACK .)


state 166

    (101) localvardirective -> # localvardirectiveB . ID

    ID              shift and go to state 194


state 167

    (103) localvardirectiveB -> FORGET .

    ID              reduce using rule 103 (localvardirectiveB -> FORGET .)


state 168

    (41) instruction -> input ; .

    ID              reduce using rule 41 (instruction -> input ; .)
    PRINT           reduce using rule 41 (instruction -> input ; .)
    INPUT           reduce using rule 41 (instruction -> input ; .)
    RETURN          reduce using rule 41 (instruction -> input ; .)
    IF              reduce using rule 41 (instruction -> input ; .)
    WHILE           reduce using rule 41 (instruction -> input ; .)
    FOR             reduce using rule 41 (instruction -> input ; .)
    INT             reduce using rule 41 (instruction -> input ; .)
    FLOAT           reduce using rule 41 (instruction -> input ; .)
    STRING          reduce using rule 41 (instruction -> input ; .)
    #               reduce using rule 41 (instruction -> input ; .)
    TRACKDECISION   reduce using rule 41 (instruction -> input ; .)
    FORGETDECISION  reduce using rule 41 (instruction -> input ; .)
    }               reduce using rule 41 (instruction -> input ; .)


state 169

    (42) instruction -> return ; .

    ID              reduce using rule 42 (instruction -> return ; .)
    PRINT           reduce using rule 42 (instruction -> return ; .)
    INPUT           reduce using rule 42 (instruction -> return ; .)
    RETURN          reduce using rule 42 (instruction -> return ; .)
    IF              reduce using rule 42 (instruction -> return ; .)
    WHILE           reduce using rule 42 (instruction -> return ; .)
    FOR             reduce using rule 42 (instruction -> return ; .)
    INT             reduce using rule 42 (instruction -> return ; .)
    FLOAT           reduce using rule 42 (instruction -> return ; .)
    STRING          reduce using rule 42 (instruction -> return ; .)
    #               reduce using rule 42 (instruction -> return ; .)
    TRACKDECISION   reduce using rule 42 (instruction -> return ; .)
    FORGETDECISION  reduce using rule 42 (instruction -> return ; .)
    }               reduce using rule 42 (instruction -> return ; .)


state 170

    (92) forloop -> FOR ( . assign ; superexpression ; superexpression ) block
    (32) assign -> . ID dimensionsOpt = superexpression

    ID              shift and go to state 195

    assign                         shift and go to state 196

state 171

    (29) block -> { instructionsOpt } .

    ID              reduce using rule 29 (block -> { instructionsOpt } .)
    PRINT           reduce using rule 29 (block -> { instructionsOpt } .)
    INPUT           reduce using rule 29 (block -> { instructionsOpt } .)
    RETURN          reduce using rule 29 (block -> { instructionsOpt } .)
    IF              reduce using rule 29 (block -> { instructionsOpt } .)
    WHILE           reduce using rule 29 (block -> { instructionsOpt } .)
    FOR             reduce using rule 29 (block -> { instructionsOpt } .)
    INT             reduce using rule 29 (block -> { instructionsOpt } .)
    FLOAT           reduce using rule 29 (block -> { instructionsOpt } .)
    STRING          reduce using rule 29 (block -> { instructionsOpt } .)
    #               reduce using rule 29 (block -> { instructionsOpt } .)
    TRACKDECISION   reduce using rule 29 (block -> { instructionsOpt } .)
    FORGETDECISION  reduce using rule 29 (block -> { instructionsOpt } .)
    }               reduce using rule 29 (block -> { instructionsOpt } .)
    DEF             reduce using rule 29 (block -> { instructionsOpt } .)
    $end            reduce using rule 29 (block -> { instructionsOpt } .)
    ELSE            reduce using rule 29 (block -> { instructionsOpt } .)
    MAIN            reduce using rule 29 (block -> { instructionsOpt } .)


state 172

    (43) instruction -> declaration ; .

    ID              reduce using rule 43 (instruction -> declaration ; .)
    PRINT           reduce using rule 43 (instruction -> declaration ; .)
    INPUT           reduce using rule 43 (instruction -> declaration ; .)
    RETURN          reduce using rule 43 (instruction -> declaration ; .)
    IF              reduce using rule 43 (instruction -> declaration ; .)
    WHILE           reduce using rule 43 (instruction -> declaration ; .)
    FOR             reduce using rule 43 (instruction -> declaration ; .)
    INT             reduce using rule 43 (instruction -> declaration ; .)
    FLOAT           reduce using rule 43 (instruction -> declaration ; .)
    STRING          reduce using rule 43 (instruction -> declaration ; .)
    #               reduce using rule 43 (instruction -> declaration ; .)
    TRACKDECISION   reduce using rule 43 (instruction -> declaration ; .)
    FORGETDECISION  reduce using rule 43 (instruction -> declaration ; .)
    }               reduce using rule 43 (instruction -> declaration ; .)


state 173

    (93) input -> INPUT ( . ID inputB )

    ID              shift and go to state 197


state 174

    (48) assignfunccall -> ID assignfunccallB .

    ;               reduce using rule 48 (assignfunccall -> ID assignfunccallB .)


state 175

    (49) assignfunccallB -> ( . funccallB
    (109) funccallB -> . superexpression funccallC
    (110) funccallB -> . )
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    )               shift and go to state 151
    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    funccallB                      shift and go to state 198
    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 152
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66
    empty                          shift and go to state 60

state 176

    (50) assignfunccallB -> assignB .

    ;               reduce using rule 50 (assignfunccallB -> assignB .)


state 177

    (33) assignB -> dimensionsOpt . = superexpression

    =               shift and go to state 199


state 178

    (36) condition -> IF ( . superexpression ) block else
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 200
    empty                          shift and go to state 60
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66

state 179

    (30) instructionsOpt -> instruction instructionsOpt .

    }               reduce using rule 30 (instructionsOpt -> instruction instructionsOpt .)


state 180

    (40) instruction -> output ; .

    ID              reduce using rule 40 (instruction -> output ; .)
    PRINT           reduce using rule 40 (instruction -> output ; .)
    INPUT           reduce using rule 40 (instruction -> output ; .)
    RETURN          reduce using rule 40 (instruction -> output ; .)
    IF              reduce using rule 40 (instruction -> output ; .)
    WHILE           reduce using rule 40 (instruction -> output ; .)
    FOR             reduce using rule 40 (instruction -> output ; .)
    INT             reduce using rule 40 (instruction -> output ; .)
    FLOAT           reduce using rule 40 (instruction -> output ; .)
    STRING          reduce using rule 40 (instruction -> output ; .)
    #               reduce using rule 40 (instruction -> output ; .)
    TRACKDECISION   reduce using rule 40 (instruction -> output ; .)
    FORGETDECISION  reduce using rule 40 (instruction -> output ; .)
    }               reduce using rule 40 (instruction -> output ; .)


state 181

    (26) func -> DEF returntype ID ( paramsOpt ) block .

    DEF             reduce using rule 26 (func -> DEF returntype ID ( paramsOpt ) block .)
    $end            reduce using rule 26 (func -> DEF returntype ID ( paramsOpt ) block .)
    MAIN            reduce using rule 26 (func -> DEF returntype ID ( paramsOpt ) block .)


state 182

    (116) params -> type ID paramsB .

    )               reduce using rule 116 (params -> type ID paramsB .)


state 183

    (118) paramsB -> empty .

    )               reduce using rule 118 (paramsB -> empty .)


state 184

    (117) paramsB -> , . type ID paramsB
    (87) type -> . INT
    (88) type -> . FLOAT
    (89) type -> . STRING

    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14

    type                           shift and go to state 201

state 185

    (109) funccallB -> superexpression funccallC .

    ;               reduce using rule 109 (funccallB -> superexpression funccallC .)
    /               reduce using rule 109 (funccallB -> superexpression funccallC .)
    *               reduce using rule 109 (funccallB -> superexpression funccallC .)
    -               reduce using rule 109 (funccallB -> superexpression funccallC .)
    +               reduce using rule 109 (funccallB -> superexpression funccallC .)
    <               reduce using rule 109 (funccallB -> superexpression funccallC .)
    >               reduce using rule 109 (funccallB -> superexpression funccallC .)
    =               reduce using rule 109 (funccallB -> superexpression funccallC .)
    &               reduce using rule 109 (funccallB -> superexpression funccallC .)
    |               reduce using rule 109 (funccallB -> superexpression funccallC .)
    ]               reduce using rule 109 (funccallB -> superexpression funccallC .)
    ,               reduce using rule 109 (funccallB -> superexpression funccallC .)
    )               reduce using rule 109 (funccallB -> superexpression funccallC .)


state 186

    (112) funccallC -> ) .

    /               reduce using rule 112 (funccallC -> ) .)
    *               reduce using rule 112 (funccallC -> ) .)
    -               reduce using rule 112 (funccallC -> ) .)
    +               reduce using rule 112 (funccallC -> ) .)
    <               reduce using rule 112 (funccallC -> ) .)
    >               reduce using rule 112 (funccallC -> ) .)
    =               reduce using rule 112 (funccallC -> ) .)
    &               reduce using rule 112 (funccallC -> ) .)
    |               reduce using rule 112 (funccallC -> ) .)
    ]               reduce using rule 112 (funccallC -> ) .)
    ,               reduce using rule 112 (funccallC -> ) .)
    ;               reduce using rule 112 (funccallC -> ) .)
    )               reduce using rule 112 (funccallC -> ) .)


state 187

    (111) funccallC -> , . superexpression funccallC
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 202
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66
    empty                          shift and go to state 60

state 188

    (114) dimensionsB -> [ superexpression ] .

    =               reduce using rule 114 (dimensionsB -> [ superexpression ] .)
    ,               reduce using rule 114 (dimensionsB -> [ superexpression ] .)
    ;               reduce using rule 114 (dimensionsB -> [ superexpression ] .)
    /               reduce using rule 114 (dimensionsB -> [ superexpression ] .)
    *               reduce using rule 114 (dimensionsB -> [ superexpression ] .)
    -               reduce using rule 114 (dimensionsB -> [ superexpression ] .)
    +               reduce using rule 114 (dimensionsB -> [ superexpression ] .)
    <               reduce using rule 114 (dimensionsB -> [ superexpression ] .)
    >               reduce using rule 114 (dimensionsB -> [ superexpression ] .)
    &               reduce using rule 114 (dimensionsB -> [ superexpression ] .)
    |               reduce using rule 114 (dimensionsB -> [ superexpression ] .)
    ]               reduce using rule 114 (dimensionsB -> [ superexpression ] .)
    )               reduce using rule 114 (dimensionsB -> [ superexpression ] .)


state 189

    (86) whileloop -> WHILE ( superexpression . ) block

    )               shift and go to state 203


state 190

    (97) outputB -> STRING . outputC
    (99) outputC -> . )
    (100) outputC -> . , outputB

    )               shift and go to state 204
    ,               shift and go to state 206

    outputC                        shift and go to state 205

state 191

    (98) outputB -> superexpression . outputC
    (99) outputC -> . )
    (100) outputC -> . , outputB

    )               shift and go to state 204
    ,               shift and go to state 206

    outputC                        shift and go to state 207

state 192

    (96) output -> PRINT ( outputB .

    ;               reduce using rule 96 (output -> PRINT ( outputB .)


state 193

    (104) localmsgdirective -> # SHOW STRING .

    ID              reduce using rule 104 (localmsgdirective -> # SHOW STRING .)
    PRINT           reduce using rule 104 (localmsgdirective -> # SHOW STRING .)
    INPUT           reduce using rule 104 (localmsgdirective -> # SHOW STRING .)
    RETURN          reduce using rule 104 (localmsgdirective -> # SHOW STRING .)
    IF              reduce using rule 104 (localmsgdirective -> # SHOW STRING .)
    WHILE           reduce using rule 104 (localmsgdirective -> # SHOW STRING .)
    FOR             reduce using rule 104 (localmsgdirective -> # SHOW STRING .)
    INT             reduce using rule 104 (localmsgdirective -> # SHOW STRING .)
    FLOAT           reduce using rule 104 (localmsgdirective -> # SHOW STRING .)
    STRING          reduce using rule 104 (localmsgdirective -> # SHOW STRING .)
    #               reduce using rule 104 (localmsgdirective -> # SHOW STRING .)
    TRACKDECISION   reduce using rule 104 (localmsgdirective -> # SHOW STRING .)
    FORGETDECISION  reduce using rule 104 (localmsgdirective -> # SHOW STRING .)
    }               reduce using rule 104 (localmsgdirective -> # SHOW STRING .)


state 194

    (101) localvardirective -> # localvardirectiveB ID .

    ID              reduce using rule 101 (localvardirective -> # localvardirectiveB ID .)
    PRINT           reduce using rule 101 (localvardirective -> # localvardirectiveB ID .)
    INPUT           reduce using rule 101 (localvardirective -> # localvardirectiveB ID .)
    RETURN          reduce using rule 101 (localvardirective -> # localvardirectiveB ID .)
    IF              reduce using rule 101 (localvardirective -> # localvardirectiveB ID .)
    WHILE           reduce using rule 101 (localvardirective -> # localvardirectiveB ID .)
    FOR             reduce using rule 101 (localvardirective -> # localvardirectiveB ID .)
    INT             reduce using rule 101 (localvardirective -> # localvardirectiveB ID .)
    FLOAT           reduce using rule 101 (localvardirective -> # localvardirectiveB ID .)
    STRING          reduce using rule 101 (localvardirective -> # localvardirectiveB ID .)
    #               reduce using rule 101 (localvardirective -> # localvardirectiveB ID .)
    TRACKDECISION   reduce using rule 101 (localvardirective -> # localvardirectiveB ID .)
    FORGETDECISION  reduce using rule 101 (localvardirective -> # localvardirectiveB ID .)
    }               reduce using rule 101 (localvardirective -> # localvardirectiveB ID .)


state 195

    (32) assign -> ID . dimensionsOpt = superexpression
    (34) dimensionsOpt -> . dimensions
    (35) dimensionsOpt -> . empty
    (113) dimensions -> . [ superexpression ] dimensionsB
    (119) empty -> .

    [               shift and go to state 44
    =               reduce using rule 119 (empty -> .)

    dimensionsOpt                  shift and go to state 208
    dimensions                     shift and go to state 43
    empty                          shift and go to state 45

state 196

    (92) forloop -> FOR ( assign . ; superexpression ; superexpression ) block

    ;               shift and go to state 209


state 197

    (93) input -> INPUT ( ID . inputB )
    (94) inputB -> . , ID inputB
    (95) inputB -> . empty
    (119) empty -> .

    ,               shift and go to state 210
    )               reduce using rule 119 (empty -> .)

    inputB                         shift and go to state 211
    empty                          shift and go to state 212

state 198

    (49) assignfunccallB -> ( funccallB .

    ;               reduce using rule 49 (assignfunccallB -> ( funccallB .)


state 199

    (33) assignB -> dimensionsOpt = . superexpression
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 213
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66
    empty                          shift and go to state 60

state 200

    (36) condition -> IF ( superexpression . ) block else

    )               shift and go to state 214


state 201

    (117) paramsB -> , type . ID paramsB

    ID              shift and go to state 215


state 202

    (111) funccallC -> , superexpression . funccallC
    (111) funccallC -> . , superexpression funccallC
    (112) funccallC -> . )

    ,               shift and go to state 187
    )               shift and go to state 186

    funccallC                      shift and go to state 216

state 203

    (86) whileloop -> WHILE ( superexpression ) . block
    (29) block -> . { instructionsOpt }

    {               shift and go to state 97

    block                          shift and go to state 217

state 204

    (99) outputC -> ) .

    ;               reduce using rule 99 (outputC -> ) .)


state 205

    (97) outputB -> STRING outputC .

    ;               reduce using rule 97 (outputB -> STRING outputC .)


state 206

    (100) outputC -> , . outputB
    (97) outputB -> . STRING outputC
    (98) outputB -> . superexpression outputC
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    STRING          shift and go to state 190
    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    factor                         shift and go to state 59
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 191
    exp                            shift and go to state 65
    outputB                        shift and go to state 218
    expression                     shift and go to state 66
    empty                          shift and go to state 60

state 207

    (98) outputB -> superexpression outputC .

    ;               reduce using rule 98 (outputB -> superexpression outputC .)


state 208

    (32) assign -> ID dimensionsOpt . = superexpression

    =               shift and go to state 219


state 209

    (92) forloop -> FOR ( assign ; . superexpression ; superexpression ) block
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 220
    empty                          shift and go to state 60
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66

state 210

    (94) inputB -> , . ID inputB

    ID              shift and go to state 221


state 211

    (93) input -> INPUT ( ID inputB . )

    )               shift and go to state 222


state 212

    (95) inputB -> empty .

    )               reduce using rule 95 (inputB -> empty .)


state 213

    (33) assignB -> dimensionsOpt = superexpression .

    ;               reduce using rule 33 (assignB -> dimensionsOpt = superexpression .)


state 214

    (36) condition -> IF ( superexpression ) . block else
    (29) block -> . { instructionsOpt }

    {               shift and go to state 97

    block                          shift and go to state 223

state 215

    (117) paramsB -> , type ID . paramsB
    (117) paramsB -> . , type ID paramsB
    (118) paramsB -> . empty
    (119) empty -> .

    ,               shift and go to state 184
    )               reduce using rule 119 (empty -> .)

    paramsB                        shift and go to state 224
    empty                          shift and go to state 183

state 216

    (111) funccallC -> , superexpression funccallC .

    /               reduce using rule 111 (funccallC -> , superexpression funccallC .)
    *               reduce using rule 111 (funccallC -> , superexpression funccallC .)
    -               reduce using rule 111 (funccallC -> , superexpression funccallC .)
    +               reduce using rule 111 (funccallC -> , superexpression funccallC .)
    <               reduce using rule 111 (funccallC -> , superexpression funccallC .)
    >               reduce using rule 111 (funccallC -> , superexpression funccallC .)
    =               reduce using rule 111 (funccallC -> , superexpression funccallC .)
    &               reduce using rule 111 (funccallC -> , superexpression funccallC .)
    |               reduce using rule 111 (funccallC -> , superexpression funccallC .)
    ]               reduce using rule 111 (funccallC -> , superexpression funccallC .)
    ,               reduce using rule 111 (funccallC -> , superexpression funccallC .)
    ;               reduce using rule 111 (funccallC -> , superexpression funccallC .)
    )               reduce using rule 111 (funccallC -> , superexpression funccallC .)


state 217

    (86) whileloop -> WHILE ( superexpression ) block .

    ID              reduce using rule 86 (whileloop -> WHILE ( superexpression ) block .)
    PRINT           reduce using rule 86 (whileloop -> WHILE ( superexpression ) block .)
    INPUT           reduce using rule 86 (whileloop -> WHILE ( superexpression ) block .)
    RETURN          reduce using rule 86 (whileloop -> WHILE ( superexpression ) block .)
    IF              reduce using rule 86 (whileloop -> WHILE ( superexpression ) block .)
    WHILE           reduce using rule 86 (whileloop -> WHILE ( superexpression ) block .)
    FOR             reduce using rule 86 (whileloop -> WHILE ( superexpression ) block .)
    INT             reduce using rule 86 (whileloop -> WHILE ( superexpression ) block .)
    FLOAT           reduce using rule 86 (whileloop -> WHILE ( superexpression ) block .)
    STRING          reduce using rule 86 (whileloop -> WHILE ( superexpression ) block .)
    #               reduce using rule 86 (whileloop -> WHILE ( superexpression ) block .)
    TRACKDECISION   reduce using rule 86 (whileloop -> WHILE ( superexpression ) block .)
    FORGETDECISION  reduce using rule 86 (whileloop -> WHILE ( superexpression ) block .)
    }               reduce using rule 86 (whileloop -> WHILE ( superexpression ) block .)


state 218

    (100) outputC -> , outputB .

    ;               reduce using rule 100 (outputC -> , outputB .)


state 219

    (32) assign -> ID dimensionsOpt = . superexpression
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 225
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66
    empty                          shift and go to state 60

state 220

    (92) forloop -> FOR ( assign ; superexpression . ; superexpression ) block

    ;               shift and go to state 226


state 221

    (94) inputB -> , ID . inputB
    (94) inputB -> . , ID inputB
    (95) inputB -> . empty
    (119) empty -> .

    ,               shift and go to state 210
    )               reduce using rule 119 (empty -> .)

    inputB                         shift and go to state 227
    empty                          shift and go to state 212

state 222

    (93) input -> INPUT ( ID inputB ) .

    ;               reduce using rule 93 (input -> INPUT ( ID inputB ) .)


state 223

    (36) condition -> IF ( superexpression ) block . else
    (37) else -> . ELSE block
    (38) else -> . empty
    (119) empty -> .

    ELSE            shift and go to state 230
    ID              reduce using rule 119 (empty -> .)
    PRINT           reduce using rule 119 (empty -> .)
    INPUT           reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    IF              reduce using rule 119 (empty -> .)
    WHILE           reduce using rule 119 (empty -> .)
    FOR             reduce using rule 119 (empty -> .)
    INT             reduce using rule 119 (empty -> .)
    FLOAT           reduce using rule 119 (empty -> .)
    STRING          reduce using rule 119 (empty -> .)
    #               reduce using rule 119 (empty -> .)
    TRACKDECISION   reduce using rule 119 (empty -> .)
    FORGETDECISION  reduce using rule 119 (empty -> .)
    }               reduce using rule 119 (empty -> .)

    empty                          shift and go to state 229
    else                           shift and go to state 228

state 224

    (117) paramsB -> , type ID paramsB .

    )               reduce using rule 117 (paramsB -> , type ID paramsB .)


state 225

    (32) assign -> ID dimensionsOpt = superexpression .

    ;               reduce using rule 32 (assign -> ID dimensionsOpt = superexpression .)


state 226

    (92) forloop -> FOR ( assign ; superexpression ; . superexpression ) block
    (54) superexpression -> . expression superexpressionB
    (58) expression -> . exp expressionB
    (66) exp -> . term expB
    (70) term -> . factor termB
    (74) factor -> . signB constant
    (75) factor -> . ( superexpression )
    (76) factor -> . funccall
    (77) factor -> . ID dimensionsOpt
    (78) signB -> . sign
    (79) signB -> . empty
    (108) funccall -> . DEF ID ( funccallB
    (84) sign -> . +
    (85) sign -> . -
    (119) empty -> .

    (               shift and go to state 56
    ID              shift and go to state 63
    DEF             shift and go to state 54
    +               shift and go to state 57
    -               shift and go to state 58
    FCONST          reduce using rule 119 (empty -> .)
    ICONST          reduce using rule 119 (empty -> .)
    TRUE            reduce using rule 119 (empty -> .)
    FALSE           reduce using rule 119 (empty -> .)

    term                           shift and go to state 64
    funccall                       shift and go to state 61
    signB                          shift and go to state 55
    sign                           shift and go to state 53
    superexpression                shift and go to state 231
    empty                          shift and go to state 60
    exp                            shift and go to state 65
    factor                         shift and go to state 59
    expression                     shift and go to state 66

state 227

    (94) inputB -> , ID inputB .

    )               reduce using rule 94 (inputB -> , ID inputB .)


state 228

    (36) condition -> IF ( superexpression ) block else .

    ID              reduce using rule 36 (condition -> IF ( superexpression ) block else .)
    PRINT           reduce using rule 36 (condition -> IF ( superexpression ) block else .)
    INPUT           reduce using rule 36 (condition -> IF ( superexpression ) block else .)
    RETURN          reduce using rule 36 (condition -> IF ( superexpression ) block else .)
    IF              reduce using rule 36 (condition -> IF ( superexpression ) block else .)
    WHILE           reduce using rule 36 (condition -> IF ( superexpression ) block else .)
    FOR             reduce using rule 36 (condition -> IF ( superexpression ) block else .)
    INT             reduce using rule 36 (condition -> IF ( superexpression ) block else .)
    FLOAT           reduce using rule 36 (condition -> IF ( superexpression ) block else .)
    STRING          reduce using rule 36 (condition -> IF ( superexpression ) block else .)
    #               reduce using rule 36 (condition -> IF ( superexpression ) block else .)
    TRACKDECISION   reduce using rule 36 (condition -> IF ( superexpression ) block else .)
    FORGETDECISION  reduce using rule 36 (condition -> IF ( superexpression ) block else .)
    }               reduce using rule 36 (condition -> IF ( superexpression ) block else .)


state 229

    (38) else -> empty .

    ID              reduce using rule 38 (else -> empty .)
    PRINT           reduce using rule 38 (else -> empty .)
    INPUT           reduce using rule 38 (else -> empty .)
    RETURN          reduce using rule 38 (else -> empty .)
    IF              reduce using rule 38 (else -> empty .)
    WHILE           reduce using rule 38 (else -> empty .)
    FOR             reduce using rule 38 (else -> empty .)
    INT             reduce using rule 38 (else -> empty .)
    FLOAT           reduce using rule 38 (else -> empty .)
    STRING          reduce using rule 38 (else -> empty .)
    #               reduce using rule 38 (else -> empty .)
    TRACKDECISION   reduce using rule 38 (else -> empty .)
    FORGETDECISION  reduce using rule 38 (else -> empty .)
    }               reduce using rule 38 (else -> empty .)


state 230

    (37) else -> ELSE . block
    (29) block -> . { instructionsOpt }

    {               shift and go to state 97

    block                          shift and go to state 232

state 231

    (92) forloop -> FOR ( assign ; superexpression ; superexpression . ) block

    )               shift and go to state 233


state 232

    (37) else -> ELSE block .

    ID              reduce using rule 37 (else -> ELSE block .)
    PRINT           reduce using rule 37 (else -> ELSE block .)
    INPUT           reduce using rule 37 (else -> ELSE block .)
    RETURN          reduce using rule 37 (else -> ELSE block .)
    IF              reduce using rule 37 (else -> ELSE block .)
    WHILE           reduce using rule 37 (else -> ELSE block .)
    FOR             reduce using rule 37 (else -> ELSE block .)
    INT             reduce using rule 37 (else -> ELSE block .)
    FLOAT           reduce using rule 37 (else -> ELSE block .)
    STRING          reduce using rule 37 (else -> ELSE block .)
    #               reduce using rule 37 (else -> ELSE block .)
    TRACKDECISION   reduce using rule 37 (else -> ELSE block .)
    FORGETDECISION  reduce using rule 37 (else -> ELSE block .)
    }               reduce using rule 37 (else -> ELSE block .)


state 233

    (92) forloop -> FOR ( assign ; superexpression ; superexpression ) . block
    (29) block -> . { instructionsOpt }

    {               shift and go to state 97

    block                          shift and go to state 234

state 234

    (92) forloop -> FOR ( assign ; superexpression ; superexpression ) block .

    ID              reduce using rule 92 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    PRINT           reduce using rule 92 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    INPUT           reduce using rule 92 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    RETURN          reduce using rule 92 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    IF              reduce using rule 92 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    WHILE           reduce using rule 92 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    FOR             reduce using rule 92 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    INT             reduce using rule 92 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    FLOAT           reduce using rule 92 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    STRING          reduce using rule 92 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    #               reduce using rule 92 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    TRACKDECISION   reduce using rule 92 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    FORGETDECISION  reduce using rule 92 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    }               reduce using rule 92 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 97 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 97 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 97 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 97 resolved as shift
WARNING: shift/reduce conflict for IF in state 97 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 97 resolved as shift
WARNING: shift/reduce conflict for FOR in state 97 resolved as shift
WARNING: shift/reduce conflict for INT in state 97 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 97 resolved as shift
WARNING: shift/reduce conflict for STRING in state 97 resolved as shift
WARNING: shift/reduce conflict for # in state 97 resolved as shift
WARNING: shift/reduce conflict for TRACKDECISION in state 97 resolved as shift
WARNING: shift/reduce conflict for FORGETDECISION in state 97 resolved as shift
WARNING: shift/reduce conflict for ID in state 143 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 143 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 143 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 143 resolved as shift
WARNING: shift/reduce conflict for IF in state 143 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 143 resolved as shift
WARNING: shift/reduce conflict for FOR in state 143 resolved as shift
WARNING: shift/reduce conflict for INT in state 143 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 143 resolved as shift
WARNING: shift/reduce conflict for STRING in state 143 resolved as shift
WARNING: shift/reduce conflict for # in state 143 resolved as shift
WARNING: shift/reduce conflict for TRACKDECISION in state 143 resolved as shift
WARNING: shift/reduce conflict for FORGETDECISION in state 143 resolved as shift
WARNING: reduce/reduce conflict in state 131 resolved using rule (instructionsOpt -> empty)
WARNING: rejected rule (localdecisiondirective -> empty) in state 131
