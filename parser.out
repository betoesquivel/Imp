Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> config body
Rule 2     config -> configdirective config
Rule 3     config -> empty
Rule 4     configdirective -> VARSCONFIG = options
Rule 5     configdirective -> DECISIONSCONFIG = options
Rule 6     configdirective -> COMPLEXITYCONFIG = optionsyesno
Rule 7     options -> SOME
Rule 8     options -> ALL
Rule 9     options -> MOST
Rule 10    options -> NONE
Rule 11    optionsyesno -> YES
Rule 12    optionsyesno -> NO
Rule 13    body -> declarationsOpt funcsOpt main funcsOpt
Rule 14    funcsOpt -> suprafunc funcsOpt
Rule 15    funcsOpt -> empty
Rule 16    declarationsOpt -> declaration declarationsOpt
Rule 17    declarationsOpt -> empty
Rule 18    declaration -> type push_type declarationB declarationC
Rule 19    declarationB -> ID push_operand dimensionsOpt
Rule 20    push_operand -> <empty>
Rule 21    push_type -> <empty>
Rule 22    repush_type -> <empty>
Rule 23    push_operator -> <empty>
Rule 24    quadruple_assign -> <empty>
Rule 25    declarationC -> = push_operator hyperexpression quadruple_assign declarationD
Rule 26    declarationC -> , repush_type declarationB declarationC
Rule 27    declarationC -> ;
Rule 28    declarationD -> , repush_type declarationB declarationC
Rule 29    declarationD -> ;
Rule 30    main -> MAIN ( ) block
Rule 31    suprafunc -> func block
Rule 32    func -> DEF returntype ID ( paramsOpt )
Rule 33    paramsOpt -> params paramsB
Rule 34    paramsOpt -> empty
Rule 35    block -> { instructionsOpt }
Rule 36    instructionsOpt -> instruction instructionsOpt
Rule 37    instructionsOpt -> empty
Rule 38    assign -> ID push_operand dimensionsOpt = push_operator hyperexpression quadruple_assign
Rule 39    assignB -> dimensionsOpt = push_operator hyperexpression quadruple_assign
Rule 40    dimensionsOpt -> dimensions
Rule 41    dimensionsOpt -> empty
Rule 42    condition -> IF ( hyperexpression ) block else
Rule 43    else -> ELSE block
Rule 44    else -> empty
Rule 45    instruction -> assignfunccall ;
Rule 46    instruction -> output ;
Rule 47    instruction -> return ;
Rule 48    instruction -> input ;
Rule 49    instruction -> declaration
Rule 50    instruction -> condition
Rule 51    instruction -> whileloop
Rule 52    instruction -> forloop
Rule 53    instruction -> localdirective
Rule 54    assignfunccall -> ID push_operand assignfunccallB
Rule 55    pop_operand -> <empty>
Rule 56    assignfunccallB -> ( pop_operand funccallB funccallC
Rule 57    assignfunccallB -> assignB
Rule 58    localdirective -> localvardirective
Rule 59    localdirective -> localdecisiondirective
Rule 60    localdirective -> localmsgdirective
Rule 61    hyperexpression -> superexpression hyperexpressionB
Rule 62    hyperexpressionB -> OR push_operator hyperexpression
Rule 63    hyperexpressionB -> empty
Rule 64    superexpression -> expression superexpressionB
Rule 65    superexpressionB -> AND push_operator superexpression
Rule 66    superexpressionB -> empty
Rule 67    expression -> exp expressionB
Rule 68    expressionB -> < push_operator exp
Rule 69    expressionB -> > push_operator exp
Rule 70    expressionB -> DIFF push_operator exp
Rule 71    expressionB -> EQ push_operator exp
Rule 72    expressionB -> LTEQ push_operator exp
Rule 73    expressionB -> GTEQ push_operator exp
Rule 74    expressionB -> empty
Rule 75    exp -> term seen_term expB
Rule 76    seen_term -> <empty>
Rule 77    expB -> - push_operator exp
Rule 78    expB -> + push_operator exp
Rule 79    expB -> empty
Rule 80    term -> factor seen_factor termB
Rule 81    seen_factor -> <empty>
Rule 82    termB -> / push_operator term
Rule 83    termB -> * push_operator term
Rule 84    termB -> empty
Rule 85    factor -> signB constant
Rule 86    factor -> ( seen_parentheses hyperexpression )
Rule 87    factor -> funccall
Rule 88    factor -> ID seen_ID dimensionsOpt
Rule 89    seen_parentheses -> <empty>
Rule 90    seen_ID -> <empty>
Rule 91    signB -> sign
Rule 92    signB -> empty
Rule 93    seen_fconst -> <empty>
Rule 94    seen_iconst -> <empty>
Rule 95    seen_sconst -> <empty>
Rule 96    seen_true -> <empty>
Rule 97    seen_false -> <empty>
Rule 98    constant -> FCONST seen_fconst
Rule 99    constant -> ICONST seen_iconst
Rule 100   constant -> SCONST seen_sconst
Rule 101   constant -> TRUE seen_true
Rule 102   constant -> FALSE seen_false
Rule 103   sign -> +
Rule 104   sign -> -
Rule 105   whileloop -> WHILE ( hyperexpression ) block
Rule 106   type -> INT
Rule 107   type -> FLOAT
Rule 108   type -> STRING
Rule 109   type -> BOOL
Rule 110   returntype -> VOID
Rule 111   returntype -> type
Rule 112   forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block
Rule 113   input -> INPUT ( ID inputB )
Rule 114   inputB -> , ID inputB
Rule 115   inputB -> empty
Rule 116   output -> PRINT ( outputB
Rule 117   outputB -> SCONST push_operand print_quadruple outputC
Rule 118   outputB -> hyperexpression print_quadruple outputC
Rule 119   print_quadruple -> <empty>
Rule 120   outputC -> )
Rule 121   outputC -> , outputB
Rule 122   localvardirective -> # localvardirectiveB ID
Rule 123   localvardirectiveB -> TRACK
Rule 124   localvardirectiveB -> FORGET
Rule 125   localmsgdirective -> # SHOW SCONST
Rule 126   localdecisiondirective -> TRACKDECISION
Rule 127   localdecisiondirective -> FORGETDECISION
Rule 128   localdecisiondirective -> empty
Rule 129   funccall -> ID ( funccallB funccallC
Rule 130   funccallB -> hyperexpression seen_param
Rule 131   funccallB -> empty
Rule 132   seen_param -> <empty>
Rule 133   funccallC -> , funccallB funccallC
Rule 134   funccallC -> )
Rule 135   dimensions -> [ hyperexpression ] dimensionsB
Rule 136   dimensionsB -> [ hyperexpression ]
Rule 137   dimensionsB -> empty
Rule 138   return -> RETURN hyperexpression
Rule 139   params -> type ID
Rule 140   paramsB -> , params paramsB
Rule 141   paramsB -> empty
Rule 142   empty -> <empty>

Terminals, with rules where they appear

#                    : 122 125
(                    : 30 32 42 56 86 105 112 113 116 129
)                    : 30 32 42 86 105 112 113 120 134
*                    : 83
+                    : 78 103
,                    : 26 28 114 121 133 140
-                    : 77 104
/                    : 82
;                    : 27 29 45 46 47 48 112 112
<                    : 68
=                    : 4 5 6 25 38 39
>                    : 69
ALL                  : 8
AND                  : 65
BOOL                 : 109
COMPLEXITYCONFIG     : 6
DECISIONSCONFIG      : 5
DEF                  : 32
DIFF                 : 70
ELSE                 : 43
EQ                   : 71
FALSE                : 102
FCONST               : 98
FLOAT                : 107
FOR                  : 112
FORGET               : 124
FORGETDECISION       : 127
GTEQ                 : 73
ICONST               : 99
ID                   : 19 32 38 54 88 113 114 122 129 139
IF                   : 42
INPUT                : 113
INT                  : 106
LTEQ                 : 72
MAIN                 : 30
MOST                 : 9
NO                   : 12
NONE                 : 10
OR                   : 62
PRINT                : 116
RETURN               : 138
SCONST               : 100 117 125
SHOW                 : 125
SOME                 : 7
STRING               : 108
TRACK                : 123
TRACKDECISION        : 126
TRUE                 : 101
VARSCONFIG           : 4
VOID                 : 110
WHILE                : 105
YES                  : 11
[                    : 135 136
]                    : 135 136
error                : 
{                    : 35
}                    : 35

Nonterminals, with rules where they appear

assign               : 112
assignB              : 57
assignfunccall       : 45
assignfunccallB      : 54
block                : 30 31 42 43 105 112
body                 : 1
condition            : 50
config               : 1 2
configdirective      : 2
constant             : 85
declaration          : 16 49
declarationB         : 18 26 28
declarationC         : 18 26 28
declarationD         : 25
declarationsOpt      : 13 16
dimensions           : 40
dimensionsB          : 135
dimensionsOpt        : 19 38 39 88
else                 : 42
empty                : 3 15 17 34 37 41 44 63 66 74 79 84 92 115 128 131 137 141
exp                  : 67 68 69 70 71 72 73 77 78
expB                 : 75
expression           : 64
expressionB          : 67
factor               : 80
forloop              : 52
func                 : 31
funccall             : 87
funccallB            : 56 129 133
funccallC            : 56 129 133
funcsOpt             : 13 13 14
hyperexpression      : 25 38 39 42 62 86 105 112 112 118 130 135 136 138
hyperexpressionB     : 61
input                : 48
inputB               : 113 114
instruction          : 36
instructionsOpt      : 35 36
localdecisiondirective : 59
localdirective       : 53
localmsgdirective    : 60
localvardirective    : 58
localvardirectiveB   : 122
main                 : 13
options              : 4 5
optionsyesno         : 6
output               : 46
outputB              : 116 121
outputC              : 117 118
params               : 33 140
paramsB              : 33 140
paramsOpt            : 32
pop_operand          : 56
print_quadruple      : 117 118
program              : 0
push_operand         : 19 38 54 117
push_operator        : 25 38 39 62 65 68 69 70 71 72 73 77 78 82 83
push_type            : 18
quadruple_assign     : 25 38 39
repush_type          : 26 28
return               : 47
returntype           : 32
seen_ID              : 88
seen_factor          : 80
seen_false           : 102
seen_fconst          : 98
seen_iconst          : 99
seen_param           : 130
seen_parentheses     : 86
seen_sconst          : 100
seen_term            : 75
seen_true            : 101
sign                 : 91
signB                : 85
superexpression      : 61 65
superexpressionB     : 64
suprafunc            : 14
term                 : 75 82 83
termB                : 80
type                 : 18 111 139
whileloop            : 51

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . config body
    (2) config -> . configdirective config
    (3) config -> . empty
    (4) configdirective -> . VARSCONFIG = options
    (5) configdirective -> . DECISIONSCONFIG = options
    (6) configdirective -> . COMPLEXITYCONFIG = optionsyesno
    (142) empty -> .

    VARSCONFIG      shift and go to state 2
    DECISIONSCONFIG shift and go to state 1
    COMPLEXITYCONFIG shift and go to state 4
    INT             reduce using rule 142 (empty -> .)
    FLOAT           reduce using rule 142 (empty -> .)
    STRING          reduce using rule 142 (empty -> .)
    BOOL            reduce using rule 142 (empty -> .)
    DEF             reduce using rule 142 (empty -> .)
    MAIN            reduce using rule 142 (empty -> .)

    configdirective                shift and go to state 3
    program                        shift and go to state 5
    config                         shift and go to state 6
    empty                          shift and go to state 7

state 1

    (5) configdirective -> DECISIONSCONFIG . = options

    =               shift and go to state 8


state 2

    (4) configdirective -> VARSCONFIG . = options

    =               shift and go to state 9


state 3

    (2) config -> configdirective . config
    (2) config -> . configdirective config
    (3) config -> . empty
    (4) configdirective -> . VARSCONFIG = options
    (5) configdirective -> . DECISIONSCONFIG = options
    (6) configdirective -> . COMPLEXITYCONFIG = optionsyesno
    (142) empty -> .

    VARSCONFIG      shift and go to state 2
    DECISIONSCONFIG shift and go to state 1
    COMPLEXITYCONFIG shift and go to state 4
    INT             reduce using rule 142 (empty -> .)
    FLOAT           reduce using rule 142 (empty -> .)
    STRING          reduce using rule 142 (empty -> .)
    BOOL            reduce using rule 142 (empty -> .)
    DEF             reduce using rule 142 (empty -> .)
    MAIN            reduce using rule 142 (empty -> .)

    config                         shift and go to state 10
    empty                          shift and go to state 7
    configdirective                shift and go to state 3

state 4

    (6) configdirective -> COMPLEXITYCONFIG . = optionsyesno

    =               shift and go to state 11


state 5

    (0) S' -> program .



state 6

    (1) program -> config . body
    (13) body -> . declarationsOpt funcsOpt main funcsOpt
    (16) declarationsOpt -> . declaration declarationsOpt
    (17) declarationsOpt -> . empty
    (18) declaration -> . type push_type declarationB declarationC
    (142) empty -> .
    (106) type -> . INT
    (107) type -> . FLOAT
    (108) type -> . STRING
    (109) type -> . BOOL

    DEF             reduce using rule 142 (empty -> .)
    MAIN            reduce using rule 142 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18

    body                           shift and go to state 12
    declarationsOpt                shift and go to state 13
    type                           shift and go to state 16
    declaration                    shift and go to state 19
    empty                          shift and go to state 20

state 7

    (3) config -> empty .

    INT             reduce using rule 3 (config -> empty .)
    FLOAT           reduce using rule 3 (config -> empty .)
    STRING          reduce using rule 3 (config -> empty .)
    BOOL            reduce using rule 3 (config -> empty .)
    DEF             reduce using rule 3 (config -> empty .)
    MAIN            reduce using rule 3 (config -> empty .)


state 8

    (5) configdirective -> DECISIONSCONFIG = . options
    (7) options -> . SOME
    (8) options -> . ALL
    (9) options -> . MOST
    (10) options -> . NONE

    SOME            shift and go to state 22
    ALL             shift and go to state 21
    MOST            shift and go to state 24
    NONE            shift and go to state 23

    options                        shift and go to state 25

state 9

    (4) configdirective -> VARSCONFIG = . options
    (7) options -> . SOME
    (8) options -> . ALL
    (9) options -> . MOST
    (10) options -> . NONE

    SOME            shift and go to state 22
    ALL             shift and go to state 21
    MOST            shift and go to state 24
    NONE            shift and go to state 23

    options                        shift and go to state 26

state 10

    (2) config -> configdirective config .

    INT             reduce using rule 2 (config -> configdirective config .)
    FLOAT           reduce using rule 2 (config -> configdirective config .)
    STRING          reduce using rule 2 (config -> configdirective config .)
    BOOL            reduce using rule 2 (config -> configdirective config .)
    DEF             reduce using rule 2 (config -> configdirective config .)
    MAIN            reduce using rule 2 (config -> configdirective config .)


state 11

    (6) configdirective -> COMPLEXITYCONFIG = . optionsyesno
    (11) optionsyesno -> . YES
    (12) optionsyesno -> . NO

    YES             shift and go to state 27
    NO              shift and go to state 29

    optionsyesno                   shift and go to state 28

state 12

    (1) program -> config body .

    $end            reduce using rule 1 (program -> config body .)


state 13

    (13) body -> declarationsOpt . funcsOpt main funcsOpt
    (14) funcsOpt -> . suprafunc funcsOpt
    (15) funcsOpt -> . empty
    (31) suprafunc -> . func block
    (142) empty -> .
    (32) func -> . DEF returntype ID ( paramsOpt )

    MAIN            reduce using rule 142 (empty -> .)
    DEF             shift and go to state 33

    suprafunc                      shift and go to state 30
    funcsOpt                       shift and go to state 31
    func                           shift and go to state 32
    empty                          shift and go to state 34

state 14

    (108) type -> STRING .

    ID              reduce using rule 108 (type -> STRING .)


state 15

    (106) type -> INT .

    ID              reduce using rule 106 (type -> INT .)


state 16

    (18) declaration -> type . push_type declarationB declarationC
    (21) push_type -> .

    ID              reduce using rule 21 (push_type -> .)

    push_type                      shift and go to state 35

state 17

    (107) type -> FLOAT .

    ID              reduce using rule 107 (type -> FLOAT .)


state 18

    (109) type -> BOOL .

    ID              reduce using rule 109 (type -> BOOL .)


state 19

    (16) declarationsOpt -> declaration . declarationsOpt
    (16) declarationsOpt -> . declaration declarationsOpt
    (17) declarationsOpt -> . empty
    (18) declaration -> . type push_type declarationB declarationC
    (142) empty -> .
    (106) type -> . INT
    (107) type -> . FLOAT
    (108) type -> . STRING
    (109) type -> . BOOL

    DEF             reduce using rule 142 (empty -> .)
    MAIN            reduce using rule 142 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18

    declarationsOpt                shift and go to state 36
    declaration                    shift and go to state 19
    type                           shift and go to state 16
    empty                          shift and go to state 20

state 20

    (17) declarationsOpt -> empty .

    DEF             reduce using rule 17 (declarationsOpt -> empty .)
    MAIN            reduce using rule 17 (declarationsOpt -> empty .)


state 21

    (8) options -> ALL .

    VARSCONFIG      reduce using rule 8 (options -> ALL .)
    DECISIONSCONFIG reduce using rule 8 (options -> ALL .)
    COMPLEXITYCONFIG reduce using rule 8 (options -> ALL .)
    INT             reduce using rule 8 (options -> ALL .)
    FLOAT           reduce using rule 8 (options -> ALL .)
    STRING          reduce using rule 8 (options -> ALL .)
    BOOL            reduce using rule 8 (options -> ALL .)
    DEF             reduce using rule 8 (options -> ALL .)
    MAIN            reduce using rule 8 (options -> ALL .)


state 22

    (7) options -> SOME .

    VARSCONFIG      reduce using rule 7 (options -> SOME .)
    DECISIONSCONFIG reduce using rule 7 (options -> SOME .)
    COMPLEXITYCONFIG reduce using rule 7 (options -> SOME .)
    INT             reduce using rule 7 (options -> SOME .)
    FLOAT           reduce using rule 7 (options -> SOME .)
    STRING          reduce using rule 7 (options -> SOME .)
    BOOL            reduce using rule 7 (options -> SOME .)
    DEF             reduce using rule 7 (options -> SOME .)
    MAIN            reduce using rule 7 (options -> SOME .)


state 23

    (10) options -> NONE .

    VARSCONFIG      reduce using rule 10 (options -> NONE .)
    DECISIONSCONFIG reduce using rule 10 (options -> NONE .)
    COMPLEXITYCONFIG reduce using rule 10 (options -> NONE .)
    INT             reduce using rule 10 (options -> NONE .)
    FLOAT           reduce using rule 10 (options -> NONE .)
    STRING          reduce using rule 10 (options -> NONE .)
    BOOL            reduce using rule 10 (options -> NONE .)
    DEF             reduce using rule 10 (options -> NONE .)
    MAIN            reduce using rule 10 (options -> NONE .)


state 24

    (9) options -> MOST .

    VARSCONFIG      reduce using rule 9 (options -> MOST .)
    DECISIONSCONFIG reduce using rule 9 (options -> MOST .)
    COMPLEXITYCONFIG reduce using rule 9 (options -> MOST .)
    INT             reduce using rule 9 (options -> MOST .)
    FLOAT           reduce using rule 9 (options -> MOST .)
    STRING          reduce using rule 9 (options -> MOST .)
    BOOL            reduce using rule 9 (options -> MOST .)
    DEF             reduce using rule 9 (options -> MOST .)
    MAIN            reduce using rule 9 (options -> MOST .)


state 25

    (5) configdirective -> DECISIONSCONFIG = options .

    VARSCONFIG      reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    DECISIONSCONFIG reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    COMPLEXITYCONFIG reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    INT             reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    FLOAT           reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    STRING          reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    BOOL            reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    DEF             reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    MAIN            reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)


state 26

    (4) configdirective -> VARSCONFIG = options .

    VARSCONFIG      reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    DECISIONSCONFIG reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    COMPLEXITYCONFIG reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    INT             reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    FLOAT           reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    STRING          reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    BOOL            reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    DEF             reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    MAIN            reduce using rule 4 (configdirective -> VARSCONFIG = options .)


state 27

    (11) optionsyesno -> YES .

    VARSCONFIG      reduce using rule 11 (optionsyesno -> YES .)
    DECISIONSCONFIG reduce using rule 11 (optionsyesno -> YES .)
    COMPLEXITYCONFIG reduce using rule 11 (optionsyesno -> YES .)
    INT             reduce using rule 11 (optionsyesno -> YES .)
    FLOAT           reduce using rule 11 (optionsyesno -> YES .)
    STRING          reduce using rule 11 (optionsyesno -> YES .)
    BOOL            reduce using rule 11 (optionsyesno -> YES .)
    DEF             reduce using rule 11 (optionsyesno -> YES .)
    MAIN            reduce using rule 11 (optionsyesno -> YES .)


state 28

    (6) configdirective -> COMPLEXITYCONFIG = optionsyesno .

    VARSCONFIG      reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    DECISIONSCONFIG reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    COMPLEXITYCONFIG reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    INT             reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    FLOAT           reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    STRING          reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    BOOL            reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    DEF             reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    MAIN            reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)


state 29

    (12) optionsyesno -> NO .

    VARSCONFIG      reduce using rule 12 (optionsyesno -> NO .)
    DECISIONSCONFIG reduce using rule 12 (optionsyesno -> NO .)
    COMPLEXITYCONFIG reduce using rule 12 (optionsyesno -> NO .)
    INT             reduce using rule 12 (optionsyesno -> NO .)
    FLOAT           reduce using rule 12 (optionsyesno -> NO .)
    STRING          reduce using rule 12 (optionsyesno -> NO .)
    BOOL            reduce using rule 12 (optionsyesno -> NO .)
    DEF             reduce using rule 12 (optionsyesno -> NO .)
    MAIN            reduce using rule 12 (optionsyesno -> NO .)


state 30

    (14) funcsOpt -> suprafunc . funcsOpt
    (14) funcsOpt -> . suprafunc funcsOpt
    (15) funcsOpt -> . empty
    (31) suprafunc -> . func block
    (142) empty -> .
    (32) func -> . DEF returntype ID ( paramsOpt )

    MAIN            reduce using rule 142 (empty -> .)
    $end            reduce using rule 142 (empty -> .)
    DEF             shift and go to state 33

    suprafunc                      shift and go to state 30
    funcsOpt                       shift and go to state 37
    empty                          shift and go to state 34
    func                           shift and go to state 32

state 31

    (13) body -> declarationsOpt funcsOpt . main funcsOpt
    (30) main -> . MAIN ( ) block

    MAIN            shift and go to state 38

    main                           shift and go to state 39

state 32

    (31) suprafunc -> func . block
    (35) block -> . { instructionsOpt }

    {               shift and go to state 40

    block                          shift and go to state 41

state 33

    (32) func -> DEF . returntype ID ( paramsOpt )
    (110) returntype -> . VOID
    (111) returntype -> . type
    (106) type -> . INT
    (107) type -> . FLOAT
    (108) type -> . STRING
    (109) type -> . BOOL

    VOID            shift and go to state 42
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18

    returntype                     shift and go to state 43
    type                           shift and go to state 44

state 34

    (15) funcsOpt -> empty .

    MAIN            reduce using rule 15 (funcsOpt -> empty .)
    $end            reduce using rule 15 (funcsOpt -> empty .)


state 35

    (18) declaration -> type push_type . declarationB declarationC
    (19) declarationB -> . ID push_operand dimensionsOpt

    ID              shift and go to state 45

    declarationB                   shift and go to state 46

state 36

    (16) declarationsOpt -> declaration declarationsOpt .

    DEF             reduce using rule 16 (declarationsOpt -> declaration declarationsOpt .)
    MAIN            reduce using rule 16 (declarationsOpt -> declaration declarationsOpt .)


state 37

    (14) funcsOpt -> suprafunc funcsOpt .

    MAIN            reduce using rule 14 (funcsOpt -> suprafunc funcsOpt .)
    $end            reduce using rule 14 (funcsOpt -> suprafunc funcsOpt .)


state 38

    (30) main -> MAIN . ( ) block

    (               shift and go to state 47


state 39

    (13) body -> declarationsOpt funcsOpt main . funcsOpt
    (14) funcsOpt -> . suprafunc funcsOpt
    (15) funcsOpt -> . empty
    (31) suprafunc -> . func block
    (142) empty -> .
    (32) func -> . DEF returntype ID ( paramsOpt )

    $end            reduce using rule 142 (empty -> .)
    DEF             shift and go to state 33

    suprafunc                      shift and go to state 30
    funcsOpt                       shift and go to state 48
    func                           shift and go to state 32
    empty                          shift and go to state 34

state 40

    (35) block -> { . instructionsOpt }
    (36) instructionsOpt -> . instruction instructionsOpt
    (37) instructionsOpt -> . empty
    (45) instruction -> . assignfunccall ;
    (46) instruction -> . output ;
    (47) instruction -> . return ;
    (48) instruction -> . input ;
    (49) instruction -> . declaration
    (50) instruction -> . condition
    (51) instruction -> . whileloop
    (52) instruction -> . forloop
    (53) instruction -> . localdirective
    (142) empty -> .
    (54) assignfunccall -> . ID push_operand assignfunccallB
    (116) output -> . PRINT ( outputB
    (138) return -> . RETURN hyperexpression
    (113) input -> . INPUT ( ID inputB )
    (18) declaration -> . type push_type declarationB declarationC
    (42) condition -> . IF ( hyperexpression ) block else
    (105) whileloop -> . WHILE ( hyperexpression ) block
    (112) forloop -> . FOR ( assign ; hyperexpression ; hyperexpression ) block
    (58) localdirective -> . localvardirective
    (59) localdirective -> . localdecisiondirective
    (60) localdirective -> . localmsgdirective
    (106) type -> . INT
    (107) type -> . FLOAT
    (108) type -> . STRING
    (109) type -> . BOOL
    (122) localvardirective -> . # localvardirectiveB ID
    (126) localdecisiondirective -> . TRACKDECISION
    (127) localdecisiondirective -> . FORGETDECISION
    (128) localdecisiondirective -> . empty
    (125) localmsgdirective -> . # SHOW SCONST

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for TRACKDECISION resolved as shift
  ! shift/reduce conflict for FORGETDECISION resolved as shift
    }               reduce using rule 142 (empty -> .)
    ID              shift and go to state 67
    PRINT           shift and go to state 52
    RETURN          shift and go to state 49
    INPUT           shift and go to state 66
    IF              shift and go to state 69
    WHILE           shift and go to state 51
    FOR             shift and go to state 61
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18
    #               shift and go to state 54
    TRACKDECISION   shift and go to state 56
    FORGETDECISION  shift and go to state 63

  ! ID              [ reduce using rule 142 (empty -> .) ]
  ! PRINT           [ reduce using rule 142 (empty -> .) ]
  ! RETURN          [ reduce using rule 142 (empty -> .) ]
  ! INPUT           [ reduce using rule 142 (empty -> .) ]
  ! IF              [ reduce using rule 142 (empty -> .) ]
  ! WHILE           [ reduce using rule 142 (empty -> .) ]
  ! FOR             [ reduce using rule 142 (empty -> .) ]
  ! INT             [ reduce using rule 142 (empty -> .) ]
  ! FLOAT           [ reduce using rule 142 (empty -> .) ]
  ! STRING          [ reduce using rule 142 (empty -> .) ]
  ! BOOL            [ reduce using rule 142 (empty -> .) ]
  ! #               [ reduce using rule 142 (empty -> .) ]
  ! TRACKDECISION   [ reduce using rule 142 (empty -> .) ]
  ! FORGETDECISION  [ reduce using rule 142 (empty -> .) ]

    assignfunccall                 shift and go to state 50
    whileloop                      shift and go to state 53
    localvardirective              shift and go to state 55
    input                          shift and go to state 57
    type                           shift and go to state 16
    empty                          shift and go to state 58
    forloop                        shift and go to state 59
    return                         shift and go to state 60
    instructionsOpt                shift and go to state 62
    localdirective                 shift and go to state 64
    declaration                    shift and go to state 65
    condition                      shift and go to state 68
    instruction                    shift and go to state 70
    localmsgdirective              shift and go to state 71
    localdecisiondirective         shift and go to state 72
    output                         shift and go to state 73

state 41

    (31) suprafunc -> func block .

    DEF             reduce using rule 31 (suprafunc -> func block .)
    MAIN            reduce using rule 31 (suprafunc -> func block .)
    $end            reduce using rule 31 (suprafunc -> func block .)


state 42

    (110) returntype -> VOID .

    ID              reduce using rule 110 (returntype -> VOID .)


state 43

    (32) func -> DEF returntype . ID ( paramsOpt )

    ID              shift and go to state 74


state 44

    (111) returntype -> type .

    ID              reduce using rule 111 (returntype -> type .)


state 45

    (19) declarationB -> ID . push_operand dimensionsOpt
    (20) push_operand -> .

    [               reduce using rule 20 (push_operand -> .)
    =               reduce using rule 20 (push_operand -> .)
    ,               reduce using rule 20 (push_operand -> .)
    ;               reduce using rule 20 (push_operand -> .)

    push_operand                   shift and go to state 75

state 46

    (18) declaration -> type push_type declarationB . declarationC
    (25) declarationC -> . = push_operator hyperexpression quadruple_assign declarationD
    (26) declarationC -> . , repush_type declarationB declarationC
    (27) declarationC -> . ;

    =               shift and go to state 79
    ,               shift and go to state 76
    ;               shift and go to state 77

    declarationC                   shift and go to state 78

state 47

    (30) main -> MAIN ( . ) block

    )               shift and go to state 80


state 48

    (13) body -> declarationsOpt funcsOpt main funcsOpt .

    $end            reduce using rule 13 (body -> declarationsOpt funcsOpt main funcsOpt .)


state 49

    (138) return -> RETURN . hyperexpression
    (61) hyperexpression -> . superexpression hyperexpressionB
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    sign                           shift and go to state 90
    signB                          shift and go to state 81
    hyperexpression                shift and go to state 85
    factor                         shift and go to state 86
    empty                          shift and go to state 87
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 50

    (45) instruction -> assignfunccall . ;

    ;               shift and go to state 95


state 51

    (105) whileloop -> WHILE . ( hyperexpression ) block

    (               shift and go to state 96


state 52

    (116) output -> PRINT . ( outputB

    (               shift and go to state 97


state 53

    (51) instruction -> whileloop .

    ID              reduce using rule 51 (instruction -> whileloop .)
    PRINT           reduce using rule 51 (instruction -> whileloop .)
    RETURN          reduce using rule 51 (instruction -> whileloop .)
    INPUT           reduce using rule 51 (instruction -> whileloop .)
    IF              reduce using rule 51 (instruction -> whileloop .)
    WHILE           reduce using rule 51 (instruction -> whileloop .)
    FOR             reduce using rule 51 (instruction -> whileloop .)
    INT             reduce using rule 51 (instruction -> whileloop .)
    FLOAT           reduce using rule 51 (instruction -> whileloop .)
    STRING          reduce using rule 51 (instruction -> whileloop .)
    BOOL            reduce using rule 51 (instruction -> whileloop .)
    #               reduce using rule 51 (instruction -> whileloop .)
    TRACKDECISION   reduce using rule 51 (instruction -> whileloop .)
    FORGETDECISION  reduce using rule 51 (instruction -> whileloop .)
    }               reduce using rule 51 (instruction -> whileloop .)


state 54

    (122) localvardirective -> # . localvardirectiveB ID
    (125) localmsgdirective -> # . SHOW SCONST
    (123) localvardirectiveB -> . TRACK
    (124) localvardirectiveB -> . FORGET

    SHOW            shift and go to state 99
    TRACK           shift and go to state 100
    FORGET          shift and go to state 98

    localvardirectiveB             shift and go to state 101

state 55

    (58) localdirective -> localvardirective .

    ID              reduce using rule 58 (localdirective -> localvardirective .)
    PRINT           reduce using rule 58 (localdirective -> localvardirective .)
    RETURN          reduce using rule 58 (localdirective -> localvardirective .)
    INPUT           reduce using rule 58 (localdirective -> localvardirective .)
    IF              reduce using rule 58 (localdirective -> localvardirective .)
    WHILE           reduce using rule 58 (localdirective -> localvardirective .)
    FOR             reduce using rule 58 (localdirective -> localvardirective .)
    INT             reduce using rule 58 (localdirective -> localvardirective .)
    FLOAT           reduce using rule 58 (localdirective -> localvardirective .)
    STRING          reduce using rule 58 (localdirective -> localvardirective .)
    BOOL            reduce using rule 58 (localdirective -> localvardirective .)
    #               reduce using rule 58 (localdirective -> localvardirective .)
    TRACKDECISION   reduce using rule 58 (localdirective -> localvardirective .)
    FORGETDECISION  reduce using rule 58 (localdirective -> localvardirective .)
    }               reduce using rule 58 (localdirective -> localvardirective .)


state 56

    (126) localdecisiondirective -> TRACKDECISION .

    ID              reduce using rule 126 (localdecisiondirective -> TRACKDECISION .)
    PRINT           reduce using rule 126 (localdecisiondirective -> TRACKDECISION .)
    RETURN          reduce using rule 126 (localdecisiondirective -> TRACKDECISION .)
    INPUT           reduce using rule 126 (localdecisiondirective -> TRACKDECISION .)
    IF              reduce using rule 126 (localdecisiondirective -> TRACKDECISION .)
    WHILE           reduce using rule 126 (localdecisiondirective -> TRACKDECISION .)
    FOR             reduce using rule 126 (localdecisiondirective -> TRACKDECISION .)
    INT             reduce using rule 126 (localdecisiondirective -> TRACKDECISION .)
    FLOAT           reduce using rule 126 (localdecisiondirective -> TRACKDECISION .)
    STRING          reduce using rule 126 (localdecisiondirective -> TRACKDECISION .)
    BOOL            reduce using rule 126 (localdecisiondirective -> TRACKDECISION .)
    #               reduce using rule 126 (localdecisiondirective -> TRACKDECISION .)
    TRACKDECISION   reduce using rule 126 (localdecisiondirective -> TRACKDECISION .)
    FORGETDECISION  reduce using rule 126 (localdecisiondirective -> TRACKDECISION .)
    }               reduce using rule 126 (localdecisiondirective -> TRACKDECISION .)


state 57

    (48) instruction -> input . ;

    ;               shift and go to state 102


state 58

    (37) instructionsOpt -> empty .
    (128) localdecisiondirective -> empty .

  ! reduce/reduce conflict for } resolved using rule 37 (instructionsOpt -> empty .)
    }               reduce using rule 37 (instructionsOpt -> empty .)
    ID              reduce using rule 128 (localdecisiondirective -> empty .)
    PRINT           reduce using rule 128 (localdecisiondirective -> empty .)
    RETURN          reduce using rule 128 (localdecisiondirective -> empty .)
    INPUT           reduce using rule 128 (localdecisiondirective -> empty .)
    IF              reduce using rule 128 (localdecisiondirective -> empty .)
    WHILE           reduce using rule 128 (localdecisiondirective -> empty .)
    FOR             reduce using rule 128 (localdecisiondirective -> empty .)
    INT             reduce using rule 128 (localdecisiondirective -> empty .)
    FLOAT           reduce using rule 128 (localdecisiondirective -> empty .)
    STRING          reduce using rule 128 (localdecisiondirective -> empty .)
    BOOL            reduce using rule 128 (localdecisiondirective -> empty .)
    #               reduce using rule 128 (localdecisiondirective -> empty .)
    TRACKDECISION   reduce using rule 128 (localdecisiondirective -> empty .)
    FORGETDECISION  reduce using rule 128 (localdecisiondirective -> empty .)

  ! }               [ reduce using rule 128 (localdecisiondirective -> empty .) ]


state 59

    (52) instruction -> forloop .

    ID              reduce using rule 52 (instruction -> forloop .)
    PRINT           reduce using rule 52 (instruction -> forloop .)
    RETURN          reduce using rule 52 (instruction -> forloop .)
    INPUT           reduce using rule 52 (instruction -> forloop .)
    IF              reduce using rule 52 (instruction -> forloop .)
    WHILE           reduce using rule 52 (instruction -> forloop .)
    FOR             reduce using rule 52 (instruction -> forloop .)
    INT             reduce using rule 52 (instruction -> forloop .)
    FLOAT           reduce using rule 52 (instruction -> forloop .)
    STRING          reduce using rule 52 (instruction -> forloop .)
    BOOL            reduce using rule 52 (instruction -> forloop .)
    #               reduce using rule 52 (instruction -> forloop .)
    TRACKDECISION   reduce using rule 52 (instruction -> forloop .)
    FORGETDECISION  reduce using rule 52 (instruction -> forloop .)
    }               reduce using rule 52 (instruction -> forloop .)


state 60

    (47) instruction -> return . ;

    ;               shift and go to state 103


state 61

    (112) forloop -> FOR . ( assign ; hyperexpression ; hyperexpression ) block

    (               shift and go to state 104


state 62

    (35) block -> { instructionsOpt . }

    }               shift and go to state 105


state 63

    (127) localdecisiondirective -> FORGETDECISION .

    ID              reduce using rule 127 (localdecisiondirective -> FORGETDECISION .)
    PRINT           reduce using rule 127 (localdecisiondirective -> FORGETDECISION .)
    RETURN          reduce using rule 127 (localdecisiondirective -> FORGETDECISION .)
    INPUT           reduce using rule 127 (localdecisiondirective -> FORGETDECISION .)
    IF              reduce using rule 127 (localdecisiondirective -> FORGETDECISION .)
    WHILE           reduce using rule 127 (localdecisiondirective -> FORGETDECISION .)
    FOR             reduce using rule 127 (localdecisiondirective -> FORGETDECISION .)
    INT             reduce using rule 127 (localdecisiondirective -> FORGETDECISION .)
    FLOAT           reduce using rule 127 (localdecisiondirective -> FORGETDECISION .)
    STRING          reduce using rule 127 (localdecisiondirective -> FORGETDECISION .)
    BOOL            reduce using rule 127 (localdecisiondirective -> FORGETDECISION .)
    #               reduce using rule 127 (localdecisiondirective -> FORGETDECISION .)
    TRACKDECISION   reduce using rule 127 (localdecisiondirective -> FORGETDECISION .)
    FORGETDECISION  reduce using rule 127 (localdecisiondirective -> FORGETDECISION .)
    }               reduce using rule 127 (localdecisiondirective -> FORGETDECISION .)


state 64

    (53) instruction -> localdirective .

    ID              reduce using rule 53 (instruction -> localdirective .)
    PRINT           reduce using rule 53 (instruction -> localdirective .)
    RETURN          reduce using rule 53 (instruction -> localdirective .)
    INPUT           reduce using rule 53 (instruction -> localdirective .)
    IF              reduce using rule 53 (instruction -> localdirective .)
    WHILE           reduce using rule 53 (instruction -> localdirective .)
    FOR             reduce using rule 53 (instruction -> localdirective .)
    INT             reduce using rule 53 (instruction -> localdirective .)
    FLOAT           reduce using rule 53 (instruction -> localdirective .)
    STRING          reduce using rule 53 (instruction -> localdirective .)
    BOOL            reduce using rule 53 (instruction -> localdirective .)
    #               reduce using rule 53 (instruction -> localdirective .)
    TRACKDECISION   reduce using rule 53 (instruction -> localdirective .)
    FORGETDECISION  reduce using rule 53 (instruction -> localdirective .)
    }               reduce using rule 53 (instruction -> localdirective .)


state 65

    (49) instruction -> declaration .

    ID              reduce using rule 49 (instruction -> declaration .)
    PRINT           reduce using rule 49 (instruction -> declaration .)
    RETURN          reduce using rule 49 (instruction -> declaration .)
    INPUT           reduce using rule 49 (instruction -> declaration .)
    IF              reduce using rule 49 (instruction -> declaration .)
    WHILE           reduce using rule 49 (instruction -> declaration .)
    FOR             reduce using rule 49 (instruction -> declaration .)
    INT             reduce using rule 49 (instruction -> declaration .)
    FLOAT           reduce using rule 49 (instruction -> declaration .)
    STRING          reduce using rule 49 (instruction -> declaration .)
    BOOL            reduce using rule 49 (instruction -> declaration .)
    #               reduce using rule 49 (instruction -> declaration .)
    TRACKDECISION   reduce using rule 49 (instruction -> declaration .)
    FORGETDECISION  reduce using rule 49 (instruction -> declaration .)
    }               reduce using rule 49 (instruction -> declaration .)


state 66

    (113) input -> INPUT . ( ID inputB )

    (               shift and go to state 106


state 67

    (54) assignfunccall -> ID . push_operand assignfunccallB
    (20) push_operand -> .

    (               reduce using rule 20 (push_operand -> .)
    [               reduce using rule 20 (push_operand -> .)
    =               reduce using rule 20 (push_operand -> .)

    push_operand                   shift and go to state 107

state 68

    (50) instruction -> condition .

    ID              reduce using rule 50 (instruction -> condition .)
    PRINT           reduce using rule 50 (instruction -> condition .)
    RETURN          reduce using rule 50 (instruction -> condition .)
    INPUT           reduce using rule 50 (instruction -> condition .)
    IF              reduce using rule 50 (instruction -> condition .)
    WHILE           reduce using rule 50 (instruction -> condition .)
    FOR             reduce using rule 50 (instruction -> condition .)
    INT             reduce using rule 50 (instruction -> condition .)
    FLOAT           reduce using rule 50 (instruction -> condition .)
    STRING          reduce using rule 50 (instruction -> condition .)
    BOOL            reduce using rule 50 (instruction -> condition .)
    #               reduce using rule 50 (instruction -> condition .)
    TRACKDECISION   reduce using rule 50 (instruction -> condition .)
    FORGETDECISION  reduce using rule 50 (instruction -> condition .)
    }               reduce using rule 50 (instruction -> condition .)


state 69

    (42) condition -> IF . ( hyperexpression ) block else

    (               shift and go to state 108


state 70

    (36) instructionsOpt -> instruction . instructionsOpt
    (36) instructionsOpt -> . instruction instructionsOpt
    (37) instructionsOpt -> . empty
    (45) instruction -> . assignfunccall ;
    (46) instruction -> . output ;
    (47) instruction -> . return ;
    (48) instruction -> . input ;
    (49) instruction -> . declaration
    (50) instruction -> . condition
    (51) instruction -> . whileloop
    (52) instruction -> . forloop
    (53) instruction -> . localdirective
    (142) empty -> .
    (54) assignfunccall -> . ID push_operand assignfunccallB
    (116) output -> . PRINT ( outputB
    (138) return -> . RETURN hyperexpression
    (113) input -> . INPUT ( ID inputB )
    (18) declaration -> . type push_type declarationB declarationC
    (42) condition -> . IF ( hyperexpression ) block else
    (105) whileloop -> . WHILE ( hyperexpression ) block
    (112) forloop -> . FOR ( assign ; hyperexpression ; hyperexpression ) block
    (58) localdirective -> . localvardirective
    (59) localdirective -> . localdecisiondirective
    (60) localdirective -> . localmsgdirective
    (106) type -> . INT
    (107) type -> . FLOAT
    (108) type -> . STRING
    (109) type -> . BOOL
    (122) localvardirective -> . # localvardirectiveB ID
    (126) localdecisiondirective -> . TRACKDECISION
    (127) localdecisiondirective -> . FORGETDECISION
    (128) localdecisiondirective -> . empty
    (125) localmsgdirective -> . # SHOW SCONST

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for TRACKDECISION resolved as shift
  ! shift/reduce conflict for FORGETDECISION resolved as shift
    }               reduce using rule 142 (empty -> .)
    ID              shift and go to state 67
    PRINT           shift and go to state 52
    RETURN          shift and go to state 49
    INPUT           shift and go to state 66
    IF              shift and go to state 69
    WHILE           shift and go to state 51
    FOR             shift and go to state 61
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18
    #               shift and go to state 54
    TRACKDECISION   shift and go to state 56
    FORGETDECISION  shift and go to state 63

  ! ID              [ reduce using rule 142 (empty -> .) ]
  ! PRINT           [ reduce using rule 142 (empty -> .) ]
  ! RETURN          [ reduce using rule 142 (empty -> .) ]
  ! INPUT           [ reduce using rule 142 (empty -> .) ]
  ! IF              [ reduce using rule 142 (empty -> .) ]
  ! WHILE           [ reduce using rule 142 (empty -> .) ]
  ! FOR             [ reduce using rule 142 (empty -> .) ]
  ! INT             [ reduce using rule 142 (empty -> .) ]
  ! FLOAT           [ reduce using rule 142 (empty -> .) ]
  ! STRING          [ reduce using rule 142 (empty -> .) ]
  ! BOOL            [ reduce using rule 142 (empty -> .) ]
  ! #               [ reduce using rule 142 (empty -> .) ]
  ! TRACKDECISION   [ reduce using rule 142 (empty -> .) ]
  ! FORGETDECISION  [ reduce using rule 142 (empty -> .) ]

    assignfunccall                 shift and go to state 50
    whileloop                      shift and go to state 53
    localvardirective              shift and go to state 55
    input                          shift and go to state 57
    type                           shift and go to state 16
    empty                          shift and go to state 58
    forloop                        shift and go to state 59
    return                         shift and go to state 60
    instructionsOpt                shift and go to state 109
    localdirective                 shift and go to state 64
    declaration                    shift and go to state 65
    condition                      shift and go to state 68
    instruction                    shift and go to state 70
    localmsgdirective              shift and go to state 71
    localdecisiondirective         shift and go to state 72
    output                         shift and go to state 73

state 71

    (60) localdirective -> localmsgdirective .

    ID              reduce using rule 60 (localdirective -> localmsgdirective .)
    PRINT           reduce using rule 60 (localdirective -> localmsgdirective .)
    RETURN          reduce using rule 60 (localdirective -> localmsgdirective .)
    INPUT           reduce using rule 60 (localdirective -> localmsgdirective .)
    IF              reduce using rule 60 (localdirective -> localmsgdirective .)
    WHILE           reduce using rule 60 (localdirective -> localmsgdirective .)
    FOR             reduce using rule 60 (localdirective -> localmsgdirective .)
    INT             reduce using rule 60 (localdirective -> localmsgdirective .)
    FLOAT           reduce using rule 60 (localdirective -> localmsgdirective .)
    STRING          reduce using rule 60 (localdirective -> localmsgdirective .)
    BOOL            reduce using rule 60 (localdirective -> localmsgdirective .)
    #               reduce using rule 60 (localdirective -> localmsgdirective .)
    TRACKDECISION   reduce using rule 60 (localdirective -> localmsgdirective .)
    FORGETDECISION  reduce using rule 60 (localdirective -> localmsgdirective .)
    }               reduce using rule 60 (localdirective -> localmsgdirective .)


state 72

    (59) localdirective -> localdecisiondirective .

    ID              reduce using rule 59 (localdirective -> localdecisiondirective .)
    PRINT           reduce using rule 59 (localdirective -> localdecisiondirective .)
    RETURN          reduce using rule 59 (localdirective -> localdecisiondirective .)
    INPUT           reduce using rule 59 (localdirective -> localdecisiondirective .)
    IF              reduce using rule 59 (localdirective -> localdecisiondirective .)
    WHILE           reduce using rule 59 (localdirective -> localdecisiondirective .)
    FOR             reduce using rule 59 (localdirective -> localdecisiondirective .)
    INT             reduce using rule 59 (localdirective -> localdecisiondirective .)
    FLOAT           reduce using rule 59 (localdirective -> localdecisiondirective .)
    STRING          reduce using rule 59 (localdirective -> localdecisiondirective .)
    BOOL            reduce using rule 59 (localdirective -> localdecisiondirective .)
    #               reduce using rule 59 (localdirective -> localdecisiondirective .)
    TRACKDECISION   reduce using rule 59 (localdirective -> localdecisiondirective .)
    FORGETDECISION  reduce using rule 59 (localdirective -> localdecisiondirective .)
    }               reduce using rule 59 (localdirective -> localdecisiondirective .)


state 73

    (46) instruction -> output . ;

    ;               shift and go to state 110


state 74

    (32) func -> DEF returntype ID . ( paramsOpt )

    (               shift and go to state 111


state 75

    (19) declarationB -> ID push_operand . dimensionsOpt
    (40) dimensionsOpt -> . dimensions
    (41) dimensionsOpt -> . empty
    (135) dimensions -> . [ hyperexpression ] dimensionsB
    (142) empty -> .

    [               shift and go to state 113
    =               reduce using rule 142 (empty -> .)
    ,               reduce using rule 142 (empty -> .)
    ;               reduce using rule 142 (empty -> .)

    dimensions                     shift and go to state 112
    dimensionsOpt                  shift and go to state 114
    empty                          shift and go to state 115

state 76

    (26) declarationC -> , . repush_type declarationB declarationC
    (22) repush_type -> .

    ID              reduce using rule 22 (repush_type -> .)

    repush_type                    shift and go to state 116

state 77

    (27) declarationC -> ; .

    INT             reduce using rule 27 (declarationC -> ; .)
    FLOAT           reduce using rule 27 (declarationC -> ; .)
    STRING          reduce using rule 27 (declarationC -> ; .)
    BOOL            reduce using rule 27 (declarationC -> ; .)
    DEF             reduce using rule 27 (declarationC -> ; .)
    MAIN            reduce using rule 27 (declarationC -> ; .)
    ID              reduce using rule 27 (declarationC -> ; .)
    PRINT           reduce using rule 27 (declarationC -> ; .)
    RETURN          reduce using rule 27 (declarationC -> ; .)
    INPUT           reduce using rule 27 (declarationC -> ; .)
    IF              reduce using rule 27 (declarationC -> ; .)
    WHILE           reduce using rule 27 (declarationC -> ; .)
    FOR             reduce using rule 27 (declarationC -> ; .)
    #               reduce using rule 27 (declarationC -> ; .)
    TRACKDECISION   reduce using rule 27 (declarationC -> ; .)
    FORGETDECISION  reduce using rule 27 (declarationC -> ; .)
    }               reduce using rule 27 (declarationC -> ; .)


state 78

    (18) declaration -> type push_type declarationB declarationC .

    INT             reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    FLOAT           reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    STRING          reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    BOOL            reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    DEF             reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    MAIN            reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    ID              reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    PRINT           reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    RETURN          reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    INPUT           reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    IF              reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    WHILE           reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    FOR             reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    #               reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    TRACKDECISION   reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    FORGETDECISION  reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    }               reduce using rule 18 (declaration -> type push_type declarationB declarationC .)


state 79

    (25) declarationC -> = . push_operator hyperexpression quadruple_assign declarationD
    (23) push_operator -> .

    (               reduce using rule 23 (push_operator -> .)
    ID              reduce using rule 23 (push_operator -> .)
    +               reduce using rule 23 (push_operator -> .)
    -               reduce using rule 23 (push_operator -> .)
    FCONST          reduce using rule 23 (push_operator -> .)
    ICONST          reduce using rule 23 (push_operator -> .)
    SCONST          reduce using rule 23 (push_operator -> .)
    TRUE            reduce using rule 23 (push_operator -> .)
    FALSE           reduce using rule 23 (push_operator -> .)

    push_operator                  shift and go to state 117

state 80

    (30) main -> MAIN ( ) . block
    (35) block -> . { instructionsOpt }

    {               shift and go to state 40

    block                          shift and go to state 118

state 81

    (85) factor -> signB . constant
    (98) constant -> . FCONST seen_fconst
    (99) constant -> . ICONST seen_iconst
    (100) constant -> . SCONST seen_sconst
    (101) constant -> . TRUE seen_true
    (102) constant -> . FALSE seen_false

    FCONST          shift and go to state 120
    ICONST          shift and go to state 122
    SCONST          shift and go to state 121
    TRUE            shift and go to state 124
    FALSE           shift and go to state 123

    constant                       shift and go to state 119

state 82

    (86) factor -> ( . seen_parentheses hyperexpression )
    (89) seen_parentheses -> .

    (               reduce using rule 89 (seen_parentheses -> .)
    ID              reduce using rule 89 (seen_parentheses -> .)
    +               reduce using rule 89 (seen_parentheses -> .)
    -               reduce using rule 89 (seen_parentheses -> .)
    FCONST          reduce using rule 89 (seen_parentheses -> .)
    ICONST          reduce using rule 89 (seen_parentheses -> .)
    SCONST          reduce using rule 89 (seen_parentheses -> .)
    TRUE            reduce using rule 89 (seen_parentheses -> .)
    FALSE           reduce using rule 89 (seen_parentheses -> .)

    seen_parentheses               shift and go to state 125

state 83

    (103) sign -> + .

    FCONST          reduce using rule 103 (sign -> + .)
    ICONST          reduce using rule 103 (sign -> + .)
    SCONST          reduce using rule 103 (sign -> + .)
    TRUE            reduce using rule 103 (sign -> + .)
    FALSE           reduce using rule 103 (sign -> + .)


state 84

    (104) sign -> - .

    FCONST          reduce using rule 104 (sign -> - .)
    ICONST          reduce using rule 104 (sign -> - .)
    SCONST          reduce using rule 104 (sign -> - .)
    TRUE            reduce using rule 104 (sign -> - .)
    FALSE           reduce using rule 104 (sign -> - .)


state 85

    (138) return -> RETURN hyperexpression .

    ;               reduce using rule 138 (return -> RETURN hyperexpression .)


state 86

    (80) term -> factor . seen_factor termB
    (81) seen_factor -> .

    /               reduce using rule 81 (seen_factor -> .)
    *               reduce using rule 81 (seen_factor -> .)
    -               reduce using rule 81 (seen_factor -> .)
    +               reduce using rule 81 (seen_factor -> .)
    <               reduce using rule 81 (seen_factor -> .)
    >               reduce using rule 81 (seen_factor -> .)
    DIFF            reduce using rule 81 (seen_factor -> .)
    EQ              reduce using rule 81 (seen_factor -> .)
    LTEQ            reduce using rule 81 (seen_factor -> .)
    GTEQ            reduce using rule 81 (seen_factor -> .)
    AND             reduce using rule 81 (seen_factor -> .)
    OR              reduce using rule 81 (seen_factor -> .)
    ;               reduce using rule 81 (seen_factor -> .)
    )               reduce using rule 81 (seen_factor -> .)
    ,               reduce using rule 81 (seen_factor -> .)
    ]               reduce using rule 81 (seen_factor -> .)

    seen_factor                    shift and go to state 126

state 87

    (92) signB -> empty .

    FCONST          reduce using rule 92 (signB -> empty .)
    ICONST          reduce using rule 92 (signB -> empty .)
    SCONST          reduce using rule 92 (signB -> empty .)
    TRUE            reduce using rule 92 (signB -> empty .)
    FALSE           reduce using rule 92 (signB -> empty .)


state 88

    (87) factor -> funccall .

    /               reduce using rule 87 (factor -> funccall .)
    *               reduce using rule 87 (factor -> funccall .)
    -               reduce using rule 87 (factor -> funccall .)
    +               reduce using rule 87 (factor -> funccall .)
    <               reduce using rule 87 (factor -> funccall .)
    >               reduce using rule 87 (factor -> funccall .)
    DIFF            reduce using rule 87 (factor -> funccall .)
    EQ              reduce using rule 87 (factor -> funccall .)
    LTEQ            reduce using rule 87 (factor -> funccall .)
    GTEQ            reduce using rule 87 (factor -> funccall .)
    AND             reduce using rule 87 (factor -> funccall .)
    OR              reduce using rule 87 (factor -> funccall .)
    )               reduce using rule 87 (factor -> funccall .)
    ;               reduce using rule 87 (factor -> funccall .)
    ,               reduce using rule 87 (factor -> funccall .)
    ]               reduce using rule 87 (factor -> funccall .)


state 89

    (61) hyperexpression -> superexpression . hyperexpressionB
    (62) hyperexpressionB -> . OR push_operator hyperexpression
    (63) hyperexpressionB -> . empty
    (142) empty -> .

    OR              shift and go to state 128
    ;               reduce using rule 142 (empty -> .)
    )               reduce using rule 142 (empty -> .)
    ,               reduce using rule 142 (empty -> .)
    ]               reduce using rule 142 (empty -> .)

    hyperexpressionB               shift and go to state 127
    empty                          shift and go to state 129

state 90

    (91) signB -> sign .

    FCONST          reduce using rule 91 (signB -> sign .)
    ICONST          reduce using rule 91 (signB -> sign .)
    SCONST          reduce using rule 91 (signB -> sign .)
    TRUE            reduce using rule 91 (signB -> sign .)
    FALSE           reduce using rule 91 (signB -> sign .)


state 91

    (88) factor -> ID . seen_ID dimensionsOpt
    (129) funccall -> ID . ( funccallB funccallC
    (90) seen_ID -> .

    (               shift and go to state 130
    [               reduce using rule 90 (seen_ID -> .)
    /               reduce using rule 90 (seen_ID -> .)
    *               reduce using rule 90 (seen_ID -> .)
    -               reduce using rule 90 (seen_ID -> .)
    +               reduce using rule 90 (seen_ID -> .)
    <               reduce using rule 90 (seen_ID -> .)
    >               reduce using rule 90 (seen_ID -> .)
    DIFF            reduce using rule 90 (seen_ID -> .)
    EQ              reduce using rule 90 (seen_ID -> .)
    LTEQ            reduce using rule 90 (seen_ID -> .)
    GTEQ            reduce using rule 90 (seen_ID -> .)
    AND             reduce using rule 90 (seen_ID -> .)
    OR              reduce using rule 90 (seen_ID -> .)
    ;               reduce using rule 90 (seen_ID -> .)
    )               reduce using rule 90 (seen_ID -> .)
    ,               reduce using rule 90 (seen_ID -> .)
    ]               reduce using rule 90 (seen_ID -> .)

    seen_ID                        shift and go to state 131

state 92

    (75) exp -> term . seen_term expB
    (76) seen_term -> .

    -               reduce using rule 76 (seen_term -> .)
    +               reduce using rule 76 (seen_term -> .)
    <               reduce using rule 76 (seen_term -> .)
    >               reduce using rule 76 (seen_term -> .)
    DIFF            reduce using rule 76 (seen_term -> .)
    EQ              reduce using rule 76 (seen_term -> .)
    LTEQ            reduce using rule 76 (seen_term -> .)
    GTEQ            reduce using rule 76 (seen_term -> .)
    AND             reduce using rule 76 (seen_term -> .)
    OR              reduce using rule 76 (seen_term -> .)
    ;               reduce using rule 76 (seen_term -> .)
    )               reduce using rule 76 (seen_term -> .)
    ,               reduce using rule 76 (seen_term -> .)
    ]               reduce using rule 76 (seen_term -> .)

    seen_term                      shift and go to state 132

state 93

    (67) expression -> exp . expressionB
    (68) expressionB -> . < push_operator exp
    (69) expressionB -> . > push_operator exp
    (70) expressionB -> . DIFF push_operator exp
    (71) expressionB -> . EQ push_operator exp
    (72) expressionB -> . LTEQ push_operator exp
    (73) expressionB -> . GTEQ push_operator exp
    (74) expressionB -> . empty
    (142) empty -> .

    <               shift and go to state 138
    >               shift and go to state 140
    DIFF            shift and go to state 136
    EQ              shift and go to state 137
    LTEQ            shift and go to state 134
    GTEQ            shift and go to state 133
    AND             reduce using rule 142 (empty -> .)
    OR              reduce using rule 142 (empty -> .)
    ;               reduce using rule 142 (empty -> .)
    )               reduce using rule 142 (empty -> .)
    ,               reduce using rule 142 (empty -> .)
    ]               reduce using rule 142 (empty -> .)

    empty                          shift and go to state 139
    expressionB                    shift and go to state 135

state 94

    (64) superexpression -> expression . superexpressionB
    (65) superexpressionB -> . AND push_operator superexpression
    (66) superexpressionB -> . empty
    (142) empty -> .

    AND             shift and go to state 141
    OR              reduce using rule 142 (empty -> .)
    ;               reduce using rule 142 (empty -> .)
    )               reduce using rule 142 (empty -> .)
    ,               reduce using rule 142 (empty -> .)
    ]               reduce using rule 142 (empty -> .)

    empty                          shift and go to state 143
    superexpressionB               shift and go to state 142

state 95

    (45) instruction -> assignfunccall ; .

    ID              reduce using rule 45 (instruction -> assignfunccall ; .)
    PRINT           reduce using rule 45 (instruction -> assignfunccall ; .)
    RETURN          reduce using rule 45 (instruction -> assignfunccall ; .)
    INPUT           reduce using rule 45 (instruction -> assignfunccall ; .)
    IF              reduce using rule 45 (instruction -> assignfunccall ; .)
    WHILE           reduce using rule 45 (instruction -> assignfunccall ; .)
    FOR             reduce using rule 45 (instruction -> assignfunccall ; .)
    INT             reduce using rule 45 (instruction -> assignfunccall ; .)
    FLOAT           reduce using rule 45 (instruction -> assignfunccall ; .)
    STRING          reduce using rule 45 (instruction -> assignfunccall ; .)
    BOOL            reduce using rule 45 (instruction -> assignfunccall ; .)
    #               reduce using rule 45 (instruction -> assignfunccall ; .)
    TRACKDECISION   reduce using rule 45 (instruction -> assignfunccall ; .)
    FORGETDECISION  reduce using rule 45 (instruction -> assignfunccall ; .)
    }               reduce using rule 45 (instruction -> assignfunccall ; .)


state 96

    (105) whileloop -> WHILE ( . hyperexpression ) block
    (61) hyperexpression -> . superexpression hyperexpressionB
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    sign                           shift and go to state 90
    signB                          shift and go to state 81
    hyperexpression                shift and go to state 144
    factor                         shift and go to state 86
    empty                          shift and go to state 87
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 97

    (116) output -> PRINT ( . outputB
    (117) outputB -> . SCONST push_operand print_quadruple outputC
    (118) outputB -> . hyperexpression print_quadruple outputC
    (61) hyperexpression -> . superexpression hyperexpressionB
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

  ! shift/reduce conflict for SCONST resolved as shift
    SCONST          shift and go to state 145
    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

  ! SCONST          [ reduce using rule 142 (empty -> .) ]

    signB                          shift and go to state 81
    hyperexpression                shift and go to state 146
    factor                         shift and go to state 86
    empty                          shift and go to state 87
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    sign                           shift and go to state 90
    term                           shift and go to state 92
    exp                            shift and go to state 93
    outputB                        shift and go to state 147
    expression                     shift and go to state 94

state 98

    (124) localvardirectiveB -> FORGET .

    ID              reduce using rule 124 (localvardirectiveB -> FORGET .)


state 99

    (125) localmsgdirective -> # SHOW . SCONST

    SCONST          shift and go to state 148


state 100

    (123) localvardirectiveB -> TRACK .

    ID              reduce using rule 123 (localvardirectiveB -> TRACK .)


state 101

    (122) localvardirective -> # localvardirectiveB . ID

    ID              shift and go to state 149


state 102

    (48) instruction -> input ; .

    ID              reduce using rule 48 (instruction -> input ; .)
    PRINT           reduce using rule 48 (instruction -> input ; .)
    RETURN          reduce using rule 48 (instruction -> input ; .)
    INPUT           reduce using rule 48 (instruction -> input ; .)
    IF              reduce using rule 48 (instruction -> input ; .)
    WHILE           reduce using rule 48 (instruction -> input ; .)
    FOR             reduce using rule 48 (instruction -> input ; .)
    INT             reduce using rule 48 (instruction -> input ; .)
    FLOAT           reduce using rule 48 (instruction -> input ; .)
    STRING          reduce using rule 48 (instruction -> input ; .)
    BOOL            reduce using rule 48 (instruction -> input ; .)
    #               reduce using rule 48 (instruction -> input ; .)
    TRACKDECISION   reduce using rule 48 (instruction -> input ; .)
    FORGETDECISION  reduce using rule 48 (instruction -> input ; .)
    }               reduce using rule 48 (instruction -> input ; .)


state 103

    (47) instruction -> return ; .

    ID              reduce using rule 47 (instruction -> return ; .)
    PRINT           reduce using rule 47 (instruction -> return ; .)
    RETURN          reduce using rule 47 (instruction -> return ; .)
    INPUT           reduce using rule 47 (instruction -> return ; .)
    IF              reduce using rule 47 (instruction -> return ; .)
    WHILE           reduce using rule 47 (instruction -> return ; .)
    FOR             reduce using rule 47 (instruction -> return ; .)
    INT             reduce using rule 47 (instruction -> return ; .)
    FLOAT           reduce using rule 47 (instruction -> return ; .)
    STRING          reduce using rule 47 (instruction -> return ; .)
    BOOL            reduce using rule 47 (instruction -> return ; .)
    #               reduce using rule 47 (instruction -> return ; .)
    TRACKDECISION   reduce using rule 47 (instruction -> return ; .)
    FORGETDECISION  reduce using rule 47 (instruction -> return ; .)
    }               reduce using rule 47 (instruction -> return ; .)


state 104

    (112) forloop -> FOR ( . assign ; hyperexpression ; hyperexpression ) block
    (38) assign -> . ID push_operand dimensionsOpt = push_operator hyperexpression quadruple_assign

    ID              shift and go to state 150

    assign                         shift and go to state 151

state 105

    (35) block -> { instructionsOpt } .

    DEF             reduce using rule 35 (block -> { instructionsOpt } .)
    $end            reduce using rule 35 (block -> { instructionsOpt } .)
    ID              reduce using rule 35 (block -> { instructionsOpt } .)
    PRINT           reduce using rule 35 (block -> { instructionsOpt } .)
    RETURN          reduce using rule 35 (block -> { instructionsOpt } .)
    INPUT           reduce using rule 35 (block -> { instructionsOpt } .)
    IF              reduce using rule 35 (block -> { instructionsOpt } .)
    WHILE           reduce using rule 35 (block -> { instructionsOpt } .)
    FOR             reduce using rule 35 (block -> { instructionsOpt } .)
    INT             reduce using rule 35 (block -> { instructionsOpt } .)
    FLOAT           reduce using rule 35 (block -> { instructionsOpt } .)
    STRING          reduce using rule 35 (block -> { instructionsOpt } .)
    BOOL            reduce using rule 35 (block -> { instructionsOpt } .)
    #               reduce using rule 35 (block -> { instructionsOpt } .)
    TRACKDECISION   reduce using rule 35 (block -> { instructionsOpt } .)
    FORGETDECISION  reduce using rule 35 (block -> { instructionsOpt } .)
    }               reduce using rule 35 (block -> { instructionsOpt } .)
    MAIN            reduce using rule 35 (block -> { instructionsOpt } .)
    ELSE            reduce using rule 35 (block -> { instructionsOpt } .)


state 106

    (113) input -> INPUT ( . ID inputB )

    ID              shift and go to state 152


state 107

    (54) assignfunccall -> ID push_operand . assignfunccallB
    (56) assignfunccallB -> . ( pop_operand funccallB funccallC
    (57) assignfunccallB -> . assignB
    (39) assignB -> . dimensionsOpt = push_operator hyperexpression quadruple_assign
    (40) dimensionsOpt -> . dimensions
    (41) dimensionsOpt -> . empty
    (135) dimensions -> . [ hyperexpression ] dimensionsB
    (142) empty -> .

    (               shift and go to state 154
    [               shift and go to state 113
    =               reduce using rule 142 (empty -> .)

    dimensions                     shift and go to state 112
    assignfunccallB                shift and go to state 153
    assignB                        shift and go to state 155
    dimensionsOpt                  shift and go to state 156
    empty                          shift and go to state 115

state 108

    (42) condition -> IF ( . hyperexpression ) block else
    (61) hyperexpression -> . superexpression hyperexpressionB
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    sign                           shift and go to state 90
    signB                          shift and go to state 81
    hyperexpression                shift and go to state 157
    factor                         shift and go to state 86
    empty                          shift and go to state 87
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 109

    (36) instructionsOpt -> instruction instructionsOpt .

    }               reduce using rule 36 (instructionsOpt -> instruction instructionsOpt .)


state 110

    (46) instruction -> output ; .

    ID              reduce using rule 46 (instruction -> output ; .)
    PRINT           reduce using rule 46 (instruction -> output ; .)
    RETURN          reduce using rule 46 (instruction -> output ; .)
    INPUT           reduce using rule 46 (instruction -> output ; .)
    IF              reduce using rule 46 (instruction -> output ; .)
    WHILE           reduce using rule 46 (instruction -> output ; .)
    FOR             reduce using rule 46 (instruction -> output ; .)
    INT             reduce using rule 46 (instruction -> output ; .)
    FLOAT           reduce using rule 46 (instruction -> output ; .)
    STRING          reduce using rule 46 (instruction -> output ; .)
    BOOL            reduce using rule 46 (instruction -> output ; .)
    #               reduce using rule 46 (instruction -> output ; .)
    TRACKDECISION   reduce using rule 46 (instruction -> output ; .)
    FORGETDECISION  reduce using rule 46 (instruction -> output ; .)
    }               reduce using rule 46 (instruction -> output ; .)


state 111

    (32) func -> DEF returntype ID ( . paramsOpt )
    (33) paramsOpt -> . params paramsB
    (34) paramsOpt -> . empty
    (139) params -> . type ID
    (142) empty -> .
    (106) type -> . INT
    (107) type -> . FLOAT
    (108) type -> . STRING
    (109) type -> . BOOL

    )               reduce using rule 142 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18

    paramsOpt                      shift and go to state 158
    params                         shift and go to state 159
    type                           shift and go to state 161
    empty                          shift and go to state 160

state 112

    (40) dimensionsOpt -> dimensions .

    =               reduce using rule 40 (dimensionsOpt -> dimensions .)
    /               reduce using rule 40 (dimensionsOpt -> dimensions .)
    *               reduce using rule 40 (dimensionsOpt -> dimensions .)
    -               reduce using rule 40 (dimensionsOpt -> dimensions .)
    +               reduce using rule 40 (dimensionsOpt -> dimensions .)
    <               reduce using rule 40 (dimensionsOpt -> dimensions .)
    >               reduce using rule 40 (dimensionsOpt -> dimensions .)
    DIFF            reduce using rule 40 (dimensionsOpt -> dimensions .)
    EQ              reduce using rule 40 (dimensionsOpt -> dimensions .)
    LTEQ            reduce using rule 40 (dimensionsOpt -> dimensions .)
    GTEQ            reduce using rule 40 (dimensionsOpt -> dimensions .)
    AND             reduce using rule 40 (dimensionsOpt -> dimensions .)
    OR              reduce using rule 40 (dimensionsOpt -> dimensions .)
    ;               reduce using rule 40 (dimensionsOpt -> dimensions .)
    )               reduce using rule 40 (dimensionsOpt -> dimensions .)
    ,               reduce using rule 40 (dimensionsOpt -> dimensions .)
    ]               reduce using rule 40 (dimensionsOpt -> dimensions .)


state 113

    (135) dimensions -> [ . hyperexpression ] dimensionsB
    (61) hyperexpression -> . superexpression hyperexpressionB
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    sign                           shift and go to state 90
    signB                          shift and go to state 81
    hyperexpression                shift and go to state 162
    factor                         shift and go to state 86
    empty                          shift and go to state 87
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 114

    (19) declarationB -> ID push_operand dimensionsOpt .

    =               reduce using rule 19 (declarationB -> ID push_operand dimensionsOpt .)
    ,               reduce using rule 19 (declarationB -> ID push_operand dimensionsOpt .)
    ;               reduce using rule 19 (declarationB -> ID push_operand dimensionsOpt .)


state 115

    (41) dimensionsOpt -> empty .

    =               reduce using rule 41 (dimensionsOpt -> empty .)
    /               reduce using rule 41 (dimensionsOpt -> empty .)
    *               reduce using rule 41 (dimensionsOpt -> empty .)
    -               reduce using rule 41 (dimensionsOpt -> empty .)
    +               reduce using rule 41 (dimensionsOpt -> empty .)
    <               reduce using rule 41 (dimensionsOpt -> empty .)
    >               reduce using rule 41 (dimensionsOpt -> empty .)
    DIFF            reduce using rule 41 (dimensionsOpt -> empty .)
    EQ              reduce using rule 41 (dimensionsOpt -> empty .)
    LTEQ            reduce using rule 41 (dimensionsOpt -> empty .)
    GTEQ            reduce using rule 41 (dimensionsOpt -> empty .)
    AND             reduce using rule 41 (dimensionsOpt -> empty .)
    OR              reduce using rule 41 (dimensionsOpt -> empty .)
    ;               reduce using rule 41 (dimensionsOpt -> empty .)
    )               reduce using rule 41 (dimensionsOpt -> empty .)
    ,               reduce using rule 41 (dimensionsOpt -> empty .)
    ]               reduce using rule 41 (dimensionsOpt -> empty .)


state 116

    (26) declarationC -> , repush_type . declarationB declarationC
    (19) declarationB -> . ID push_operand dimensionsOpt

    ID              shift and go to state 45

    declarationB                   shift and go to state 163

state 117

    (25) declarationC -> = push_operator . hyperexpression quadruple_assign declarationD
    (61) hyperexpression -> . superexpression hyperexpressionB
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    signB                          shift and go to state 81
    hyperexpression                shift and go to state 164
    factor                         shift and go to state 86
    empty                          shift and go to state 87
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    sign                           shift and go to state 90
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 118

    (30) main -> MAIN ( ) block .

    DEF             reduce using rule 30 (main -> MAIN ( ) block .)
    $end            reduce using rule 30 (main -> MAIN ( ) block .)


state 119

    (85) factor -> signB constant .

    /               reduce using rule 85 (factor -> signB constant .)
    *               reduce using rule 85 (factor -> signB constant .)
    -               reduce using rule 85 (factor -> signB constant .)
    +               reduce using rule 85 (factor -> signB constant .)
    <               reduce using rule 85 (factor -> signB constant .)
    >               reduce using rule 85 (factor -> signB constant .)
    DIFF            reduce using rule 85 (factor -> signB constant .)
    EQ              reduce using rule 85 (factor -> signB constant .)
    LTEQ            reduce using rule 85 (factor -> signB constant .)
    GTEQ            reduce using rule 85 (factor -> signB constant .)
    AND             reduce using rule 85 (factor -> signB constant .)
    OR              reduce using rule 85 (factor -> signB constant .)
    )               reduce using rule 85 (factor -> signB constant .)
    ;               reduce using rule 85 (factor -> signB constant .)
    ,               reduce using rule 85 (factor -> signB constant .)
    ]               reduce using rule 85 (factor -> signB constant .)


state 120

    (98) constant -> FCONST . seen_fconst
    (93) seen_fconst -> .

    /               reduce using rule 93 (seen_fconst -> .)
    *               reduce using rule 93 (seen_fconst -> .)
    -               reduce using rule 93 (seen_fconst -> .)
    +               reduce using rule 93 (seen_fconst -> .)
    <               reduce using rule 93 (seen_fconst -> .)
    >               reduce using rule 93 (seen_fconst -> .)
    DIFF            reduce using rule 93 (seen_fconst -> .)
    EQ              reduce using rule 93 (seen_fconst -> .)
    LTEQ            reduce using rule 93 (seen_fconst -> .)
    GTEQ            reduce using rule 93 (seen_fconst -> .)
    AND             reduce using rule 93 (seen_fconst -> .)
    OR              reduce using rule 93 (seen_fconst -> .)
    ;               reduce using rule 93 (seen_fconst -> .)
    )               reduce using rule 93 (seen_fconst -> .)
    ,               reduce using rule 93 (seen_fconst -> .)
    ]               reduce using rule 93 (seen_fconst -> .)

    seen_fconst                    shift and go to state 165

state 121

    (100) constant -> SCONST . seen_sconst
    (95) seen_sconst -> .

    /               reduce using rule 95 (seen_sconst -> .)
    *               reduce using rule 95 (seen_sconst -> .)
    -               reduce using rule 95 (seen_sconst -> .)
    +               reduce using rule 95 (seen_sconst -> .)
    <               reduce using rule 95 (seen_sconst -> .)
    >               reduce using rule 95 (seen_sconst -> .)
    DIFF            reduce using rule 95 (seen_sconst -> .)
    EQ              reduce using rule 95 (seen_sconst -> .)
    LTEQ            reduce using rule 95 (seen_sconst -> .)
    GTEQ            reduce using rule 95 (seen_sconst -> .)
    AND             reduce using rule 95 (seen_sconst -> .)
    OR              reduce using rule 95 (seen_sconst -> .)
    ;               reduce using rule 95 (seen_sconst -> .)
    )               reduce using rule 95 (seen_sconst -> .)
    ,               reduce using rule 95 (seen_sconst -> .)
    ]               reduce using rule 95 (seen_sconst -> .)

    seen_sconst                    shift and go to state 166

state 122

    (99) constant -> ICONST . seen_iconst
    (94) seen_iconst -> .

    /               reduce using rule 94 (seen_iconst -> .)
    *               reduce using rule 94 (seen_iconst -> .)
    -               reduce using rule 94 (seen_iconst -> .)
    +               reduce using rule 94 (seen_iconst -> .)
    <               reduce using rule 94 (seen_iconst -> .)
    >               reduce using rule 94 (seen_iconst -> .)
    DIFF            reduce using rule 94 (seen_iconst -> .)
    EQ              reduce using rule 94 (seen_iconst -> .)
    LTEQ            reduce using rule 94 (seen_iconst -> .)
    GTEQ            reduce using rule 94 (seen_iconst -> .)
    AND             reduce using rule 94 (seen_iconst -> .)
    OR              reduce using rule 94 (seen_iconst -> .)
    ;               reduce using rule 94 (seen_iconst -> .)
    )               reduce using rule 94 (seen_iconst -> .)
    ,               reduce using rule 94 (seen_iconst -> .)
    ]               reduce using rule 94 (seen_iconst -> .)

    seen_iconst                    shift and go to state 167

state 123

    (102) constant -> FALSE . seen_false
    (97) seen_false -> .

    /               reduce using rule 97 (seen_false -> .)
    *               reduce using rule 97 (seen_false -> .)
    -               reduce using rule 97 (seen_false -> .)
    +               reduce using rule 97 (seen_false -> .)
    <               reduce using rule 97 (seen_false -> .)
    >               reduce using rule 97 (seen_false -> .)
    DIFF            reduce using rule 97 (seen_false -> .)
    EQ              reduce using rule 97 (seen_false -> .)
    LTEQ            reduce using rule 97 (seen_false -> .)
    GTEQ            reduce using rule 97 (seen_false -> .)
    AND             reduce using rule 97 (seen_false -> .)
    OR              reduce using rule 97 (seen_false -> .)
    ;               reduce using rule 97 (seen_false -> .)
    )               reduce using rule 97 (seen_false -> .)
    ,               reduce using rule 97 (seen_false -> .)
    ]               reduce using rule 97 (seen_false -> .)

    seen_false                     shift and go to state 168

state 124

    (101) constant -> TRUE . seen_true
    (96) seen_true -> .

    /               reduce using rule 96 (seen_true -> .)
    *               reduce using rule 96 (seen_true -> .)
    -               reduce using rule 96 (seen_true -> .)
    +               reduce using rule 96 (seen_true -> .)
    <               reduce using rule 96 (seen_true -> .)
    >               reduce using rule 96 (seen_true -> .)
    DIFF            reduce using rule 96 (seen_true -> .)
    EQ              reduce using rule 96 (seen_true -> .)
    LTEQ            reduce using rule 96 (seen_true -> .)
    GTEQ            reduce using rule 96 (seen_true -> .)
    AND             reduce using rule 96 (seen_true -> .)
    OR              reduce using rule 96 (seen_true -> .)
    ;               reduce using rule 96 (seen_true -> .)
    )               reduce using rule 96 (seen_true -> .)
    ,               reduce using rule 96 (seen_true -> .)
    ]               reduce using rule 96 (seen_true -> .)

    seen_true                      shift and go to state 169

state 125

    (86) factor -> ( seen_parentheses . hyperexpression )
    (61) hyperexpression -> . superexpression hyperexpressionB
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    sign                           shift and go to state 90
    signB                          shift and go to state 81
    hyperexpression                shift and go to state 170
    factor                         shift and go to state 86
    empty                          shift and go to state 87
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 126

    (80) term -> factor seen_factor . termB
    (82) termB -> . / push_operator term
    (83) termB -> . * push_operator term
    (84) termB -> . empty
    (142) empty -> .

    /               shift and go to state 174
    *               shift and go to state 171
    -               reduce using rule 142 (empty -> .)
    +               reduce using rule 142 (empty -> .)
    <               reduce using rule 142 (empty -> .)
    >               reduce using rule 142 (empty -> .)
    DIFF            reduce using rule 142 (empty -> .)
    EQ              reduce using rule 142 (empty -> .)
    LTEQ            reduce using rule 142 (empty -> .)
    GTEQ            reduce using rule 142 (empty -> .)
    AND             reduce using rule 142 (empty -> .)
    OR              reduce using rule 142 (empty -> .)
    ;               reduce using rule 142 (empty -> .)
    )               reduce using rule 142 (empty -> .)
    ,               reduce using rule 142 (empty -> .)
    ]               reduce using rule 142 (empty -> .)

    termB                          shift and go to state 172
    empty                          shift and go to state 173

state 127

    (61) hyperexpression -> superexpression hyperexpressionB .

    )               reduce using rule 61 (hyperexpression -> superexpression hyperexpressionB .)
    ;               reduce using rule 61 (hyperexpression -> superexpression hyperexpressionB .)
    ]               reduce using rule 61 (hyperexpression -> superexpression hyperexpressionB .)
    ,               reduce using rule 61 (hyperexpression -> superexpression hyperexpressionB .)


state 128

    (62) hyperexpressionB -> OR . push_operator hyperexpression
    (23) push_operator -> .

    (               reduce using rule 23 (push_operator -> .)
    ID              reduce using rule 23 (push_operator -> .)
    +               reduce using rule 23 (push_operator -> .)
    -               reduce using rule 23 (push_operator -> .)
    FCONST          reduce using rule 23 (push_operator -> .)
    ICONST          reduce using rule 23 (push_operator -> .)
    SCONST          reduce using rule 23 (push_operator -> .)
    TRUE            reduce using rule 23 (push_operator -> .)
    FALSE           reduce using rule 23 (push_operator -> .)

    push_operator                  shift and go to state 175

state 129

    (63) hyperexpressionB -> empty .

    ;               reduce using rule 63 (hyperexpressionB -> empty .)
    )               reduce using rule 63 (hyperexpressionB -> empty .)
    ,               reduce using rule 63 (hyperexpressionB -> empty .)
    ]               reduce using rule 63 (hyperexpressionB -> empty .)


state 130

    (129) funccall -> ID ( . funccallB funccallC
    (130) funccallB -> . hyperexpression seen_param
    (131) funccallB -> . empty
    (61) hyperexpression -> . superexpression hyperexpressionB
    (142) empty -> .
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -

    ,               reduce using rule 142 (empty -> .)
    )               reduce using rule 142 (empty -> .)
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)
    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84

    funccallB                      shift and go to state 176
    signB                          shift and go to state 81
    hyperexpression                shift and go to state 177
    factor                         shift and go to state 86
    empty                          shift and go to state 178
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    sign                           shift and go to state 90
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 131

    (88) factor -> ID seen_ID . dimensionsOpt
    (40) dimensionsOpt -> . dimensions
    (41) dimensionsOpt -> . empty
    (135) dimensions -> . [ hyperexpression ] dimensionsB
    (142) empty -> .

    [               shift and go to state 113
    /               reduce using rule 142 (empty -> .)
    *               reduce using rule 142 (empty -> .)
    -               reduce using rule 142 (empty -> .)
    +               reduce using rule 142 (empty -> .)
    <               reduce using rule 142 (empty -> .)
    >               reduce using rule 142 (empty -> .)
    DIFF            reduce using rule 142 (empty -> .)
    EQ              reduce using rule 142 (empty -> .)
    LTEQ            reduce using rule 142 (empty -> .)
    GTEQ            reduce using rule 142 (empty -> .)
    AND             reduce using rule 142 (empty -> .)
    OR              reduce using rule 142 (empty -> .)
    ;               reduce using rule 142 (empty -> .)
    )               reduce using rule 142 (empty -> .)
    ,               reduce using rule 142 (empty -> .)
    ]               reduce using rule 142 (empty -> .)

    dimensions                     shift and go to state 112
    dimensionsOpt                  shift and go to state 179
    empty                          shift and go to state 115

state 132

    (75) exp -> term seen_term . expB
    (77) expB -> . - push_operator exp
    (78) expB -> . + push_operator exp
    (79) expB -> . empty
    (142) empty -> .

    -               shift and go to state 181
    +               shift and go to state 180
    <               reduce using rule 142 (empty -> .)
    >               reduce using rule 142 (empty -> .)
    DIFF            reduce using rule 142 (empty -> .)
    EQ              reduce using rule 142 (empty -> .)
    LTEQ            reduce using rule 142 (empty -> .)
    GTEQ            reduce using rule 142 (empty -> .)
    AND             reduce using rule 142 (empty -> .)
    OR              reduce using rule 142 (empty -> .)
    ;               reduce using rule 142 (empty -> .)
    )               reduce using rule 142 (empty -> .)
    ,               reduce using rule 142 (empty -> .)
    ]               reduce using rule 142 (empty -> .)

    expB                           shift and go to state 182
    empty                          shift and go to state 183

state 133

    (73) expressionB -> GTEQ . push_operator exp
    (23) push_operator -> .

    (               reduce using rule 23 (push_operator -> .)
    ID              reduce using rule 23 (push_operator -> .)
    +               reduce using rule 23 (push_operator -> .)
    -               reduce using rule 23 (push_operator -> .)
    FCONST          reduce using rule 23 (push_operator -> .)
    ICONST          reduce using rule 23 (push_operator -> .)
    SCONST          reduce using rule 23 (push_operator -> .)
    TRUE            reduce using rule 23 (push_operator -> .)
    FALSE           reduce using rule 23 (push_operator -> .)

    push_operator                  shift and go to state 184

state 134

    (72) expressionB -> LTEQ . push_operator exp
    (23) push_operator -> .

    (               reduce using rule 23 (push_operator -> .)
    ID              reduce using rule 23 (push_operator -> .)
    +               reduce using rule 23 (push_operator -> .)
    -               reduce using rule 23 (push_operator -> .)
    FCONST          reduce using rule 23 (push_operator -> .)
    ICONST          reduce using rule 23 (push_operator -> .)
    SCONST          reduce using rule 23 (push_operator -> .)
    TRUE            reduce using rule 23 (push_operator -> .)
    FALSE           reduce using rule 23 (push_operator -> .)

    push_operator                  shift and go to state 185

state 135

    (67) expression -> exp expressionB .

    AND             reduce using rule 67 (expression -> exp expressionB .)
    OR              reduce using rule 67 (expression -> exp expressionB .)
    ;               reduce using rule 67 (expression -> exp expressionB .)
    ,               reduce using rule 67 (expression -> exp expressionB .)
    )               reduce using rule 67 (expression -> exp expressionB .)
    ]               reduce using rule 67 (expression -> exp expressionB .)


state 136

    (70) expressionB -> DIFF . push_operator exp
    (23) push_operator -> .

    (               reduce using rule 23 (push_operator -> .)
    ID              reduce using rule 23 (push_operator -> .)
    +               reduce using rule 23 (push_operator -> .)
    -               reduce using rule 23 (push_operator -> .)
    FCONST          reduce using rule 23 (push_operator -> .)
    ICONST          reduce using rule 23 (push_operator -> .)
    SCONST          reduce using rule 23 (push_operator -> .)
    TRUE            reduce using rule 23 (push_operator -> .)
    FALSE           reduce using rule 23 (push_operator -> .)

    push_operator                  shift and go to state 186

state 137

    (71) expressionB -> EQ . push_operator exp
    (23) push_operator -> .

    (               reduce using rule 23 (push_operator -> .)
    ID              reduce using rule 23 (push_operator -> .)
    +               reduce using rule 23 (push_operator -> .)
    -               reduce using rule 23 (push_operator -> .)
    FCONST          reduce using rule 23 (push_operator -> .)
    ICONST          reduce using rule 23 (push_operator -> .)
    SCONST          reduce using rule 23 (push_operator -> .)
    TRUE            reduce using rule 23 (push_operator -> .)
    FALSE           reduce using rule 23 (push_operator -> .)

    push_operator                  shift and go to state 187

state 138

    (68) expressionB -> < . push_operator exp
    (23) push_operator -> .

    (               reduce using rule 23 (push_operator -> .)
    ID              reduce using rule 23 (push_operator -> .)
    +               reduce using rule 23 (push_operator -> .)
    -               reduce using rule 23 (push_operator -> .)
    FCONST          reduce using rule 23 (push_operator -> .)
    ICONST          reduce using rule 23 (push_operator -> .)
    SCONST          reduce using rule 23 (push_operator -> .)
    TRUE            reduce using rule 23 (push_operator -> .)
    FALSE           reduce using rule 23 (push_operator -> .)

    push_operator                  shift and go to state 188

state 139

    (74) expressionB -> empty .

    AND             reduce using rule 74 (expressionB -> empty .)
    OR              reduce using rule 74 (expressionB -> empty .)
    ;               reduce using rule 74 (expressionB -> empty .)
    )               reduce using rule 74 (expressionB -> empty .)
    ,               reduce using rule 74 (expressionB -> empty .)
    ]               reduce using rule 74 (expressionB -> empty .)


state 140

    (69) expressionB -> > . push_operator exp
    (23) push_operator -> .

    (               reduce using rule 23 (push_operator -> .)
    ID              reduce using rule 23 (push_operator -> .)
    +               reduce using rule 23 (push_operator -> .)
    -               reduce using rule 23 (push_operator -> .)
    FCONST          reduce using rule 23 (push_operator -> .)
    ICONST          reduce using rule 23 (push_operator -> .)
    SCONST          reduce using rule 23 (push_operator -> .)
    TRUE            reduce using rule 23 (push_operator -> .)
    FALSE           reduce using rule 23 (push_operator -> .)

    push_operator                  shift and go to state 189

state 141

    (65) superexpressionB -> AND . push_operator superexpression
    (23) push_operator -> .

    (               reduce using rule 23 (push_operator -> .)
    ID              reduce using rule 23 (push_operator -> .)
    +               reduce using rule 23 (push_operator -> .)
    -               reduce using rule 23 (push_operator -> .)
    FCONST          reduce using rule 23 (push_operator -> .)
    ICONST          reduce using rule 23 (push_operator -> .)
    SCONST          reduce using rule 23 (push_operator -> .)
    TRUE            reduce using rule 23 (push_operator -> .)
    FALSE           reduce using rule 23 (push_operator -> .)

    push_operator                  shift and go to state 190

state 142

    (64) superexpression -> expression superexpressionB .

    OR              reduce using rule 64 (superexpression -> expression superexpressionB .)
    )               reduce using rule 64 (superexpression -> expression superexpressionB .)
    ;               reduce using rule 64 (superexpression -> expression superexpressionB .)
    ,               reduce using rule 64 (superexpression -> expression superexpressionB .)
    ]               reduce using rule 64 (superexpression -> expression superexpressionB .)


state 143

    (66) superexpressionB -> empty .

    OR              reduce using rule 66 (superexpressionB -> empty .)
    ;               reduce using rule 66 (superexpressionB -> empty .)
    )               reduce using rule 66 (superexpressionB -> empty .)
    ,               reduce using rule 66 (superexpressionB -> empty .)
    ]               reduce using rule 66 (superexpressionB -> empty .)


state 144

    (105) whileloop -> WHILE ( hyperexpression . ) block

    )               shift and go to state 191


state 145

    (117) outputB -> SCONST . push_operand print_quadruple outputC
    (20) push_operand -> .

    )               reduce using rule 20 (push_operand -> .)
    ,               reduce using rule 20 (push_operand -> .)

    push_operand                   shift and go to state 192

state 146

    (118) outputB -> hyperexpression . print_quadruple outputC
    (119) print_quadruple -> .

    )               reduce using rule 119 (print_quadruple -> .)
    ,               reduce using rule 119 (print_quadruple -> .)

    print_quadruple                shift and go to state 193

state 147

    (116) output -> PRINT ( outputB .

    ;               reduce using rule 116 (output -> PRINT ( outputB .)


state 148

    (125) localmsgdirective -> # SHOW SCONST .

    ID              reduce using rule 125 (localmsgdirective -> # SHOW SCONST .)
    PRINT           reduce using rule 125 (localmsgdirective -> # SHOW SCONST .)
    RETURN          reduce using rule 125 (localmsgdirective -> # SHOW SCONST .)
    INPUT           reduce using rule 125 (localmsgdirective -> # SHOW SCONST .)
    IF              reduce using rule 125 (localmsgdirective -> # SHOW SCONST .)
    WHILE           reduce using rule 125 (localmsgdirective -> # SHOW SCONST .)
    FOR             reduce using rule 125 (localmsgdirective -> # SHOW SCONST .)
    INT             reduce using rule 125 (localmsgdirective -> # SHOW SCONST .)
    FLOAT           reduce using rule 125 (localmsgdirective -> # SHOW SCONST .)
    STRING          reduce using rule 125 (localmsgdirective -> # SHOW SCONST .)
    BOOL            reduce using rule 125 (localmsgdirective -> # SHOW SCONST .)
    #               reduce using rule 125 (localmsgdirective -> # SHOW SCONST .)
    TRACKDECISION   reduce using rule 125 (localmsgdirective -> # SHOW SCONST .)
    FORGETDECISION  reduce using rule 125 (localmsgdirective -> # SHOW SCONST .)
    }               reduce using rule 125 (localmsgdirective -> # SHOW SCONST .)


state 149

    (122) localvardirective -> # localvardirectiveB ID .

    ID              reduce using rule 122 (localvardirective -> # localvardirectiveB ID .)
    PRINT           reduce using rule 122 (localvardirective -> # localvardirectiveB ID .)
    RETURN          reduce using rule 122 (localvardirective -> # localvardirectiveB ID .)
    INPUT           reduce using rule 122 (localvardirective -> # localvardirectiveB ID .)
    IF              reduce using rule 122 (localvardirective -> # localvardirectiveB ID .)
    WHILE           reduce using rule 122 (localvardirective -> # localvardirectiveB ID .)
    FOR             reduce using rule 122 (localvardirective -> # localvardirectiveB ID .)
    INT             reduce using rule 122 (localvardirective -> # localvardirectiveB ID .)
    FLOAT           reduce using rule 122 (localvardirective -> # localvardirectiveB ID .)
    STRING          reduce using rule 122 (localvardirective -> # localvardirectiveB ID .)
    BOOL            reduce using rule 122 (localvardirective -> # localvardirectiveB ID .)
    #               reduce using rule 122 (localvardirective -> # localvardirectiveB ID .)
    TRACKDECISION   reduce using rule 122 (localvardirective -> # localvardirectiveB ID .)
    FORGETDECISION  reduce using rule 122 (localvardirective -> # localvardirectiveB ID .)
    }               reduce using rule 122 (localvardirective -> # localvardirectiveB ID .)


state 150

    (38) assign -> ID . push_operand dimensionsOpt = push_operator hyperexpression quadruple_assign
    (20) push_operand -> .

    [               reduce using rule 20 (push_operand -> .)
    =               reduce using rule 20 (push_operand -> .)

    push_operand                   shift and go to state 194

state 151

    (112) forloop -> FOR ( assign . ; hyperexpression ; hyperexpression ) block

    ;               shift and go to state 195


state 152

    (113) input -> INPUT ( ID . inputB )
    (114) inputB -> . , ID inputB
    (115) inputB -> . empty
    (142) empty -> .

    ,               shift and go to state 196
    )               reduce using rule 142 (empty -> .)

    inputB                         shift and go to state 197
    empty                          shift and go to state 198

state 153

    (54) assignfunccall -> ID push_operand assignfunccallB .

    ;               reduce using rule 54 (assignfunccall -> ID push_operand assignfunccallB .)


state 154

    (56) assignfunccallB -> ( . pop_operand funccallB funccallC
    (55) pop_operand -> .

    (               reduce using rule 55 (pop_operand -> .)
    ID              reduce using rule 55 (pop_operand -> .)
    +               reduce using rule 55 (pop_operand -> .)
    -               reduce using rule 55 (pop_operand -> .)
    ,               reduce using rule 55 (pop_operand -> .)
    )               reduce using rule 55 (pop_operand -> .)
    FCONST          reduce using rule 55 (pop_operand -> .)
    ICONST          reduce using rule 55 (pop_operand -> .)
    SCONST          reduce using rule 55 (pop_operand -> .)
    TRUE            reduce using rule 55 (pop_operand -> .)
    FALSE           reduce using rule 55 (pop_operand -> .)

    pop_operand                    shift and go to state 199

state 155

    (57) assignfunccallB -> assignB .

    ;               reduce using rule 57 (assignfunccallB -> assignB .)


state 156

    (39) assignB -> dimensionsOpt . = push_operator hyperexpression quadruple_assign

    =               shift and go to state 200


state 157

    (42) condition -> IF ( hyperexpression . ) block else

    )               shift and go to state 201


state 158

    (32) func -> DEF returntype ID ( paramsOpt . )

    )               shift and go to state 202


state 159

    (33) paramsOpt -> params . paramsB
    (140) paramsB -> . , params paramsB
    (141) paramsB -> . empty
    (142) empty -> .

    ,               shift and go to state 204
    )               reduce using rule 142 (empty -> .)

    paramsB                        shift and go to state 203
    empty                          shift and go to state 205

state 160

    (34) paramsOpt -> empty .

    )               reduce using rule 34 (paramsOpt -> empty .)


state 161

    (139) params -> type . ID

    ID              shift and go to state 206


state 162

    (135) dimensions -> [ hyperexpression . ] dimensionsB

    ]               shift and go to state 207


state 163

    (26) declarationC -> , repush_type declarationB . declarationC
    (25) declarationC -> . = push_operator hyperexpression quadruple_assign declarationD
    (26) declarationC -> . , repush_type declarationB declarationC
    (27) declarationC -> . ;

    =               shift and go to state 79
    ,               shift and go to state 76
    ;               shift and go to state 77

    declarationC                   shift and go to state 208

state 164

    (25) declarationC -> = push_operator hyperexpression . quadruple_assign declarationD
    (24) quadruple_assign -> .

    ,               reduce using rule 24 (quadruple_assign -> .)
    ;               reduce using rule 24 (quadruple_assign -> .)

    quadruple_assign               shift and go to state 209

state 165

    (98) constant -> FCONST seen_fconst .

    /               reduce using rule 98 (constant -> FCONST seen_fconst .)
    *               reduce using rule 98 (constant -> FCONST seen_fconst .)
    -               reduce using rule 98 (constant -> FCONST seen_fconst .)
    +               reduce using rule 98 (constant -> FCONST seen_fconst .)
    <               reduce using rule 98 (constant -> FCONST seen_fconst .)
    >               reduce using rule 98 (constant -> FCONST seen_fconst .)
    DIFF            reduce using rule 98 (constant -> FCONST seen_fconst .)
    EQ              reduce using rule 98 (constant -> FCONST seen_fconst .)
    LTEQ            reduce using rule 98 (constant -> FCONST seen_fconst .)
    GTEQ            reduce using rule 98 (constant -> FCONST seen_fconst .)
    AND             reduce using rule 98 (constant -> FCONST seen_fconst .)
    OR              reduce using rule 98 (constant -> FCONST seen_fconst .)
    ;               reduce using rule 98 (constant -> FCONST seen_fconst .)
    )               reduce using rule 98 (constant -> FCONST seen_fconst .)
    ,               reduce using rule 98 (constant -> FCONST seen_fconst .)
    ]               reduce using rule 98 (constant -> FCONST seen_fconst .)


state 166

    (100) constant -> SCONST seen_sconst .

    /               reduce using rule 100 (constant -> SCONST seen_sconst .)
    *               reduce using rule 100 (constant -> SCONST seen_sconst .)
    -               reduce using rule 100 (constant -> SCONST seen_sconst .)
    +               reduce using rule 100 (constant -> SCONST seen_sconst .)
    <               reduce using rule 100 (constant -> SCONST seen_sconst .)
    >               reduce using rule 100 (constant -> SCONST seen_sconst .)
    DIFF            reduce using rule 100 (constant -> SCONST seen_sconst .)
    EQ              reduce using rule 100 (constant -> SCONST seen_sconst .)
    LTEQ            reduce using rule 100 (constant -> SCONST seen_sconst .)
    GTEQ            reduce using rule 100 (constant -> SCONST seen_sconst .)
    AND             reduce using rule 100 (constant -> SCONST seen_sconst .)
    OR              reduce using rule 100 (constant -> SCONST seen_sconst .)
    ;               reduce using rule 100 (constant -> SCONST seen_sconst .)
    )               reduce using rule 100 (constant -> SCONST seen_sconst .)
    ,               reduce using rule 100 (constant -> SCONST seen_sconst .)
    ]               reduce using rule 100 (constant -> SCONST seen_sconst .)


state 167

    (99) constant -> ICONST seen_iconst .

    /               reduce using rule 99 (constant -> ICONST seen_iconst .)
    *               reduce using rule 99 (constant -> ICONST seen_iconst .)
    -               reduce using rule 99 (constant -> ICONST seen_iconst .)
    +               reduce using rule 99 (constant -> ICONST seen_iconst .)
    <               reduce using rule 99 (constant -> ICONST seen_iconst .)
    >               reduce using rule 99 (constant -> ICONST seen_iconst .)
    DIFF            reduce using rule 99 (constant -> ICONST seen_iconst .)
    EQ              reduce using rule 99 (constant -> ICONST seen_iconst .)
    LTEQ            reduce using rule 99 (constant -> ICONST seen_iconst .)
    GTEQ            reduce using rule 99 (constant -> ICONST seen_iconst .)
    AND             reduce using rule 99 (constant -> ICONST seen_iconst .)
    OR              reduce using rule 99 (constant -> ICONST seen_iconst .)
    ;               reduce using rule 99 (constant -> ICONST seen_iconst .)
    )               reduce using rule 99 (constant -> ICONST seen_iconst .)
    ,               reduce using rule 99 (constant -> ICONST seen_iconst .)
    ]               reduce using rule 99 (constant -> ICONST seen_iconst .)


state 168

    (102) constant -> FALSE seen_false .

    /               reduce using rule 102 (constant -> FALSE seen_false .)
    *               reduce using rule 102 (constant -> FALSE seen_false .)
    -               reduce using rule 102 (constant -> FALSE seen_false .)
    +               reduce using rule 102 (constant -> FALSE seen_false .)
    <               reduce using rule 102 (constant -> FALSE seen_false .)
    >               reduce using rule 102 (constant -> FALSE seen_false .)
    DIFF            reduce using rule 102 (constant -> FALSE seen_false .)
    EQ              reduce using rule 102 (constant -> FALSE seen_false .)
    LTEQ            reduce using rule 102 (constant -> FALSE seen_false .)
    GTEQ            reduce using rule 102 (constant -> FALSE seen_false .)
    AND             reduce using rule 102 (constant -> FALSE seen_false .)
    OR              reduce using rule 102 (constant -> FALSE seen_false .)
    ;               reduce using rule 102 (constant -> FALSE seen_false .)
    )               reduce using rule 102 (constant -> FALSE seen_false .)
    ,               reduce using rule 102 (constant -> FALSE seen_false .)
    ]               reduce using rule 102 (constant -> FALSE seen_false .)


state 169

    (101) constant -> TRUE seen_true .

    /               reduce using rule 101 (constant -> TRUE seen_true .)
    *               reduce using rule 101 (constant -> TRUE seen_true .)
    -               reduce using rule 101 (constant -> TRUE seen_true .)
    +               reduce using rule 101 (constant -> TRUE seen_true .)
    <               reduce using rule 101 (constant -> TRUE seen_true .)
    >               reduce using rule 101 (constant -> TRUE seen_true .)
    DIFF            reduce using rule 101 (constant -> TRUE seen_true .)
    EQ              reduce using rule 101 (constant -> TRUE seen_true .)
    LTEQ            reduce using rule 101 (constant -> TRUE seen_true .)
    GTEQ            reduce using rule 101 (constant -> TRUE seen_true .)
    AND             reduce using rule 101 (constant -> TRUE seen_true .)
    OR              reduce using rule 101 (constant -> TRUE seen_true .)
    ;               reduce using rule 101 (constant -> TRUE seen_true .)
    )               reduce using rule 101 (constant -> TRUE seen_true .)
    ,               reduce using rule 101 (constant -> TRUE seen_true .)
    ]               reduce using rule 101 (constant -> TRUE seen_true .)


state 170

    (86) factor -> ( seen_parentheses hyperexpression . )

    )               shift and go to state 210


state 171

    (83) termB -> * . push_operator term
    (23) push_operator -> .

    (               reduce using rule 23 (push_operator -> .)
    ID              reduce using rule 23 (push_operator -> .)
    +               reduce using rule 23 (push_operator -> .)
    -               reduce using rule 23 (push_operator -> .)
    FCONST          reduce using rule 23 (push_operator -> .)
    ICONST          reduce using rule 23 (push_operator -> .)
    SCONST          reduce using rule 23 (push_operator -> .)
    TRUE            reduce using rule 23 (push_operator -> .)
    FALSE           reduce using rule 23 (push_operator -> .)

    push_operator                  shift and go to state 211

state 172

    (80) term -> factor seen_factor termB .

    -               reduce using rule 80 (term -> factor seen_factor termB .)
    +               reduce using rule 80 (term -> factor seen_factor termB .)
    <               reduce using rule 80 (term -> factor seen_factor termB .)
    >               reduce using rule 80 (term -> factor seen_factor termB .)
    DIFF            reduce using rule 80 (term -> factor seen_factor termB .)
    EQ              reduce using rule 80 (term -> factor seen_factor termB .)
    LTEQ            reduce using rule 80 (term -> factor seen_factor termB .)
    GTEQ            reduce using rule 80 (term -> factor seen_factor termB .)
    AND             reduce using rule 80 (term -> factor seen_factor termB .)
    OR              reduce using rule 80 (term -> factor seen_factor termB .)
    )               reduce using rule 80 (term -> factor seen_factor termB .)
    ,               reduce using rule 80 (term -> factor seen_factor termB .)
    ;               reduce using rule 80 (term -> factor seen_factor termB .)
    ]               reduce using rule 80 (term -> factor seen_factor termB .)


state 173

    (84) termB -> empty .

    -               reduce using rule 84 (termB -> empty .)
    +               reduce using rule 84 (termB -> empty .)
    <               reduce using rule 84 (termB -> empty .)
    >               reduce using rule 84 (termB -> empty .)
    DIFF            reduce using rule 84 (termB -> empty .)
    EQ              reduce using rule 84 (termB -> empty .)
    LTEQ            reduce using rule 84 (termB -> empty .)
    GTEQ            reduce using rule 84 (termB -> empty .)
    AND             reduce using rule 84 (termB -> empty .)
    OR              reduce using rule 84 (termB -> empty .)
    ;               reduce using rule 84 (termB -> empty .)
    )               reduce using rule 84 (termB -> empty .)
    ,               reduce using rule 84 (termB -> empty .)
    ]               reduce using rule 84 (termB -> empty .)


state 174

    (82) termB -> / . push_operator term
    (23) push_operator -> .

    (               reduce using rule 23 (push_operator -> .)
    ID              reduce using rule 23 (push_operator -> .)
    +               reduce using rule 23 (push_operator -> .)
    -               reduce using rule 23 (push_operator -> .)
    FCONST          reduce using rule 23 (push_operator -> .)
    ICONST          reduce using rule 23 (push_operator -> .)
    SCONST          reduce using rule 23 (push_operator -> .)
    TRUE            reduce using rule 23 (push_operator -> .)
    FALSE           reduce using rule 23 (push_operator -> .)

    push_operator                  shift and go to state 212

state 175

    (62) hyperexpressionB -> OR push_operator . hyperexpression
    (61) hyperexpression -> . superexpression hyperexpressionB
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    sign                           shift and go to state 90
    signB                          shift and go to state 81
    hyperexpression                shift and go to state 213
    factor                         shift and go to state 86
    empty                          shift and go to state 87
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 176

    (129) funccall -> ID ( funccallB . funccallC
    (133) funccallC -> . , funccallB funccallC
    (134) funccallC -> . )

    ,               shift and go to state 216
    )               shift and go to state 215

    funccallC                      shift and go to state 214

state 177

    (130) funccallB -> hyperexpression . seen_param
    (132) seen_param -> .

    ,               reduce using rule 132 (seen_param -> .)
    )               reduce using rule 132 (seen_param -> .)

    seen_param                     shift and go to state 217

state 178

    (131) funccallB -> empty .
    (92) signB -> empty .

    ,               reduce using rule 131 (funccallB -> empty .)
    )               reduce using rule 131 (funccallB -> empty .)
    FCONST          reduce using rule 92 (signB -> empty .)
    ICONST          reduce using rule 92 (signB -> empty .)
    SCONST          reduce using rule 92 (signB -> empty .)
    TRUE            reduce using rule 92 (signB -> empty .)
    FALSE           reduce using rule 92 (signB -> empty .)


state 179

    (88) factor -> ID seen_ID dimensionsOpt .

    /               reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)
    *               reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)
    -               reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)
    +               reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)
    <               reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)
    >               reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)
    DIFF            reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)
    EQ              reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)
    LTEQ            reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)
    GTEQ            reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)
    AND             reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)
    OR              reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)
    )               reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)
    ;               reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)
    ,               reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)
    ]               reduce using rule 88 (factor -> ID seen_ID dimensionsOpt .)


state 180

    (78) expB -> + . push_operator exp
    (23) push_operator -> .

    (               reduce using rule 23 (push_operator -> .)
    ID              reduce using rule 23 (push_operator -> .)
    +               reduce using rule 23 (push_operator -> .)
    -               reduce using rule 23 (push_operator -> .)
    FCONST          reduce using rule 23 (push_operator -> .)
    ICONST          reduce using rule 23 (push_operator -> .)
    SCONST          reduce using rule 23 (push_operator -> .)
    TRUE            reduce using rule 23 (push_operator -> .)
    FALSE           reduce using rule 23 (push_operator -> .)

    push_operator                  shift and go to state 218

state 181

    (77) expB -> - . push_operator exp
    (23) push_operator -> .

    (               reduce using rule 23 (push_operator -> .)
    ID              reduce using rule 23 (push_operator -> .)
    +               reduce using rule 23 (push_operator -> .)
    -               reduce using rule 23 (push_operator -> .)
    FCONST          reduce using rule 23 (push_operator -> .)
    ICONST          reduce using rule 23 (push_operator -> .)
    SCONST          reduce using rule 23 (push_operator -> .)
    TRUE            reduce using rule 23 (push_operator -> .)
    FALSE           reduce using rule 23 (push_operator -> .)

    push_operator                  shift and go to state 219

state 182

    (75) exp -> term seen_term expB .

    <               reduce using rule 75 (exp -> term seen_term expB .)
    >               reduce using rule 75 (exp -> term seen_term expB .)
    DIFF            reduce using rule 75 (exp -> term seen_term expB .)
    EQ              reduce using rule 75 (exp -> term seen_term expB .)
    LTEQ            reduce using rule 75 (exp -> term seen_term expB .)
    GTEQ            reduce using rule 75 (exp -> term seen_term expB .)
    AND             reduce using rule 75 (exp -> term seen_term expB .)
    OR              reduce using rule 75 (exp -> term seen_term expB .)
    ;               reduce using rule 75 (exp -> term seen_term expB .)
    )               reduce using rule 75 (exp -> term seen_term expB .)
    ,               reduce using rule 75 (exp -> term seen_term expB .)
    ]               reduce using rule 75 (exp -> term seen_term expB .)


state 183

    (79) expB -> empty .

    <               reduce using rule 79 (expB -> empty .)
    >               reduce using rule 79 (expB -> empty .)
    DIFF            reduce using rule 79 (expB -> empty .)
    EQ              reduce using rule 79 (expB -> empty .)
    LTEQ            reduce using rule 79 (expB -> empty .)
    GTEQ            reduce using rule 79 (expB -> empty .)
    AND             reduce using rule 79 (expB -> empty .)
    OR              reduce using rule 79 (expB -> empty .)
    ;               reduce using rule 79 (expB -> empty .)
    )               reduce using rule 79 (expB -> empty .)
    ,               reduce using rule 79 (expB -> empty .)
    ]               reduce using rule 79 (expB -> empty .)


state 184

    (73) expressionB -> GTEQ push_operator . exp
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    term                           shift and go to state 92
    funccall                       shift and go to state 88
    signB                          shift and go to state 81
    sign                           shift and go to state 90
    exp                            shift and go to state 220
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 185

    (72) expressionB -> LTEQ push_operator . exp
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    term                           shift and go to state 92
    funccall                       shift and go to state 88
    signB                          shift and go to state 81
    sign                           shift and go to state 90
    exp                            shift and go to state 221
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 186

    (70) expressionB -> DIFF push_operator . exp
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    term                           shift and go to state 92
    funccall                       shift and go to state 88
    signB                          shift and go to state 81
    sign                           shift and go to state 90
    exp                            shift and go to state 222
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 187

    (71) expressionB -> EQ push_operator . exp
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    term                           shift and go to state 92
    funccall                       shift and go to state 88
    signB                          shift and go to state 81
    sign                           shift and go to state 90
    exp                            shift and go to state 223
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 188

    (68) expressionB -> < push_operator . exp
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    term                           shift and go to state 92
    funccall                       shift and go to state 88
    signB                          shift and go to state 81
    sign                           shift and go to state 90
    exp                            shift and go to state 224
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 189

    (69) expressionB -> > push_operator . exp
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    term                           shift and go to state 92
    funccall                       shift and go to state 88
    signB                          shift and go to state 81
    sign                           shift and go to state 90
    exp                            shift and go to state 225
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 190

    (65) superexpressionB -> AND push_operator . superexpression
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    sign                           shift and go to state 90
    signB                          shift and go to state 81
    factor                         shift and go to state 86
    empty                          shift and go to state 87
    funccall                       shift and go to state 88
    superexpression                shift and go to state 226
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 191

    (105) whileloop -> WHILE ( hyperexpression ) . block
    (35) block -> . { instructionsOpt }

    {               shift and go to state 40

    block                          shift and go to state 227

state 192

    (117) outputB -> SCONST push_operand . print_quadruple outputC
    (119) print_quadruple -> .

    )               reduce using rule 119 (print_quadruple -> .)
    ,               reduce using rule 119 (print_quadruple -> .)

    print_quadruple                shift and go to state 228

state 193

    (118) outputB -> hyperexpression print_quadruple . outputC
    (120) outputC -> . )
    (121) outputC -> . , outputB

    )               shift and go to state 229
    ,               shift and go to state 230

    outputC                        shift and go to state 231

state 194

    (38) assign -> ID push_operand . dimensionsOpt = push_operator hyperexpression quadruple_assign
    (40) dimensionsOpt -> . dimensions
    (41) dimensionsOpt -> . empty
    (135) dimensions -> . [ hyperexpression ] dimensionsB
    (142) empty -> .

    [               shift and go to state 113
    =               reduce using rule 142 (empty -> .)

    dimensions                     shift and go to state 112
    dimensionsOpt                  shift and go to state 232
    empty                          shift and go to state 115

state 195

    (112) forloop -> FOR ( assign ; . hyperexpression ; hyperexpression ) block
    (61) hyperexpression -> . superexpression hyperexpressionB
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    sign                           shift and go to state 90
    signB                          shift and go to state 81
    hyperexpression                shift and go to state 233
    factor                         shift and go to state 86
    empty                          shift and go to state 87
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 196

    (114) inputB -> , . ID inputB

    ID              shift and go to state 234


state 197

    (113) input -> INPUT ( ID inputB . )

    )               shift and go to state 235


state 198

    (115) inputB -> empty .

    )               reduce using rule 115 (inputB -> empty .)


state 199

    (56) assignfunccallB -> ( pop_operand . funccallB funccallC
    (130) funccallB -> . hyperexpression seen_param
    (131) funccallB -> . empty
    (61) hyperexpression -> . superexpression hyperexpressionB
    (142) empty -> .
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -

    ,               reduce using rule 142 (empty -> .)
    )               reduce using rule 142 (empty -> .)
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)
    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84

    funccallB                      shift and go to state 236
    signB                          shift and go to state 81
    hyperexpression                shift and go to state 177
    factor                         shift and go to state 86
    empty                          shift and go to state 178
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    sign                           shift and go to state 90
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 200

    (39) assignB -> dimensionsOpt = . push_operator hyperexpression quadruple_assign
    (23) push_operator -> .

    (               reduce using rule 23 (push_operator -> .)
    ID              reduce using rule 23 (push_operator -> .)
    +               reduce using rule 23 (push_operator -> .)
    -               reduce using rule 23 (push_operator -> .)
    FCONST          reduce using rule 23 (push_operator -> .)
    ICONST          reduce using rule 23 (push_operator -> .)
    SCONST          reduce using rule 23 (push_operator -> .)
    TRUE            reduce using rule 23 (push_operator -> .)
    FALSE           reduce using rule 23 (push_operator -> .)

    push_operator                  shift and go to state 237

state 201

    (42) condition -> IF ( hyperexpression ) . block else
    (35) block -> . { instructionsOpt }

    {               shift and go to state 40

    block                          shift and go to state 238

state 202

    (32) func -> DEF returntype ID ( paramsOpt ) .

    {               reduce using rule 32 (func -> DEF returntype ID ( paramsOpt ) .)


state 203

    (33) paramsOpt -> params paramsB .

    )               reduce using rule 33 (paramsOpt -> params paramsB .)


state 204

    (140) paramsB -> , . params paramsB
    (139) params -> . type ID
    (106) type -> . INT
    (107) type -> . FLOAT
    (108) type -> . STRING
    (109) type -> . BOOL

    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18

    type                           shift and go to state 161
    params                         shift and go to state 239

state 205

    (141) paramsB -> empty .

    )               reduce using rule 141 (paramsB -> empty .)


state 206

    (139) params -> type ID .

    ,               reduce using rule 139 (params -> type ID .)
    )               reduce using rule 139 (params -> type ID .)


state 207

    (135) dimensions -> [ hyperexpression ] . dimensionsB
    (136) dimensionsB -> . [ hyperexpression ]
    (137) dimensionsB -> . empty
    (142) empty -> .

    [               shift and go to state 241
    =               reduce using rule 142 (empty -> .)
    ,               reduce using rule 142 (empty -> .)
    ;               reduce using rule 142 (empty -> .)
    /               reduce using rule 142 (empty -> .)
    *               reduce using rule 142 (empty -> .)
    -               reduce using rule 142 (empty -> .)
    +               reduce using rule 142 (empty -> .)
    <               reduce using rule 142 (empty -> .)
    >               reduce using rule 142 (empty -> .)
    DIFF            reduce using rule 142 (empty -> .)
    EQ              reduce using rule 142 (empty -> .)
    LTEQ            reduce using rule 142 (empty -> .)
    GTEQ            reduce using rule 142 (empty -> .)
    AND             reduce using rule 142 (empty -> .)
    OR              reduce using rule 142 (empty -> .)
    )               reduce using rule 142 (empty -> .)
    ]               reduce using rule 142 (empty -> .)

    dimensionsB                    shift and go to state 240
    empty                          shift and go to state 242

state 208

    (26) declarationC -> , repush_type declarationB declarationC .

    INT             reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    FLOAT           reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    STRING          reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    BOOL            reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    DEF             reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    MAIN            reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    ID              reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    PRINT           reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    RETURN          reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    INPUT           reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    IF              reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    WHILE           reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    FOR             reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    #               reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    TRACKDECISION   reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    FORGETDECISION  reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)
    }               reduce using rule 26 (declarationC -> , repush_type declarationB declarationC .)


state 209

    (25) declarationC -> = push_operator hyperexpression quadruple_assign . declarationD
    (28) declarationD -> . , repush_type declarationB declarationC
    (29) declarationD -> . ;

    ,               shift and go to state 243
    ;               shift and go to state 244

    declarationD                   shift and go to state 245

state 210

    (86) factor -> ( seen_parentheses hyperexpression ) .

    /               reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)
    *               reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)
    -               reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)
    +               reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)
    <               reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)
    >               reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)
    DIFF            reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)
    EQ              reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)
    LTEQ            reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)
    GTEQ            reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)
    AND             reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)
    OR              reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)
    )               reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)
    ;               reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)
    ,               reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)
    ]               reduce using rule 86 (factor -> ( seen_parentheses hyperexpression ) .)


state 211

    (83) termB -> * push_operator . term
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    term                           shift and go to state 246
    funccall                       shift and go to state 88
    signB                          shift and go to state 81
    sign                           shift and go to state 90
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 212

    (82) termB -> / push_operator . term
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    term                           shift and go to state 247
    funccall                       shift and go to state 88
    signB                          shift and go to state 81
    sign                           shift and go to state 90
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 213

    (62) hyperexpressionB -> OR push_operator hyperexpression .

    ;               reduce using rule 62 (hyperexpressionB -> OR push_operator hyperexpression .)
    )               reduce using rule 62 (hyperexpressionB -> OR push_operator hyperexpression .)
    ,               reduce using rule 62 (hyperexpressionB -> OR push_operator hyperexpression .)
    ]               reduce using rule 62 (hyperexpressionB -> OR push_operator hyperexpression .)


state 214

    (129) funccall -> ID ( funccallB funccallC .

    /               reduce using rule 129 (funccall -> ID ( funccallB funccallC .)
    *               reduce using rule 129 (funccall -> ID ( funccallB funccallC .)
    -               reduce using rule 129 (funccall -> ID ( funccallB funccallC .)
    +               reduce using rule 129 (funccall -> ID ( funccallB funccallC .)
    <               reduce using rule 129 (funccall -> ID ( funccallB funccallC .)
    >               reduce using rule 129 (funccall -> ID ( funccallB funccallC .)
    DIFF            reduce using rule 129 (funccall -> ID ( funccallB funccallC .)
    EQ              reduce using rule 129 (funccall -> ID ( funccallB funccallC .)
    LTEQ            reduce using rule 129 (funccall -> ID ( funccallB funccallC .)
    GTEQ            reduce using rule 129 (funccall -> ID ( funccallB funccallC .)
    AND             reduce using rule 129 (funccall -> ID ( funccallB funccallC .)
    OR              reduce using rule 129 (funccall -> ID ( funccallB funccallC .)
    ,               reduce using rule 129 (funccall -> ID ( funccallB funccallC .)
    )               reduce using rule 129 (funccall -> ID ( funccallB funccallC .)
    ;               reduce using rule 129 (funccall -> ID ( funccallB funccallC .)
    ]               reduce using rule 129 (funccall -> ID ( funccallB funccallC .)


state 215

    (134) funccallC -> ) .

    ;               reduce using rule 134 (funccallC -> ) .)
    /               reduce using rule 134 (funccallC -> ) .)
    *               reduce using rule 134 (funccallC -> ) .)
    -               reduce using rule 134 (funccallC -> ) .)
    +               reduce using rule 134 (funccallC -> ) .)
    <               reduce using rule 134 (funccallC -> ) .)
    >               reduce using rule 134 (funccallC -> ) .)
    DIFF            reduce using rule 134 (funccallC -> ) .)
    EQ              reduce using rule 134 (funccallC -> ) .)
    LTEQ            reduce using rule 134 (funccallC -> ) .)
    GTEQ            reduce using rule 134 (funccallC -> ) .)
    AND             reduce using rule 134 (funccallC -> ) .)
    OR              reduce using rule 134 (funccallC -> ) .)
    )               reduce using rule 134 (funccallC -> ) .)
    ,               reduce using rule 134 (funccallC -> ) .)
    ]               reduce using rule 134 (funccallC -> ) .)


state 216

    (133) funccallC -> , . funccallB funccallC
    (130) funccallB -> . hyperexpression seen_param
    (131) funccallB -> . empty
    (61) hyperexpression -> . superexpression hyperexpressionB
    (142) empty -> .
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -

    ,               reduce using rule 142 (empty -> .)
    )               reduce using rule 142 (empty -> .)
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)
    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84

    funccallB                      shift and go to state 248
    signB                          shift and go to state 81
    hyperexpression                shift and go to state 177
    factor                         shift and go to state 86
    empty                          shift and go to state 178
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    sign                           shift and go to state 90
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 217

    (130) funccallB -> hyperexpression seen_param .

    ,               reduce using rule 130 (funccallB -> hyperexpression seen_param .)
    )               reduce using rule 130 (funccallB -> hyperexpression seen_param .)


state 218

    (78) expB -> + push_operator . exp
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    term                           shift and go to state 92
    funccall                       shift and go to state 88
    signB                          shift and go to state 81
    sign                           shift and go to state 90
    exp                            shift and go to state 249
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 219

    (77) expB -> - push_operator . exp
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    term                           shift and go to state 92
    funccall                       shift and go to state 88
    signB                          shift and go to state 81
    sign                           shift and go to state 90
    exp                            shift and go to state 250
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 220

    (73) expressionB -> GTEQ push_operator exp .

    AND             reduce using rule 73 (expressionB -> GTEQ push_operator exp .)
    OR              reduce using rule 73 (expressionB -> GTEQ push_operator exp .)
    ;               reduce using rule 73 (expressionB -> GTEQ push_operator exp .)
    )               reduce using rule 73 (expressionB -> GTEQ push_operator exp .)
    ,               reduce using rule 73 (expressionB -> GTEQ push_operator exp .)
    ]               reduce using rule 73 (expressionB -> GTEQ push_operator exp .)


state 221

    (72) expressionB -> LTEQ push_operator exp .

    AND             reduce using rule 72 (expressionB -> LTEQ push_operator exp .)
    OR              reduce using rule 72 (expressionB -> LTEQ push_operator exp .)
    ;               reduce using rule 72 (expressionB -> LTEQ push_operator exp .)
    )               reduce using rule 72 (expressionB -> LTEQ push_operator exp .)
    ,               reduce using rule 72 (expressionB -> LTEQ push_operator exp .)
    ]               reduce using rule 72 (expressionB -> LTEQ push_operator exp .)


state 222

    (70) expressionB -> DIFF push_operator exp .

    AND             reduce using rule 70 (expressionB -> DIFF push_operator exp .)
    OR              reduce using rule 70 (expressionB -> DIFF push_operator exp .)
    ;               reduce using rule 70 (expressionB -> DIFF push_operator exp .)
    )               reduce using rule 70 (expressionB -> DIFF push_operator exp .)
    ,               reduce using rule 70 (expressionB -> DIFF push_operator exp .)
    ]               reduce using rule 70 (expressionB -> DIFF push_operator exp .)


state 223

    (71) expressionB -> EQ push_operator exp .

    AND             reduce using rule 71 (expressionB -> EQ push_operator exp .)
    OR              reduce using rule 71 (expressionB -> EQ push_operator exp .)
    ;               reduce using rule 71 (expressionB -> EQ push_operator exp .)
    )               reduce using rule 71 (expressionB -> EQ push_operator exp .)
    ,               reduce using rule 71 (expressionB -> EQ push_operator exp .)
    ]               reduce using rule 71 (expressionB -> EQ push_operator exp .)


state 224

    (68) expressionB -> < push_operator exp .

    AND             reduce using rule 68 (expressionB -> < push_operator exp .)
    OR              reduce using rule 68 (expressionB -> < push_operator exp .)
    ;               reduce using rule 68 (expressionB -> < push_operator exp .)
    )               reduce using rule 68 (expressionB -> < push_operator exp .)
    ,               reduce using rule 68 (expressionB -> < push_operator exp .)
    ]               reduce using rule 68 (expressionB -> < push_operator exp .)


state 225

    (69) expressionB -> > push_operator exp .

    AND             reduce using rule 69 (expressionB -> > push_operator exp .)
    OR              reduce using rule 69 (expressionB -> > push_operator exp .)
    ;               reduce using rule 69 (expressionB -> > push_operator exp .)
    )               reduce using rule 69 (expressionB -> > push_operator exp .)
    ,               reduce using rule 69 (expressionB -> > push_operator exp .)
    ]               reduce using rule 69 (expressionB -> > push_operator exp .)


state 226

    (65) superexpressionB -> AND push_operator superexpression .

    OR              reduce using rule 65 (superexpressionB -> AND push_operator superexpression .)
    ;               reduce using rule 65 (superexpressionB -> AND push_operator superexpression .)
    )               reduce using rule 65 (superexpressionB -> AND push_operator superexpression .)
    ,               reduce using rule 65 (superexpressionB -> AND push_operator superexpression .)
    ]               reduce using rule 65 (superexpressionB -> AND push_operator superexpression .)


state 227

    (105) whileloop -> WHILE ( hyperexpression ) block .

    ID              reduce using rule 105 (whileloop -> WHILE ( hyperexpression ) block .)
    PRINT           reduce using rule 105 (whileloop -> WHILE ( hyperexpression ) block .)
    RETURN          reduce using rule 105 (whileloop -> WHILE ( hyperexpression ) block .)
    INPUT           reduce using rule 105 (whileloop -> WHILE ( hyperexpression ) block .)
    IF              reduce using rule 105 (whileloop -> WHILE ( hyperexpression ) block .)
    WHILE           reduce using rule 105 (whileloop -> WHILE ( hyperexpression ) block .)
    FOR             reduce using rule 105 (whileloop -> WHILE ( hyperexpression ) block .)
    INT             reduce using rule 105 (whileloop -> WHILE ( hyperexpression ) block .)
    FLOAT           reduce using rule 105 (whileloop -> WHILE ( hyperexpression ) block .)
    STRING          reduce using rule 105 (whileloop -> WHILE ( hyperexpression ) block .)
    BOOL            reduce using rule 105 (whileloop -> WHILE ( hyperexpression ) block .)
    #               reduce using rule 105 (whileloop -> WHILE ( hyperexpression ) block .)
    TRACKDECISION   reduce using rule 105 (whileloop -> WHILE ( hyperexpression ) block .)
    FORGETDECISION  reduce using rule 105 (whileloop -> WHILE ( hyperexpression ) block .)
    }               reduce using rule 105 (whileloop -> WHILE ( hyperexpression ) block .)


state 228

    (117) outputB -> SCONST push_operand print_quadruple . outputC
    (120) outputC -> . )
    (121) outputC -> . , outputB

    )               shift and go to state 229
    ,               shift and go to state 230

    outputC                        shift and go to state 251

state 229

    (120) outputC -> ) .

    ;               reduce using rule 120 (outputC -> ) .)


state 230

    (121) outputC -> , . outputB
    (117) outputB -> . SCONST push_operand print_quadruple outputC
    (118) outputB -> . hyperexpression print_quadruple outputC
    (61) hyperexpression -> . superexpression hyperexpressionB
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

  ! shift/reduce conflict for SCONST resolved as shift
    SCONST          shift and go to state 145
    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

  ! SCONST          [ reduce using rule 142 (empty -> .) ]

    signB                          shift and go to state 81
    hyperexpression                shift and go to state 146
    factor                         shift and go to state 86
    empty                          shift and go to state 87
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    sign                           shift and go to state 90
    term                           shift and go to state 92
    exp                            shift and go to state 93
    outputB                        shift and go to state 252
    expression                     shift and go to state 94

state 231

    (118) outputB -> hyperexpression print_quadruple outputC .

    ;               reduce using rule 118 (outputB -> hyperexpression print_quadruple outputC .)


state 232

    (38) assign -> ID push_operand dimensionsOpt . = push_operator hyperexpression quadruple_assign

    =               shift and go to state 253


state 233

    (112) forloop -> FOR ( assign ; hyperexpression . ; hyperexpression ) block

    ;               shift and go to state 254


state 234

    (114) inputB -> , ID . inputB
    (114) inputB -> . , ID inputB
    (115) inputB -> . empty
    (142) empty -> .

    ,               shift and go to state 196
    )               reduce using rule 142 (empty -> .)

    inputB                         shift and go to state 255
    empty                          shift and go to state 198

state 235

    (113) input -> INPUT ( ID inputB ) .

    ;               reduce using rule 113 (input -> INPUT ( ID inputB ) .)


state 236

    (56) assignfunccallB -> ( pop_operand funccallB . funccallC
    (133) funccallC -> . , funccallB funccallC
    (134) funccallC -> . )

    ,               shift and go to state 216
    )               shift and go to state 215

    funccallC                      shift and go to state 256

state 237

    (39) assignB -> dimensionsOpt = push_operator . hyperexpression quadruple_assign
    (61) hyperexpression -> . superexpression hyperexpressionB
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    sign                           shift and go to state 90
    signB                          shift and go to state 81
    hyperexpression                shift and go to state 257
    factor                         shift and go to state 86
    empty                          shift and go to state 87
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 238

    (42) condition -> IF ( hyperexpression ) block . else
    (43) else -> . ELSE block
    (44) else -> . empty
    (142) empty -> .

    ELSE            shift and go to state 258
    ID              reduce using rule 142 (empty -> .)
    PRINT           reduce using rule 142 (empty -> .)
    RETURN          reduce using rule 142 (empty -> .)
    INPUT           reduce using rule 142 (empty -> .)
    IF              reduce using rule 142 (empty -> .)
    WHILE           reduce using rule 142 (empty -> .)
    FOR             reduce using rule 142 (empty -> .)
    INT             reduce using rule 142 (empty -> .)
    FLOAT           reduce using rule 142 (empty -> .)
    STRING          reduce using rule 142 (empty -> .)
    BOOL            reduce using rule 142 (empty -> .)
    #               reduce using rule 142 (empty -> .)
    TRACKDECISION   reduce using rule 142 (empty -> .)
    FORGETDECISION  reduce using rule 142 (empty -> .)
    }               reduce using rule 142 (empty -> .)

    else                           shift and go to state 259
    empty                          shift and go to state 260

state 239

    (140) paramsB -> , params . paramsB
    (140) paramsB -> . , params paramsB
    (141) paramsB -> . empty
    (142) empty -> .

    ,               shift and go to state 204
    )               reduce using rule 142 (empty -> .)

    paramsB                        shift and go to state 261
    empty                          shift and go to state 205

state 240

    (135) dimensions -> [ hyperexpression ] dimensionsB .

    /               reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    *               reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    -               reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    +               reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    <               reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    >               reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    DIFF            reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    EQ              reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    LTEQ            reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    GTEQ            reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    AND             reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    OR              reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    ;               reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    )               reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    ,               reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    ]               reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)
    =               reduce using rule 135 (dimensions -> [ hyperexpression ] dimensionsB .)


state 241

    (136) dimensionsB -> [ . hyperexpression ]
    (61) hyperexpression -> . superexpression hyperexpressionB
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    sign                           shift and go to state 90
    signB                          shift and go to state 81
    hyperexpression                shift and go to state 262
    factor                         shift and go to state 86
    empty                          shift and go to state 87
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 242

    (137) dimensionsB -> empty .

    =               reduce using rule 137 (dimensionsB -> empty .)
    ,               reduce using rule 137 (dimensionsB -> empty .)
    ;               reduce using rule 137 (dimensionsB -> empty .)
    /               reduce using rule 137 (dimensionsB -> empty .)
    *               reduce using rule 137 (dimensionsB -> empty .)
    -               reduce using rule 137 (dimensionsB -> empty .)
    +               reduce using rule 137 (dimensionsB -> empty .)
    <               reduce using rule 137 (dimensionsB -> empty .)
    >               reduce using rule 137 (dimensionsB -> empty .)
    DIFF            reduce using rule 137 (dimensionsB -> empty .)
    EQ              reduce using rule 137 (dimensionsB -> empty .)
    LTEQ            reduce using rule 137 (dimensionsB -> empty .)
    GTEQ            reduce using rule 137 (dimensionsB -> empty .)
    AND             reduce using rule 137 (dimensionsB -> empty .)
    OR              reduce using rule 137 (dimensionsB -> empty .)
    )               reduce using rule 137 (dimensionsB -> empty .)
    ]               reduce using rule 137 (dimensionsB -> empty .)


state 243

    (28) declarationD -> , . repush_type declarationB declarationC
    (22) repush_type -> .

    ID              reduce using rule 22 (repush_type -> .)

    repush_type                    shift and go to state 263

state 244

    (29) declarationD -> ; .

    INT             reduce using rule 29 (declarationD -> ; .)
    FLOAT           reduce using rule 29 (declarationD -> ; .)
    STRING          reduce using rule 29 (declarationD -> ; .)
    BOOL            reduce using rule 29 (declarationD -> ; .)
    DEF             reduce using rule 29 (declarationD -> ; .)
    MAIN            reduce using rule 29 (declarationD -> ; .)
    ID              reduce using rule 29 (declarationD -> ; .)
    PRINT           reduce using rule 29 (declarationD -> ; .)
    RETURN          reduce using rule 29 (declarationD -> ; .)
    INPUT           reduce using rule 29 (declarationD -> ; .)
    IF              reduce using rule 29 (declarationD -> ; .)
    WHILE           reduce using rule 29 (declarationD -> ; .)
    FOR             reduce using rule 29 (declarationD -> ; .)
    #               reduce using rule 29 (declarationD -> ; .)
    TRACKDECISION   reduce using rule 29 (declarationD -> ; .)
    FORGETDECISION  reduce using rule 29 (declarationD -> ; .)
    }               reduce using rule 29 (declarationD -> ; .)


state 245

    (25) declarationC -> = push_operator hyperexpression quadruple_assign declarationD .

    INT             reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    FLOAT           reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    STRING          reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    BOOL            reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    DEF             reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    MAIN            reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    ID              reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    PRINT           reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    RETURN          reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    INPUT           reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    IF              reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    WHILE           reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    FOR             reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    #               reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    TRACKDECISION   reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    FORGETDECISION  reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)
    }               reduce using rule 25 (declarationC -> = push_operator hyperexpression quadruple_assign declarationD .)


state 246

    (83) termB -> * push_operator term .

    -               reduce using rule 83 (termB -> * push_operator term .)
    +               reduce using rule 83 (termB -> * push_operator term .)
    <               reduce using rule 83 (termB -> * push_operator term .)
    >               reduce using rule 83 (termB -> * push_operator term .)
    DIFF            reduce using rule 83 (termB -> * push_operator term .)
    EQ              reduce using rule 83 (termB -> * push_operator term .)
    LTEQ            reduce using rule 83 (termB -> * push_operator term .)
    GTEQ            reduce using rule 83 (termB -> * push_operator term .)
    AND             reduce using rule 83 (termB -> * push_operator term .)
    OR              reduce using rule 83 (termB -> * push_operator term .)
    ;               reduce using rule 83 (termB -> * push_operator term .)
    )               reduce using rule 83 (termB -> * push_operator term .)
    ,               reduce using rule 83 (termB -> * push_operator term .)
    ]               reduce using rule 83 (termB -> * push_operator term .)


state 247

    (82) termB -> / push_operator term .

    -               reduce using rule 82 (termB -> / push_operator term .)
    +               reduce using rule 82 (termB -> / push_operator term .)
    <               reduce using rule 82 (termB -> / push_operator term .)
    >               reduce using rule 82 (termB -> / push_operator term .)
    DIFF            reduce using rule 82 (termB -> / push_operator term .)
    EQ              reduce using rule 82 (termB -> / push_operator term .)
    LTEQ            reduce using rule 82 (termB -> / push_operator term .)
    GTEQ            reduce using rule 82 (termB -> / push_operator term .)
    AND             reduce using rule 82 (termB -> / push_operator term .)
    OR              reduce using rule 82 (termB -> / push_operator term .)
    ;               reduce using rule 82 (termB -> / push_operator term .)
    )               reduce using rule 82 (termB -> / push_operator term .)
    ,               reduce using rule 82 (termB -> / push_operator term .)
    ]               reduce using rule 82 (termB -> / push_operator term .)


state 248

    (133) funccallC -> , funccallB . funccallC
    (133) funccallC -> . , funccallB funccallC
    (134) funccallC -> . )

    ,               shift and go to state 216
    )               shift and go to state 215

    funccallC                      shift and go to state 264

state 249

    (78) expB -> + push_operator exp .

    <               reduce using rule 78 (expB -> + push_operator exp .)
    >               reduce using rule 78 (expB -> + push_operator exp .)
    DIFF            reduce using rule 78 (expB -> + push_operator exp .)
    EQ              reduce using rule 78 (expB -> + push_operator exp .)
    LTEQ            reduce using rule 78 (expB -> + push_operator exp .)
    GTEQ            reduce using rule 78 (expB -> + push_operator exp .)
    AND             reduce using rule 78 (expB -> + push_operator exp .)
    OR              reduce using rule 78 (expB -> + push_operator exp .)
    ;               reduce using rule 78 (expB -> + push_operator exp .)
    )               reduce using rule 78 (expB -> + push_operator exp .)
    ,               reduce using rule 78 (expB -> + push_operator exp .)
    ]               reduce using rule 78 (expB -> + push_operator exp .)


state 250

    (77) expB -> - push_operator exp .

    <               reduce using rule 77 (expB -> - push_operator exp .)
    >               reduce using rule 77 (expB -> - push_operator exp .)
    DIFF            reduce using rule 77 (expB -> - push_operator exp .)
    EQ              reduce using rule 77 (expB -> - push_operator exp .)
    LTEQ            reduce using rule 77 (expB -> - push_operator exp .)
    GTEQ            reduce using rule 77 (expB -> - push_operator exp .)
    AND             reduce using rule 77 (expB -> - push_operator exp .)
    OR              reduce using rule 77 (expB -> - push_operator exp .)
    ;               reduce using rule 77 (expB -> - push_operator exp .)
    )               reduce using rule 77 (expB -> - push_operator exp .)
    ,               reduce using rule 77 (expB -> - push_operator exp .)
    ]               reduce using rule 77 (expB -> - push_operator exp .)


state 251

    (117) outputB -> SCONST push_operand print_quadruple outputC .

    ;               reduce using rule 117 (outputB -> SCONST push_operand print_quadruple outputC .)


state 252

    (121) outputC -> , outputB .

    ;               reduce using rule 121 (outputC -> , outputB .)


state 253

    (38) assign -> ID push_operand dimensionsOpt = . push_operator hyperexpression quadruple_assign
    (23) push_operator -> .

    (               reduce using rule 23 (push_operator -> .)
    ID              reduce using rule 23 (push_operator -> .)
    +               reduce using rule 23 (push_operator -> .)
    -               reduce using rule 23 (push_operator -> .)
    FCONST          reduce using rule 23 (push_operator -> .)
    ICONST          reduce using rule 23 (push_operator -> .)
    SCONST          reduce using rule 23 (push_operator -> .)
    TRUE            reduce using rule 23 (push_operator -> .)
    FALSE           reduce using rule 23 (push_operator -> .)

    push_operator                  shift and go to state 265

state 254

    (112) forloop -> FOR ( assign ; hyperexpression ; . hyperexpression ) block
    (61) hyperexpression -> . superexpression hyperexpressionB
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    sign                           shift and go to state 90
    signB                          shift and go to state 81
    hyperexpression                shift and go to state 266
    factor                         shift and go to state 86
    empty                          shift and go to state 87
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 255

    (114) inputB -> , ID inputB .

    )               reduce using rule 114 (inputB -> , ID inputB .)


state 256

    (56) assignfunccallB -> ( pop_operand funccallB funccallC .

    ;               reduce using rule 56 (assignfunccallB -> ( pop_operand funccallB funccallC .)


state 257

    (39) assignB -> dimensionsOpt = push_operator hyperexpression . quadruple_assign
    (24) quadruple_assign -> .

    ;               reduce using rule 24 (quadruple_assign -> .)

    quadruple_assign               shift and go to state 267

state 258

    (43) else -> ELSE . block
    (35) block -> . { instructionsOpt }

    {               shift and go to state 40

    block                          shift and go to state 268

state 259

    (42) condition -> IF ( hyperexpression ) block else .

    ID              reduce using rule 42 (condition -> IF ( hyperexpression ) block else .)
    PRINT           reduce using rule 42 (condition -> IF ( hyperexpression ) block else .)
    RETURN          reduce using rule 42 (condition -> IF ( hyperexpression ) block else .)
    INPUT           reduce using rule 42 (condition -> IF ( hyperexpression ) block else .)
    IF              reduce using rule 42 (condition -> IF ( hyperexpression ) block else .)
    WHILE           reduce using rule 42 (condition -> IF ( hyperexpression ) block else .)
    FOR             reduce using rule 42 (condition -> IF ( hyperexpression ) block else .)
    INT             reduce using rule 42 (condition -> IF ( hyperexpression ) block else .)
    FLOAT           reduce using rule 42 (condition -> IF ( hyperexpression ) block else .)
    STRING          reduce using rule 42 (condition -> IF ( hyperexpression ) block else .)
    BOOL            reduce using rule 42 (condition -> IF ( hyperexpression ) block else .)
    #               reduce using rule 42 (condition -> IF ( hyperexpression ) block else .)
    TRACKDECISION   reduce using rule 42 (condition -> IF ( hyperexpression ) block else .)
    FORGETDECISION  reduce using rule 42 (condition -> IF ( hyperexpression ) block else .)
    }               reduce using rule 42 (condition -> IF ( hyperexpression ) block else .)


state 260

    (44) else -> empty .

    ID              reduce using rule 44 (else -> empty .)
    PRINT           reduce using rule 44 (else -> empty .)
    RETURN          reduce using rule 44 (else -> empty .)
    INPUT           reduce using rule 44 (else -> empty .)
    IF              reduce using rule 44 (else -> empty .)
    WHILE           reduce using rule 44 (else -> empty .)
    FOR             reduce using rule 44 (else -> empty .)
    INT             reduce using rule 44 (else -> empty .)
    FLOAT           reduce using rule 44 (else -> empty .)
    STRING          reduce using rule 44 (else -> empty .)
    BOOL            reduce using rule 44 (else -> empty .)
    #               reduce using rule 44 (else -> empty .)
    TRACKDECISION   reduce using rule 44 (else -> empty .)
    FORGETDECISION  reduce using rule 44 (else -> empty .)
    }               reduce using rule 44 (else -> empty .)


state 261

    (140) paramsB -> , params paramsB .

    )               reduce using rule 140 (paramsB -> , params paramsB .)


state 262

    (136) dimensionsB -> [ hyperexpression . ]

    ]               shift and go to state 269


state 263

    (28) declarationD -> , repush_type . declarationB declarationC
    (19) declarationB -> . ID push_operand dimensionsOpt

    ID              shift and go to state 45

    declarationB                   shift and go to state 270

state 264

    (133) funccallC -> , funccallB funccallC .

    ;               reduce using rule 133 (funccallC -> , funccallB funccallC .)
    /               reduce using rule 133 (funccallC -> , funccallB funccallC .)
    *               reduce using rule 133 (funccallC -> , funccallB funccallC .)
    -               reduce using rule 133 (funccallC -> , funccallB funccallC .)
    +               reduce using rule 133 (funccallC -> , funccallB funccallC .)
    <               reduce using rule 133 (funccallC -> , funccallB funccallC .)
    >               reduce using rule 133 (funccallC -> , funccallB funccallC .)
    DIFF            reduce using rule 133 (funccallC -> , funccallB funccallC .)
    EQ              reduce using rule 133 (funccallC -> , funccallB funccallC .)
    LTEQ            reduce using rule 133 (funccallC -> , funccallB funccallC .)
    GTEQ            reduce using rule 133 (funccallC -> , funccallB funccallC .)
    AND             reduce using rule 133 (funccallC -> , funccallB funccallC .)
    OR              reduce using rule 133 (funccallC -> , funccallB funccallC .)
    )               reduce using rule 133 (funccallC -> , funccallB funccallC .)
    ,               reduce using rule 133 (funccallC -> , funccallB funccallC .)
    ]               reduce using rule 133 (funccallC -> , funccallB funccallC .)


state 265

    (38) assign -> ID push_operand dimensionsOpt = push_operator . hyperexpression quadruple_assign
    (61) hyperexpression -> . superexpression hyperexpressionB
    (64) superexpression -> . expression superexpressionB
    (67) expression -> . exp expressionB
    (75) exp -> . term seen_term expB
    (80) term -> . factor seen_factor termB
    (85) factor -> . signB constant
    (86) factor -> . ( seen_parentheses hyperexpression )
    (87) factor -> . funccall
    (88) factor -> . ID seen_ID dimensionsOpt
    (91) signB -> . sign
    (92) signB -> . empty
    (129) funccall -> . ID ( funccallB funccallC
    (103) sign -> . +
    (104) sign -> . -
    (142) empty -> .

    (               shift and go to state 82
    ID              shift and go to state 91
    +               shift and go to state 83
    -               shift and go to state 84
    FCONST          reduce using rule 142 (empty -> .)
    ICONST          reduce using rule 142 (empty -> .)
    SCONST          reduce using rule 142 (empty -> .)
    TRUE            reduce using rule 142 (empty -> .)
    FALSE           reduce using rule 142 (empty -> .)

    signB                          shift and go to state 81
    hyperexpression                shift and go to state 271
    factor                         shift and go to state 86
    empty                          shift and go to state 87
    funccall                       shift and go to state 88
    superexpression                shift and go to state 89
    sign                           shift and go to state 90
    term                           shift and go to state 92
    exp                            shift and go to state 93
    expression                     shift and go to state 94

state 266

    (112) forloop -> FOR ( assign ; hyperexpression ; hyperexpression . ) block

    )               shift and go to state 272


state 267

    (39) assignB -> dimensionsOpt = push_operator hyperexpression quadruple_assign .

    ;               reduce using rule 39 (assignB -> dimensionsOpt = push_operator hyperexpression quadruple_assign .)


state 268

    (43) else -> ELSE block .

    ID              reduce using rule 43 (else -> ELSE block .)
    PRINT           reduce using rule 43 (else -> ELSE block .)
    RETURN          reduce using rule 43 (else -> ELSE block .)
    INPUT           reduce using rule 43 (else -> ELSE block .)
    IF              reduce using rule 43 (else -> ELSE block .)
    WHILE           reduce using rule 43 (else -> ELSE block .)
    FOR             reduce using rule 43 (else -> ELSE block .)
    INT             reduce using rule 43 (else -> ELSE block .)
    FLOAT           reduce using rule 43 (else -> ELSE block .)
    STRING          reduce using rule 43 (else -> ELSE block .)
    BOOL            reduce using rule 43 (else -> ELSE block .)
    #               reduce using rule 43 (else -> ELSE block .)
    TRACKDECISION   reduce using rule 43 (else -> ELSE block .)
    FORGETDECISION  reduce using rule 43 (else -> ELSE block .)
    }               reduce using rule 43 (else -> ELSE block .)


state 269

    (136) dimensionsB -> [ hyperexpression ] .

    =               reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    ,               reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    ;               reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    /               reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    *               reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    -               reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    +               reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    <               reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    >               reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    DIFF            reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    EQ              reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    LTEQ            reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    GTEQ            reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    AND             reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    OR              reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    )               reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)
    ]               reduce using rule 136 (dimensionsB -> [ hyperexpression ] .)


state 270

    (28) declarationD -> , repush_type declarationB . declarationC
    (25) declarationC -> . = push_operator hyperexpression quadruple_assign declarationD
    (26) declarationC -> . , repush_type declarationB declarationC
    (27) declarationC -> . ;

    =               shift and go to state 79
    ,               shift and go to state 76
    ;               shift and go to state 77

    declarationC                   shift and go to state 273

state 271

    (38) assign -> ID push_operand dimensionsOpt = push_operator hyperexpression . quadruple_assign
    (24) quadruple_assign -> .

    ;               reduce using rule 24 (quadruple_assign -> .)

    quadruple_assign               shift and go to state 274

state 272

    (112) forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) . block
    (35) block -> . { instructionsOpt }

    {               shift and go to state 40

    block                          shift and go to state 275

state 273

    (28) declarationD -> , repush_type declarationB declarationC .

    INT             reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    FLOAT           reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    STRING          reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    BOOL            reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    DEF             reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    MAIN            reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    ID              reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    PRINT           reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    RETURN          reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    INPUT           reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    IF              reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    WHILE           reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    FOR             reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    #               reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    TRACKDECISION   reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    FORGETDECISION  reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)
    }               reduce using rule 28 (declarationD -> , repush_type declarationB declarationC .)


state 274

    (38) assign -> ID push_operand dimensionsOpt = push_operator hyperexpression quadruple_assign .

    ;               reduce using rule 38 (assign -> ID push_operand dimensionsOpt = push_operator hyperexpression quadruple_assign .)


state 275

    (112) forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .

    ID              reduce using rule 112 (forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .)
    PRINT           reduce using rule 112 (forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .)
    RETURN          reduce using rule 112 (forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .)
    INPUT           reduce using rule 112 (forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .)
    IF              reduce using rule 112 (forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .)
    WHILE           reduce using rule 112 (forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .)
    FOR             reduce using rule 112 (forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .)
    INT             reduce using rule 112 (forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .)
    FLOAT           reduce using rule 112 (forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .)
    STRING          reduce using rule 112 (forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .)
    BOOL            reduce using rule 112 (forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .)
    #               reduce using rule 112 (forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .)
    TRACKDECISION   reduce using rule 112 (forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .)
    FORGETDECISION  reduce using rule 112 (forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .)
    }               reduce using rule 112 (forloop -> FOR ( assign ; hyperexpression ; hyperexpression ) block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 40 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 40 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 40 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 40 resolved as shift
WARNING: shift/reduce conflict for IF in state 40 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 40 resolved as shift
WARNING: shift/reduce conflict for FOR in state 40 resolved as shift
WARNING: shift/reduce conflict for INT in state 40 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 40 resolved as shift
WARNING: shift/reduce conflict for STRING in state 40 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 40 resolved as shift
WARNING: shift/reduce conflict for # in state 40 resolved as shift
WARNING: shift/reduce conflict for TRACKDECISION in state 40 resolved as shift
WARNING: shift/reduce conflict for FORGETDECISION in state 40 resolved as shift
WARNING: shift/reduce conflict for ID in state 70 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 70 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 70 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 70 resolved as shift
WARNING: shift/reduce conflict for IF in state 70 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 70 resolved as shift
WARNING: shift/reduce conflict for FOR in state 70 resolved as shift
WARNING: shift/reduce conflict for INT in state 70 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 70 resolved as shift
WARNING: shift/reduce conflict for STRING in state 70 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 70 resolved as shift
WARNING: shift/reduce conflict for # in state 70 resolved as shift
WARNING: shift/reduce conflict for TRACKDECISION in state 70 resolved as shift
WARNING: shift/reduce conflict for FORGETDECISION in state 70 resolved as shift
WARNING: shift/reduce conflict for SCONST in state 97 resolved as shift
WARNING: shift/reduce conflict for SCONST in state 230 resolved as shift
WARNING: reduce/reduce conflict in state 58 resolved using rule (instructionsOpt -> empty)
WARNING: rejected rule (localdecisiondirective -> empty) in state 58
