Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL

Grammar

Rule 0     S' -> program
Rule 1     program -> config body
Rule 2     config -> configdirective config
Rule 3     config -> empty
Rule 4     configdirective -> VARSCONFIG = options
Rule 5     configdirective -> DECISIONSCONFIG = options
Rule 6     configdirective -> COMPLEXITYCONFIG = optionsyesno
Rule 7     options -> SOME
Rule 8     options -> ALL
Rule 9     options -> MOST
Rule 10    options -> NONE
Rule 11    optionsyesno -> YES
Rule 12    optionsyesno -> NO
Rule 13    body -> declarationsOpt funcsOpt main funcsOpt
Rule 14    funcsOpt -> func funcsOpt
Rule 15    funcsOpt -> empty
Rule 16    declarationsOpt -> declaration declarationsOpt
Rule 17    declarationsOpt -> empty
Rule 18    declaration -> type assign
Rule 19    main -> MAIN ( ) block
Rule 20    func -> DEF returntype ID ( paramsOpt ) block
Rule 21    paramsOpt -> params
Rule 22    paramsOpt -> empty
Rule 23    block -> { instructionsOpt }
Rule 24    instructionsOpt -> instruction instructionsOpt
Rule 25    instructionsOpt -> empty
Rule 26    assign -> ID dimensionsOpt = superexpression
Rule 27    assignB -> dimensionsOpt = superexpression
Rule 28    dimensionsOpt -> dimensions
Rule 29    dimensionsOpt -> empty
Rule 30    condition -> IF ( superexpression ) block else
Rule 31    else -> ELSE block
Rule 32    else -> empty
Rule 33    instruction -> assignfunccall ;
Rule 34    instruction -> output ;
Rule 35    instruction -> input ;
Rule 36    instruction -> return ;
Rule 37    instruction -> declaration ;
Rule 38    instruction -> condition
Rule 39    instruction -> whileloop
Rule 40    instruction -> forloop
Rule 41    instruction -> localdirective
Rule 42    assignfunccall -> ID assignfunccallB
Rule 43    assignfunccallB -> ( funccallB
Rule 44    assignfunccallB -> assignB
Rule 45    localdirective -> localvardirective
Rule 46    localdirective -> localdecisiondirective
Rule 47    localdirective -> localmsgdirective
Rule 48    superexpression -> expression superexpressionB
Rule 49    superexpressionB -> & & superexpression
Rule 50    superexpressionB -> | | superexpression
Rule 51    superexpressionB -> empty
Rule 52    expression -> exp expressionB
Rule 53    expressionB -> < exp
Rule 54    expressionB -> > exp
Rule 55    expressionB -> < > exp
Rule 56    expressionB -> = = exp
Rule 57    expressionB -> < = exp
Rule 58    expressionB -> > = exp
Rule 59    expressionB -> empty
Rule 60    exp -> term expB
Rule 61    expB -> - exp
Rule 62    expB -> + exp
Rule 63    expB -> empty
Rule 64    term -> factor termB
Rule 65    termB -> / term
Rule 66    termB -> * term
Rule 67    termB -> empty
Rule 68    factor -> signB constant
Rule 69    factor -> ( superexpression )
Rule 70    factor -> funccall
Rule 71    factor -> ID dimensionsOpt
Rule 72    signB -> sign
Rule 73    signB -> empty
Rule 74    constant -> FCONST
Rule 75    constant -> ICONST
Rule 76    constant -> TRUE
Rule 77    constant -> FALSE
Rule 78    sign -> +
Rule 79    sign -> -
Rule 80    whileloop -> WHILE ( superexpression ) block
Rule 81    type -> INT
Rule 82    type -> FLOAT
Rule 83    type -> STRING
Rule 84    returntype -> VOID
Rule 85    returntype -> type
Rule 86    forloop -> FOR ( assign ; superexpression ; superexpression ) block
Rule 87    input -> INPUT ( ID inputB )
Rule 88    inputB -> , ID inputB
Rule 89    inputB -> empty
Rule 90    output -> PRINT ( outputB
Rule 91    outputB -> STRING outputC
Rule 92    outputB -> superexpression outputC
Rule 93    outputC -> )
Rule 94    outputC -> , outputB
Rule 95    localvardirective -> # localvardirectiveB ID
Rule 96    localvardirectiveB -> TRACK
Rule 97    localvardirectiveB -> FORGET
Rule 98    localmsgdirective -> # SHOW STRING
Rule 99    localdecisiondirective -> TRACKDECISION
Rule 100   localdecisiondirective -> FORGETDECISION
Rule 101   localdecisiondirective -> empty
Rule 102   funccall -> DEF ID ( funccallB
Rule 103   funccallB -> superexpression funccallC
Rule 104   funccallB -> )
Rule 105   funccallC -> , superexpression funccallC
Rule 106   funccallC -> )
Rule 107   dimensions -> [ superexpression ] dimensionsB
Rule 108   dimensionsB -> [ superexpression ]
Rule 109   return -> RETURN superexpression
Rule 110   params -> type ID paramsB
Rule 111   paramsB -> , type ID paramsB
Rule 112   paramsB -> empty
Rule 113   empty -> <empty>

Terminals, with rules where they appear

#                    : 95 98
&                    : 49 49
(                    : 19 20 30 43 69 80 86 87 90 102
)                    : 19 20 30 69 80 86 87 93 104 106
*                    : 66
+                    : 62 78
,                    : 88 94 105 111
-                    : 61 79
/                    : 65
;                    : 33 34 35 36 37 86 86
<                    : 53 55 57
=                    : 4 5 6 26 27 56 56 57 58
>                    : 54 55 58
ALL                  : 8
BOOL                 : 
COMPLEXITYCONFIG     : 6
DECISIONSCONFIG      : 5
DEF                  : 20 102
ELSE                 : 31
FALSE                : 77
FCONST               : 74
FLOAT                : 82
FOR                  : 86
FORGET               : 97
FORGETDECISION       : 100
ICONST               : 75
ID                   : 20 26 42 71 87 88 95 102 110 111
IF                   : 30
INPUT                : 87
INT                  : 81
MAIN                 : 19
MOST                 : 9
NO                   : 12
NONE                 : 10
PRINT                : 90
RETURN               : 109
SHOW                 : 98
SOME                 : 7
STRING               : 83 91 98
TRACK                : 96
TRACKDECISION        : 99
TRUE                 : 76
VARSCONFIG           : 4
VOID                 : 84
WHILE                : 80
YES                  : 11
[                    : 107 108
]                    : 107 108
error                : 
{                    : 23
|                    : 50 50
}                    : 23

Nonterminals, with rules where they appear

assign               : 18 86
assignB              : 44
assignfunccall       : 33
assignfunccallB      : 42
block                : 19 20 30 31 80 86
body                 : 1
condition            : 38
config               : 1 2
configdirective      : 2
constant             : 68
declaration          : 16 37
declarationsOpt      : 13 16
dimensions           : 28
dimensionsB          : 107
dimensionsOpt        : 26 27 71
else                 : 30
empty                : 3 15 17 22 25 29 32 51 59 63 67 73 89 101 112
exp                  : 52 53 54 55 56 57 58 61 62
expB                 : 60
expression           : 48
expressionB          : 52
factor               : 64
forloop              : 40
func                 : 14
funccall             : 70
funccallB            : 43 102
funccallC            : 103 105
funcsOpt             : 13 13 14
input                : 35
inputB               : 87 88
instruction          : 24
instructionsOpt      : 23 24
localdecisiondirective : 46
localdirective       : 41
localmsgdirective    : 47
localvardirective    : 45
localvardirectiveB   : 95
main                 : 13
options              : 4 5
optionsyesno         : 6
output               : 34
outputB              : 90 94
outputC              : 91 92
params               : 21
paramsB              : 110 111
paramsOpt            : 20
program              : 0
return               : 36
returntype           : 20
sign                 : 72
signB                : 68
superexpression      : 26 27 30 49 50 69 80 86 86 92 103 105 107 108 109
superexpressionB     : 48
term                 : 60 65 66
termB                : 64
type                 : 18 85 110 111
whileloop            : 39

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . config body
    (2) config -> . configdirective config
    (3) config -> . empty
    (4) configdirective -> . VARSCONFIG = options
    (5) configdirective -> . DECISIONSCONFIG = options
    (6) configdirective -> . COMPLEXITYCONFIG = optionsyesno
    (113) empty -> .

    VARSCONFIG      shift and go to state 2
    DECISIONSCONFIG shift and go to state 1
    COMPLEXITYCONFIG shift and go to state 4
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    STRING          reduce using rule 113 (empty -> .)
    DEF             reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)

    configdirective                shift and go to state 3
    program                        shift and go to state 5
    config                         shift and go to state 6
    empty                          shift and go to state 7

state 1

    (5) configdirective -> DECISIONSCONFIG . = options

    =               shift and go to state 8


state 2

    (4) configdirective -> VARSCONFIG . = options

    =               shift and go to state 9


state 3

    (2) config -> configdirective . config
    (2) config -> . configdirective config
    (3) config -> . empty
    (4) configdirective -> . VARSCONFIG = options
    (5) configdirective -> . DECISIONSCONFIG = options
    (6) configdirective -> . COMPLEXITYCONFIG = optionsyesno
    (113) empty -> .

    VARSCONFIG      shift and go to state 2
    DECISIONSCONFIG shift and go to state 1
    COMPLEXITYCONFIG shift and go to state 4
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    STRING          reduce using rule 113 (empty -> .)
    DEF             reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)

    config                         shift and go to state 10
    empty                          shift and go to state 7
    configdirective                shift and go to state 3

state 4

    (6) configdirective -> COMPLEXITYCONFIG . = optionsyesno

    =               shift and go to state 11


state 5

    (0) S' -> program .



state 6

    (1) program -> config . body
    (13) body -> . declarationsOpt funcsOpt main funcsOpt
    (16) declarationsOpt -> . declaration declarationsOpt
    (17) declarationsOpt -> . empty
    (18) declaration -> . type assign
    (113) empty -> .
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . STRING

    DEF             reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14

    body                           shift and go to state 12
    declarationsOpt                shift and go to state 13
    type                           shift and go to state 16
    declaration                    shift and go to state 18
    empty                          shift and go to state 19

state 7

    (3) config -> empty .

    INT             reduce using rule 3 (config -> empty .)
    FLOAT           reduce using rule 3 (config -> empty .)
    STRING          reduce using rule 3 (config -> empty .)
    DEF             reduce using rule 3 (config -> empty .)
    MAIN            reduce using rule 3 (config -> empty .)


state 8

    (5) configdirective -> DECISIONSCONFIG = . options
    (7) options -> . SOME
    (8) options -> . ALL
    (9) options -> . MOST
    (10) options -> . NONE

    SOME            shift and go to state 21
    ALL             shift and go to state 20
    MOST            shift and go to state 23
    NONE            shift and go to state 22

    options                        shift and go to state 24

state 9

    (4) configdirective -> VARSCONFIG = . options
    (7) options -> . SOME
    (8) options -> . ALL
    (9) options -> . MOST
    (10) options -> . NONE

    SOME            shift and go to state 21
    ALL             shift and go to state 20
    MOST            shift and go to state 23
    NONE            shift and go to state 22

    options                        shift and go to state 25

state 10

    (2) config -> configdirective config .

    INT             reduce using rule 2 (config -> configdirective config .)
    FLOAT           reduce using rule 2 (config -> configdirective config .)
    STRING          reduce using rule 2 (config -> configdirective config .)
    DEF             reduce using rule 2 (config -> configdirective config .)
    MAIN            reduce using rule 2 (config -> configdirective config .)


state 11

    (6) configdirective -> COMPLEXITYCONFIG = . optionsyesno
    (11) optionsyesno -> . YES
    (12) optionsyesno -> . NO

    YES             shift and go to state 26
    NO              shift and go to state 28

    optionsyesno                   shift and go to state 27

state 12

    (1) program -> config body .

    $end            reduce using rule 1 (program -> config body .)


state 13

    (13) body -> declarationsOpt . funcsOpt main funcsOpt
    (14) funcsOpt -> . func funcsOpt
    (15) funcsOpt -> . empty
    (20) func -> . DEF returntype ID ( paramsOpt ) block
    (113) empty -> .

    DEF             shift and go to state 32
    MAIN            reduce using rule 113 (empty -> .)

    funcsOpt                       shift and go to state 29
    func                           shift and go to state 31
    empty                          shift and go to state 30

state 14

    (83) type -> STRING .

    ID              reduce using rule 83 (type -> STRING .)


state 15

    (81) type -> INT .

    ID              reduce using rule 81 (type -> INT .)


state 16

    (18) declaration -> type . assign
    (26) assign -> . ID dimensionsOpt = superexpression

    ID              shift and go to state 33

    assign                         shift and go to state 34

state 17

    (82) type -> FLOAT .

    ID              reduce using rule 82 (type -> FLOAT .)


state 18

    (16) declarationsOpt -> declaration . declarationsOpt
    (16) declarationsOpt -> . declaration declarationsOpt
    (17) declarationsOpt -> . empty
    (18) declaration -> . type assign
    (113) empty -> .
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . STRING

    DEF             reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14

    declarationsOpt                shift and go to state 35
    type                           shift and go to state 16
    empty                          shift and go to state 19
    declaration                    shift and go to state 18

state 19

    (17) declarationsOpt -> empty .

    DEF             reduce using rule 17 (declarationsOpt -> empty .)
    MAIN            reduce using rule 17 (declarationsOpt -> empty .)


state 20

    (8) options -> ALL .

    VARSCONFIG      reduce using rule 8 (options -> ALL .)
    DECISIONSCONFIG reduce using rule 8 (options -> ALL .)
    COMPLEXITYCONFIG reduce using rule 8 (options -> ALL .)
    INT             reduce using rule 8 (options -> ALL .)
    FLOAT           reduce using rule 8 (options -> ALL .)
    STRING          reduce using rule 8 (options -> ALL .)
    DEF             reduce using rule 8 (options -> ALL .)
    MAIN            reduce using rule 8 (options -> ALL .)


state 21

    (7) options -> SOME .

    VARSCONFIG      reduce using rule 7 (options -> SOME .)
    DECISIONSCONFIG reduce using rule 7 (options -> SOME .)
    COMPLEXITYCONFIG reduce using rule 7 (options -> SOME .)
    INT             reduce using rule 7 (options -> SOME .)
    FLOAT           reduce using rule 7 (options -> SOME .)
    STRING          reduce using rule 7 (options -> SOME .)
    DEF             reduce using rule 7 (options -> SOME .)
    MAIN            reduce using rule 7 (options -> SOME .)


state 22

    (10) options -> NONE .

    VARSCONFIG      reduce using rule 10 (options -> NONE .)
    DECISIONSCONFIG reduce using rule 10 (options -> NONE .)
    COMPLEXITYCONFIG reduce using rule 10 (options -> NONE .)
    INT             reduce using rule 10 (options -> NONE .)
    FLOAT           reduce using rule 10 (options -> NONE .)
    STRING          reduce using rule 10 (options -> NONE .)
    DEF             reduce using rule 10 (options -> NONE .)
    MAIN            reduce using rule 10 (options -> NONE .)


state 23

    (9) options -> MOST .

    VARSCONFIG      reduce using rule 9 (options -> MOST .)
    DECISIONSCONFIG reduce using rule 9 (options -> MOST .)
    COMPLEXITYCONFIG reduce using rule 9 (options -> MOST .)
    INT             reduce using rule 9 (options -> MOST .)
    FLOAT           reduce using rule 9 (options -> MOST .)
    STRING          reduce using rule 9 (options -> MOST .)
    DEF             reduce using rule 9 (options -> MOST .)
    MAIN            reduce using rule 9 (options -> MOST .)


state 24

    (5) configdirective -> DECISIONSCONFIG = options .

    VARSCONFIG      reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    DECISIONSCONFIG reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    COMPLEXITYCONFIG reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    INT             reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    FLOAT           reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    STRING          reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    DEF             reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    MAIN            reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)


state 25

    (4) configdirective -> VARSCONFIG = options .

    VARSCONFIG      reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    DECISIONSCONFIG reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    COMPLEXITYCONFIG reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    INT             reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    FLOAT           reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    STRING          reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    DEF             reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    MAIN            reduce using rule 4 (configdirective -> VARSCONFIG = options .)


state 26

    (11) optionsyesno -> YES .

    VARSCONFIG      reduce using rule 11 (optionsyesno -> YES .)
    DECISIONSCONFIG reduce using rule 11 (optionsyesno -> YES .)
    COMPLEXITYCONFIG reduce using rule 11 (optionsyesno -> YES .)
    INT             reduce using rule 11 (optionsyesno -> YES .)
    FLOAT           reduce using rule 11 (optionsyesno -> YES .)
    STRING          reduce using rule 11 (optionsyesno -> YES .)
    DEF             reduce using rule 11 (optionsyesno -> YES .)
    MAIN            reduce using rule 11 (optionsyesno -> YES .)


state 27

    (6) configdirective -> COMPLEXITYCONFIG = optionsyesno .

    VARSCONFIG      reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    DECISIONSCONFIG reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    COMPLEXITYCONFIG reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    INT             reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    FLOAT           reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    STRING          reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    DEF             reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    MAIN            reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)


state 28

    (12) optionsyesno -> NO .

    VARSCONFIG      reduce using rule 12 (optionsyesno -> NO .)
    DECISIONSCONFIG reduce using rule 12 (optionsyesno -> NO .)
    COMPLEXITYCONFIG reduce using rule 12 (optionsyesno -> NO .)
    INT             reduce using rule 12 (optionsyesno -> NO .)
    FLOAT           reduce using rule 12 (optionsyesno -> NO .)
    STRING          reduce using rule 12 (optionsyesno -> NO .)
    DEF             reduce using rule 12 (optionsyesno -> NO .)
    MAIN            reduce using rule 12 (optionsyesno -> NO .)


state 29

    (13) body -> declarationsOpt funcsOpt . main funcsOpt
    (19) main -> . MAIN ( ) block

    MAIN            shift and go to state 36

    main                           shift and go to state 37

state 30

    (15) funcsOpt -> empty .

    MAIN            reduce using rule 15 (funcsOpt -> empty .)
    $end            reduce using rule 15 (funcsOpt -> empty .)


state 31

    (14) funcsOpt -> func . funcsOpt
    (14) funcsOpt -> . func funcsOpt
    (15) funcsOpt -> . empty
    (20) func -> . DEF returntype ID ( paramsOpt ) block
    (113) empty -> .

    DEF             shift and go to state 32
    MAIN            reduce using rule 113 (empty -> .)
    $end            reduce using rule 113 (empty -> .)

    funcsOpt                       shift and go to state 38
    empty                          shift and go to state 30
    func                           shift and go to state 31

state 32

    (20) func -> DEF . returntype ID ( paramsOpt ) block
    (84) returntype -> . VOID
    (85) returntype -> . type
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . STRING

    VOID            shift and go to state 39
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14

    returntype                     shift and go to state 40
    type                           shift and go to state 41

state 33

    (26) assign -> ID . dimensionsOpt = superexpression
    (28) dimensionsOpt -> . dimensions
    (29) dimensionsOpt -> . empty
    (107) dimensions -> . [ superexpression ] dimensionsB
    (113) empty -> .

    [               shift and go to state 43
    =               reduce using rule 113 (empty -> .)

    dimensionsOpt                  shift and go to state 44
    dimensions                     shift and go to state 42
    empty                          shift and go to state 45

state 34

    (18) declaration -> type assign .

    INT             reduce using rule 18 (declaration -> type assign .)
    FLOAT           reduce using rule 18 (declaration -> type assign .)
    STRING          reduce using rule 18 (declaration -> type assign .)
    DEF             reduce using rule 18 (declaration -> type assign .)
    MAIN            reduce using rule 18 (declaration -> type assign .)
    ;               reduce using rule 18 (declaration -> type assign .)


state 35

    (16) declarationsOpt -> declaration declarationsOpt .

    DEF             reduce using rule 16 (declarationsOpt -> declaration declarationsOpt .)
    MAIN            reduce using rule 16 (declarationsOpt -> declaration declarationsOpt .)


state 36

    (19) main -> MAIN . ( ) block

    (               shift and go to state 46


state 37

    (13) body -> declarationsOpt funcsOpt main . funcsOpt
    (14) funcsOpt -> . func funcsOpt
    (15) funcsOpt -> . empty
    (20) func -> . DEF returntype ID ( paramsOpt ) block
    (113) empty -> .

    DEF             shift and go to state 32
    $end            reduce using rule 113 (empty -> .)

    funcsOpt                       shift and go to state 47
    func                           shift and go to state 31
    empty                          shift and go to state 30

state 38

    (14) funcsOpt -> func funcsOpt .

    MAIN            reduce using rule 14 (funcsOpt -> func funcsOpt .)
    $end            reduce using rule 14 (funcsOpt -> func funcsOpt .)


state 39

    (84) returntype -> VOID .

    ID              reduce using rule 84 (returntype -> VOID .)


state 40

    (20) func -> DEF returntype . ID ( paramsOpt ) block

    ID              shift and go to state 48


state 41

    (85) returntype -> type .

    ID              reduce using rule 85 (returntype -> type .)


state 42

    (28) dimensionsOpt -> dimensions .

    /               reduce using rule 28 (dimensionsOpt -> dimensions .)
    *               reduce using rule 28 (dimensionsOpt -> dimensions .)
    -               reduce using rule 28 (dimensionsOpt -> dimensions .)
    +               reduce using rule 28 (dimensionsOpt -> dimensions .)
    <               reduce using rule 28 (dimensionsOpt -> dimensions .)
    >               reduce using rule 28 (dimensionsOpt -> dimensions .)
    =               reduce using rule 28 (dimensionsOpt -> dimensions .)
    &               reduce using rule 28 (dimensionsOpt -> dimensions .)
    |               reduce using rule 28 (dimensionsOpt -> dimensions .)
    ]               reduce using rule 28 (dimensionsOpt -> dimensions .)
    )               reduce using rule 28 (dimensionsOpt -> dimensions .)
    INT             reduce using rule 28 (dimensionsOpt -> dimensions .)
    FLOAT           reduce using rule 28 (dimensionsOpt -> dimensions .)
    STRING          reduce using rule 28 (dimensionsOpt -> dimensions .)
    DEF             reduce using rule 28 (dimensionsOpt -> dimensions .)
    MAIN            reduce using rule 28 (dimensionsOpt -> dimensions .)
    ;               reduce using rule 28 (dimensionsOpt -> dimensions .)
    ,               reduce using rule 28 (dimensionsOpt -> dimensions .)


state 43

    (107) dimensions -> [ . superexpression ] dimensionsB
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 58
    exp                            shift and go to state 61
    factor                         shift and go to state 55
    expression                     shift and go to state 62
    empty                          shift and go to state 56

state 44

    (26) assign -> ID dimensionsOpt . = superexpression

    =               shift and go to state 63


state 45

    (29) dimensionsOpt -> empty .

    /               reduce using rule 29 (dimensionsOpt -> empty .)
    *               reduce using rule 29 (dimensionsOpt -> empty .)
    -               reduce using rule 29 (dimensionsOpt -> empty .)
    +               reduce using rule 29 (dimensionsOpt -> empty .)
    <               reduce using rule 29 (dimensionsOpt -> empty .)
    >               reduce using rule 29 (dimensionsOpt -> empty .)
    =               reduce using rule 29 (dimensionsOpt -> empty .)
    &               reduce using rule 29 (dimensionsOpt -> empty .)
    |               reduce using rule 29 (dimensionsOpt -> empty .)
    ]               reduce using rule 29 (dimensionsOpt -> empty .)
    )               reduce using rule 29 (dimensionsOpt -> empty .)
    INT             reduce using rule 29 (dimensionsOpt -> empty .)
    FLOAT           reduce using rule 29 (dimensionsOpt -> empty .)
    STRING          reduce using rule 29 (dimensionsOpt -> empty .)
    DEF             reduce using rule 29 (dimensionsOpt -> empty .)
    MAIN            reduce using rule 29 (dimensionsOpt -> empty .)
    ;               reduce using rule 29 (dimensionsOpt -> empty .)
    ,               reduce using rule 29 (dimensionsOpt -> empty .)


state 46

    (19) main -> MAIN ( . ) block

    )               shift and go to state 64


state 47

    (13) body -> declarationsOpt funcsOpt main funcsOpt .

    $end            reduce using rule 13 (body -> declarationsOpt funcsOpt main funcsOpt .)


state 48

    (20) func -> DEF returntype ID . ( paramsOpt ) block

    (               shift and go to state 65


state 49

    (72) signB -> sign .

    FCONST          reduce using rule 72 (signB -> sign .)
    ICONST          reduce using rule 72 (signB -> sign .)
    TRUE            reduce using rule 72 (signB -> sign .)
    FALSE           reduce using rule 72 (signB -> sign .)


state 50

    (102) funccall -> DEF . ID ( funccallB

    ID              shift and go to state 66


state 51

    (68) factor -> signB . constant
    (74) constant -> . FCONST
    (75) constant -> . ICONST
    (76) constant -> . TRUE
    (77) constant -> . FALSE

    FCONST          shift and go to state 68
    ICONST          shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 67

    constant                       shift and go to state 70

state 52

    (69) factor -> ( . superexpression )
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 72
    exp                            shift and go to state 61
    factor                         shift and go to state 55
    expression                     shift and go to state 62
    empty                          shift and go to state 56

state 53

    (78) sign -> + .

    FCONST          reduce using rule 78 (sign -> + .)
    ICONST          reduce using rule 78 (sign -> + .)
    TRUE            reduce using rule 78 (sign -> + .)
    FALSE           reduce using rule 78 (sign -> + .)


state 54

    (79) sign -> - .

    FCONST          reduce using rule 79 (sign -> - .)
    ICONST          reduce using rule 79 (sign -> - .)
    TRUE            reduce using rule 79 (sign -> - .)
    FALSE           reduce using rule 79 (sign -> - .)


state 55

    (64) term -> factor . termB
    (65) termB -> . / term
    (66) termB -> . * term
    (67) termB -> . empty
    (113) empty -> .

    /               shift and go to state 74
    *               shift and go to state 73
    -               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    <               reduce using rule 113 (empty -> .)
    >               reduce using rule 113 (empty -> .)
    =               reduce using rule 113 (empty -> .)
    &               reduce using rule 113 (empty -> .)
    |               reduce using rule 113 (empty -> .)
    ]               reduce using rule 113 (empty -> .)
    )               reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    STRING          reduce using rule 113 (empty -> .)
    DEF             reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)
    ;               reduce using rule 113 (empty -> .)
    ,               reduce using rule 113 (empty -> .)

    termB                          shift and go to state 75
    empty                          shift and go to state 76

state 56

    (73) signB -> empty .

    FCONST          reduce using rule 73 (signB -> empty .)
    ICONST          reduce using rule 73 (signB -> empty .)
    TRUE            reduce using rule 73 (signB -> empty .)
    FALSE           reduce using rule 73 (signB -> empty .)


state 57

    (70) factor -> funccall .

    /               reduce using rule 70 (factor -> funccall .)
    *               reduce using rule 70 (factor -> funccall .)
    -               reduce using rule 70 (factor -> funccall .)
    +               reduce using rule 70 (factor -> funccall .)
    &               reduce using rule 70 (factor -> funccall .)
    |               reduce using rule 70 (factor -> funccall .)
    ]               reduce using rule 70 (factor -> funccall .)
    )               reduce using rule 70 (factor -> funccall .)
    INT             reduce using rule 70 (factor -> funccall .)
    FLOAT           reduce using rule 70 (factor -> funccall .)
    STRING          reduce using rule 70 (factor -> funccall .)
    DEF             reduce using rule 70 (factor -> funccall .)
    MAIN            reduce using rule 70 (factor -> funccall .)
    ;               reduce using rule 70 (factor -> funccall .)
    ,               reduce using rule 70 (factor -> funccall .)
    <               reduce using rule 70 (factor -> funccall .)
    >               reduce using rule 70 (factor -> funccall .)
    =               reduce using rule 70 (factor -> funccall .)


state 58

    (107) dimensions -> [ superexpression . ] dimensionsB

    ]               shift and go to state 77


state 59

    (71) factor -> ID . dimensionsOpt
    (28) dimensionsOpt -> . dimensions
    (29) dimensionsOpt -> . empty
    (107) dimensions -> . [ superexpression ] dimensionsB
    (113) empty -> .

    [               shift and go to state 43
    /               reduce using rule 113 (empty -> .)
    *               reduce using rule 113 (empty -> .)
    -               reduce using rule 113 (empty -> .)
    +               reduce using rule 113 (empty -> .)
    <               reduce using rule 113 (empty -> .)
    >               reduce using rule 113 (empty -> .)
    =               reduce using rule 113 (empty -> .)
    &               reduce using rule 113 (empty -> .)
    |               reduce using rule 113 (empty -> .)
    ]               reduce using rule 113 (empty -> .)
    )               reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    STRING          reduce using rule 113 (empty -> .)
    DEF             reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)
    ;               reduce using rule 113 (empty -> .)
    ,               reduce using rule 113 (empty -> .)

    dimensionsOpt                  shift and go to state 78
    dimensions                     shift and go to state 42
    empty                          shift and go to state 45

state 60

    (60) exp -> term . expB
    (61) expB -> . - exp
    (62) expB -> . + exp
    (63) expB -> . empty
    (113) empty -> .

    -               shift and go to state 80
    +               shift and go to state 79
    <               reduce using rule 113 (empty -> .)
    >               reduce using rule 113 (empty -> .)
    =               reduce using rule 113 (empty -> .)
    &               reduce using rule 113 (empty -> .)
    |               reduce using rule 113 (empty -> .)
    ]               reduce using rule 113 (empty -> .)
    )               reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    STRING          reduce using rule 113 (empty -> .)
    DEF             reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)
    ;               reduce using rule 113 (empty -> .)
    ,               reduce using rule 113 (empty -> .)

    expB                           shift and go to state 81
    empty                          shift and go to state 82

state 61

    (52) expression -> exp . expressionB
    (53) expressionB -> . < exp
    (54) expressionB -> . > exp
    (55) expressionB -> . < > exp
    (56) expressionB -> . = = exp
    (57) expressionB -> . < = exp
    (58) expressionB -> . > = exp
    (59) expressionB -> . empty
    (113) empty -> .

    <               shift and go to state 85
    >               shift and go to state 87
    =               shift and go to state 84
    &               reduce using rule 113 (empty -> .)
    |               reduce using rule 113 (empty -> .)
    ]               reduce using rule 113 (empty -> .)
    )               reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    STRING          reduce using rule 113 (empty -> .)
    DEF             reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)
    ;               reduce using rule 113 (empty -> .)
    ,               reduce using rule 113 (empty -> .)

    expressionB                    shift and go to state 83
    empty                          shift and go to state 86

state 62

    (48) superexpression -> expression . superexpressionB
    (49) superexpressionB -> . & & superexpression
    (50) superexpressionB -> . | | superexpression
    (51) superexpressionB -> . empty
    (113) empty -> .

    &               shift and go to state 88
    |               shift and go to state 90
    ]               reduce using rule 113 (empty -> .)
    )               reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    STRING          reduce using rule 113 (empty -> .)
    DEF             reduce using rule 113 (empty -> .)
    MAIN            reduce using rule 113 (empty -> .)
    ;               reduce using rule 113 (empty -> .)
    ,               reduce using rule 113 (empty -> .)

    empty                          shift and go to state 91
    superexpressionB               shift and go to state 89

state 63

    (26) assign -> ID dimensionsOpt = . superexpression
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 92
    exp                            shift and go to state 61
    factor                         shift and go to state 55
    expression                     shift and go to state 62
    empty                          shift and go to state 56

state 64

    (19) main -> MAIN ( ) . block
    (23) block -> . { instructionsOpt }

    {               shift and go to state 93

    block                          shift and go to state 94

state 65

    (20) func -> DEF returntype ID ( . paramsOpt ) block
    (21) paramsOpt -> . params
    (22) paramsOpt -> . empty
    (110) params -> . type ID paramsB
    (113) empty -> .
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . STRING

    )               reduce using rule 113 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14

    paramsOpt                      shift and go to state 95
    params                         shift and go to state 97
    type                           shift and go to state 98
    empty                          shift and go to state 96

state 66

    (102) funccall -> DEF ID . ( funccallB

    (               shift and go to state 99


state 67

    (77) constant -> FALSE .

    /               reduce using rule 77 (constant -> FALSE .)
    *               reduce using rule 77 (constant -> FALSE .)
    -               reduce using rule 77 (constant -> FALSE .)
    +               reduce using rule 77 (constant -> FALSE .)
    <               reduce using rule 77 (constant -> FALSE .)
    >               reduce using rule 77 (constant -> FALSE .)
    =               reduce using rule 77 (constant -> FALSE .)
    &               reduce using rule 77 (constant -> FALSE .)
    |               reduce using rule 77 (constant -> FALSE .)
    ]               reduce using rule 77 (constant -> FALSE .)
    )               reduce using rule 77 (constant -> FALSE .)
    INT             reduce using rule 77 (constant -> FALSE .)
    FLOAT           reduce using rule 77 (constant -> FALSE .)
    STRING          reduce using rule 77 (constant -> FALSE .)
    DEF             reduce using rule 77 (constant -> FALSE .)
    MAIN            reduce using rule 77 (constant -> FALSE .)
    ;               reduce using rule 77 (constant -> FALSE .)
    ,               reduce using rule 77 (constant -> FALSE .)


state 68

    (74) constant -> FCONST .

    /               reduce using rule 74 (constant -> FCONST .)
    *               reduce using rule 74 (constant -> FCONST .)
    -               reduce using rule 74 (constant -> FCONST .)
    +               reduce using rule 74 (constant -> FCONST .)
    <               reduce using rule 74 (constant -> FCONST .)
    >               reduce using rule 74 (constant -> FCONST .)
    =               reduce using rule 74 (constant -> FCONST .)
    &               reduce using rule 74 (constant -> FCONST .)
    |               reduce using rule 74 (constant -> FCONST .)
    ]               reduce using rule 74 (constant -> FCONST .)
    )               reduce using rule 74 (constant -> FCONST .)
    INT             reduce using rule 74 (constant -> FCONST .)
    FLOAT           reduce using rule 74 (constant -> FCONST .)
    STRING          reduce using rule 74 (constant -> FCONST .)
    DEF             reduce using rule 74 (constant -> FCONST .)
    MAIN            reduce using rule 74 (constant -> FCONST .)
    ;               reduce using rule 74 (constant -> FCONST .)
    ,               reduce using rule 74 (constant -> FCONST .)


state 69

    (75) constant -> ICONST .

    /               reduce using rule 75 (constant -> ICONST .)
    *               reduce using rule 75 (constant -> ICONST .)
    -               reduce using rule 75 (constant -> ICONST .)
    +               reduce using rule 75 (constant -> ICONST .)
    <               reduce using rule 75 (constant -> ICONST .)
    >               reduce using rule 75 (constant -> ICONST .)
    =               reduce using rule 75 (constant -> ICONST .)
    &               reduce using rule 75 (constant -> ICONST .)
    |               reduce using rule 75 (constant -> ICONST .)
    ]               reduce using rule 75 (constant -> ICONST .)
    )               reduce using rule 75 (constant -> ICONST .)
    INT             reduce using rule 75 (constant -> ICONST .)
    FLOAT           reduce using rule 75 (constant -> ICONST .)
    STRING          reduce using rule 75 (constant -> ICONST .)
    DEF             reduce using rule 75 (constant -> ICONST .)
    MAIN            reduce using rule 75 (constant -> ICONST .)
    ;               reduce using rule 75 (constant -> ICONST .)
    ,               reduce using rule 75 (constant -> ICONST .)


state 70

    (68) factor -> signB constant .

    /               reduce using rule 68 (factor -> signB constant .)
    *               reduce using rule 68 (factor -> signB constant .)
    -               reduce using rule 68 (factor -> signB constant .)
    +               reduce using rule 68 (factor -> signB constant .)
    &               reduce using rule 68 (factor -> signB constant .)
    |               reduce using rule 68 (factor -> signB constant .)
    ]               reduce using rule 68 (factor -> signB constant .)
    )               reduce using rule 68 (factor -> signB constant .)
    INT             reduce using rule 68 (factor -> signB constant .)
    FLOAT           reduce using rule 68 (factor -> signB constant .)
    STRING          reduce using rule 68 (factor -> signB constant .)
    DEF             reduce using rule 68 (factor -> signB constant .)
    MAIN            reduce using rule 68 (factor -> signB constant .)
    ;               reduce using rule 68 (factor -> signB constant .)
    ,               reduce using rule 68 (factor -> signB constant .)
    <               reduce using rule 68 (factor -> signB constant .)
    >               reduce using rule 68 (factor -> signB constant .)
    =               reduce using rule 68 (factor -> signB constant .)


state 71

    (76) constant -> TRUE .

    /               reduce using rule 76 (constant -> TRUE .)
    *               reduce using rule 76 (constant -> TRUE .)
    -               reduce using rule 76 (constant -> TRUE .)
    +               reduce using rule 76 (constant -> TRUE .)
    <               reduce using rule 76 (constant -> TRUE .)
    >               reduce using rule 76 (constant -> TRUE .)
    =               reduce using rule 76 (constant -> TRUE .)
    &               reduce using rule 76 (constant -> TRUE .)
    |               reduce using rule 76 (constant -> TRUE .)
    ]               reduce using rule 76 (constant -> TRUE .)
    )               reduce using rule 76 (constant -> TRUE .)
    INT             reduce using rule 76 (constant -> TRUE .)
    FLOAT           reduce using rule 76 (constant -> TRUE .)
    STRING          reduce using rule 76 (constant -> TRUE .)
    DEF             reduce using rule 76 (constant -> TRUE .)
    MAIN            reduce using rule 76 (constant -> TRUE .)
    ;               reduce using rule 76 (constant -> TRUE .)
    ,               reduce using rule 76 (constant -> TRUE .)


state 72

    (69) factor -> ( superexpression . )

    )               shift and go to state 100


state 73

    (66) termB -> * . term
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 101
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    factor                         shift and go to state 55
    empty                          shift and go to state 56

state 74

    (65) termB -> / . term
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 102
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    factor                         shift and go to state 55
    empty                          shift and go to state 56

state 75

    (64) term -> factor termB .

    -               reduce using rule 64 (term -> factor termB .)
    +               reduce using rule 64 (term -> factor termB .)
    &               reduce using rule 64 (term -> factor termB .)
    |               reduce using rule 64 (term -> factor termB .)
    ]               reduce using rule 64 (term -> factor termB .)
    )               reduce using rule 64 (term -> factor termB .)
    INT             reduce using rule 64 (term -> factor termB .)
    FLOAT           reduce using rule 64 (term -> factor termB .)
    STRING          reduce using rule 64 (term -> factor termB .)
    DEF             reduce using rule 64 (term -> factor termB .)
    MAIN            reduce using rule 64 (term -> factor termB .)
    ;               reduce using rule 64 (term -> factor termB .)
    ,               reduce using rule 64 (term -> factor termB .)
    <               reduce using rule 64 (term -> factor termB .)
    >               reduce using rule 64 (term -> factor termB .)
    =               reduce using rule 64 (term -> factor termB .)


state 76

    (67) termB -> empty .

    -               reduce using rule 67 (termB -> empty .)
    +               reduce using rule 67 (termB -> empty .)
    <               reduce using rule 67 (termB -> empty .)
    >               reduce using rule 67 (termB -> empty .)
    =               reduce using rule 67 (termB -> empty .)
    &               reduce using rule 67 (termB -> empty .)
    |               reduce using rule 67 (termB -> empty .)
    ]               reduce using rule 67 (termB -> empty .)
    )               reduce using rule 67 (termB -> empty .)
    INT             reduce using rule 67 (termB -> empty .)
    FLOAT           reduce using rule 67 (termB -> empty .)
    STRING          reduce using rule 67 (termB -> empty .)
    DEF             reduce using rule 67 (termB -> empty .)
    MAIN            reduce using rule 67 (termB -> empty .)
    ;               reduce using rule 67 (termB -> empty .)
    ,               reduce using rule 67 (termB -> empty .)


state 77

    (107) dimensions -> [ superexpression ] . dimensionsB
    (108) dimensionsB -> . [ superexpression ]

    [               shift and go to state 104

    dimensionsB                    shift and go to state 103

state 78

    (71) factor -> ID dimensionsOpt .

    /               reduce using rule 71 (factor -> ID dimensionsOpt .)
    *               reduce using rule 71 (factor -> ID dimensionsOpt .)
    -               reduce using rule 71 (factor -> ID dimensionsOpt .)
    +               reduce using rule 71 (factor -> ID dimensionsOpt .)
    &               reduce using rule 71 (factor -> ID dimensionsOpt .)
    |               reduce using rule 71 (factor -> ID dimensionsOpt .)
    ]               reduce using rule 71 (factor -> ID dimensionsOpt .)
    )               reduce using rule 71 (factor -> ID dimensionsOpt .)
    INT             reduce using rule 71 (factor -> ID dimensionsOpt .)
    FLOAT           reduce using rule 71 (factor -> ID dimensionsOpt .)
    STRING          reduce using rule 71 (factor -> ID dimensionsOpt .)
    DEF             reduce using rule 71 (factor -> ID dimensionsOpt .)
    MAIN            reduce using rule 71 (factor -> ID dimensionsOpt .)
    ;               reduce using rule 71 (factor -> ID dimensionsOpt .)
    ,               reduce using rule 71 (factor -> ID dimensionsOpt .)
    <               reduce using rule 71 (factor -> ID dimensionsOpt .)
    >               reduce using rule 71 (factor -> ID dimensionsOpt .)
    =               reduce using rule 71 (factor -> ID dimensionsOpt .)


state 79

    (62) expB -> + . exp
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    exp                            shift and go to state 105
    factor                         shift and go to state 55
    empty                          shift and go to state 56

state 80

    (61) expB -> - . exp
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    exp                            shift and go to state 106
    factor                         shift and go to state 55
    empty                          shift and go to state 56

state 81

    (60) exp -> term expB .

    <               reduce using rule 60 (exp -> term expB .)
    >               reduce using rule 60 (exp -> term expB .)
    =               reduce using rule 60 (exp -> term expB .)
    &               reduce using rule 60 (exp -> term expB .)
    |               reduce using rule 60 (exp -> term expB .)
    )               reduce using rule 60 (exp -> term expB .)
    ;               reduce using rule 60 (exp -> term expB .)
    ,               reduce using rule 60 (exp -> term expB .)
    ]               reduce using rule 60 (exp -> term expB .)
    INT             reduce using rule 60 (exp -> term expB .)
    FLOAT           reduce using rule 60 (exp -> term expB .)
    STRING          reduce using rule 60 (exp -> term expB .)
    DEF             reduce using rule 60 (exp -> term expB .)
    MAIN            reduce using rule 60 (exp -> term expB .)


state 82

    (63) expB -> empty .

    <               reduce using rule 63 (expB -> empty .)
    >               reduce using rule 63 (expB -> empty .)
    =               reduce using rule 63 (expB -> empty .)
    &               reduce using rule 63 (expB -> empty .)
    |               reduce using rule 63 (expB -> empty .)
    ]               reduce using rule 63 (expB -> empty .)
    )               reduce using rule 63 (expB -> empty .)
    INT             reduce using rule 63 (expB -> empty .)
    FLOAT           reduce using rule 63 (expB -> empty .)
    STRING          reduce using rule 63 (expB -> empty .)
    DEF             reduce using rule 63 (expB -> empty .)
    MAIN            reduce using rule 63 (expB -> empty .)
    ;               reduce using rule 63 (expB -> empty .)
    ,               reduce using rule 63 (expB -> empty .)


state 83

    (52) expression -> exp expressionB .

    &               reduce using rule 52 (expression -> exp expressionB .)
    |               reduce using rule 52 (expression -> exp expressionB .)
    )               reduce using rule 52 (expression -> exp expressionB .)
    ]               reduce using rule 52 (expression -> exp expressionB .)
    ,               reduce using rule 52 (expression -> exp expressionB .)
    INT             reduce using rule 52 (expression -> exp expressionB .)
    FLOAT           reduce using rule 52 (expression -> exp expressionB .)
    STRING          reduce using rule 52 (expression -> exp expressionB .)
    DEF             reduce using rule 52 (expression -> exp expressionB .)
    MAIN            reduce using rule 52 (expression -> exp expressionB .)
    ;               reduce using rule 52 (expression -> exp expressionB .)


state 84

    (56) expressionB -> = . = exp

    =               shift and go to state 107


state 85

    (53) expressionB -> < . exp
    (55) expressionB -> < . > exp
    (57) expressionB -> < . = exp
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    >               shift and go to state 109
    =               shift and go to state 108
    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    exp                            shift and go to state 110
    factor                         shift and go to state 55
    empty                          shift and go to state 56

state 86

    (59) expressionB -> empty .

    &               reduce using rule 59 (expressionB -> empty .)
    |               reduce using rule 59 (expressionB -> empty .)
    ]               reduce using rule 59 (expressionB -> empty .)
    )               reduce using rule 59 (expressionB -> empty .)
    INT             reduce using rule 59 (expressionB -> empty .)
    FLOAT           reduce using rule 59 (expressionB -> empty .)
    STRING          reduce using rule 59 (expressionB -> empty .)
    DEF             reduce using rule 59 (expressionB -> empty .)
    MAIN            reduce using rule 59 (expressionB -> empty .)
    ;               reduce using rule 59 (expressionB -> empty .)
    ,               reduce using rule 59 (expressionB -> empty .)


state 87

    (54) expressionB -> > . exp
    (58) expressionB -> > . = exp
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    =               shift and go to state 112
    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    exp                            shift and go to state 111
    factor                         shift and go to state 55
    empty                          shift and go to state 56

state 88

    (49) superexpressionB -> & . & superexpression

    &               shift and go to state 113


state 89

    (48) superexpression -> expression superexpressionB .

    ;               reduce using rule 48 (superexpression -> expression superexpressionB .)
    ]               reduce using rule 48 (superexpression -> expression superexpressionB .)
    )               reduce using rule 48 (superexpression -> expression superexpressionB .)
    INT             reduce using rule 48 (superexpression -> expression superexpressionB .)
    FLOAT           reduce using rule 48 (superexpression -> expression superexpressionB .)
    STRING          reduce using rule 48 (superexpression -> expression superexpressionB .)
    DEF             reduce using rule 48 (superexpression -> expression superexpressionB .)
    MAIN            reduce using rule 48 (superexpression -> expression superexpressionB .)
    ,               reduce using rule 48 (superexpression -> expression superexpressionB .)


state 90

    (50) superexpressionB -> | . | superexpression

    |               shift and go to state 114


state 91

    (51) superexpressionB -> empty .

    ]               reduce using rule 51 (superexpressionB -> empty .)
    )               reduce using rule 51 (superexpressionB -> empty .)
    INT             reduce using rule 51 (superexpressionB -> empty .)
    FLOAT           reduce using rule 51 (superexpressionB -> empty .)
    STRING          reduce using rule 51 (superexpressionB -> empty .)
    DEF             reduce using rule 51 (superexpressionB -> empty .)
    MAIN            reduce using rule 51 (superexpressionB -> empty .)
    ;               reduce using rule 51 (superexpressionB -> empty .)
    ,               reduce using rule 51 (superexpressionB -> empty .)


state 92

    (26) assign -> ID dimensionsOpt = superexpression .

    INT             reduce using rule 26 (assign -> ID dimensionsOpt = superexpression .)
    FLOAT           reduce using rule 26 (assign -> ID dimensionsOpt = superexpression .)
    STRING          reduce using rule 26 (assign -> ID dimensionsOpt = superexpression .)
    DEF             reduce using rule 26 (assign -> ID dimensionsOpt = superexpression .)
    MAIN            reduce using rule 26 (assign -> ID dimensionsOpt = superexpression .)
    ;               reduce using rule 26 (assign -> ID dimensionsOpt = superexpression .)


state 93

    (23) block -> { . instructionsOpt }
    (24) instructionsOpt -> . instruction instructionsOpt
    (25) instructionsOpt -> . empty
    (33) instruction -> . assignfunccall ;
    (34) instruction -> . output ;
    (35) instruction -> . input ;
    (36) instruction -> . return ;
    (37) instruction -> . declaration ;
    (38) instruction -> . condition
    (39) instruction -> . whileloop
    (40) instruction -> . forloop
    (41) instruction -> . localdirective
    (113) empty -> .
    (42) assignfunccall -> . ID assignfunccallB
    (90) output -> . PRINT ( outputB
    (87) input -> . INPUT ( ID inputB )
    (109) return -> . RETURN superexpression
    (18) declaration -> . type assign
    (30) condition -> . IF ( superexpression ) block else
    (80) whileloop -> . WHILE ( superexpression ) block
    (86) forloop -> . FOR ( assign ; superexpression ; superexpression ) block
    (45) localdirective -> . localvardirective
    (46) localdirective -> . localdecisiondirective
    (47) localdirective -> . localmsgdirective
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . STRING
    (95) localvardirective -> . # localvardirectiveB ID
    (99) localdecisiondirective -> . TRACKDECISION
    (100) localdecisiondirective -> . FORGETDECISION
    (101) localdecisiondirective -> . empty
    (98) localmsgdirective -> . # SHOW STRING

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for TRACKDECISION resolved as shift
  ! shift/reduce conflict for FORGETDECISION resolved as shift
    }               reduce using rule 113 (empty -> .)
    ID              shift and go to state 133
    PRINT           shift and go to state 118
    INPUT           shift and go to state 132
    RETURN          shift and go to state 115
    IF              shift and go to state 135
    WHILE           shift and go to state 117
    FOR             shift and go to state 127
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    #               shift and go to state 120
    TRACKDECISION   shift and go to state 122
    FORGETDECISION  shift and go to state 129

  ! ID              [ reduce using rule 113 (empty -> .) ]
  ! PRINT           [ reduce using rule 113 (empty -> .) ]
  ! INPUT           [ reduce using rule 113 (empty -> .) ]
  ! RETURN          [ reduce using rule 113 (empty -> .) ]
  ! IF              [ reduce using rule 113 (empty -> .) ]
  ! WHILE           [ reduce using rule 113 (empty -> .) ]
  ! FOR             [ reduce using rule 113 (empty -> .) ]
  ! INT             [ reduce using rule 113 (empty -> .) ]
  ! FLOAT           [ reduce using rule 113 (empty -> .) ]
  ! STRING          [ reduce using rule 113 (empty -> .) ]
  ! #               [ reduce using rule 113 (empty -> .) ]
  ! TRACKDECISION   [ reduce using rule 113 (empty -> .) ]
  ! FORGETDECISION  [ reduce using rule 113 (empty -> .) ]

    assignfunccall                 shift and go to state 116
    whileloop                      shift and go to state 119
    localvardirective              shift and go to state 121
    input                          shift and go to state 123
    type                           shift and go to state 16
    empty                          shift and go to state 124
    forloop                        shift and go to state 125
    return                         shift and go to state 126
    instructionsOpt                shift and go to state 128
    localdirective                 shift and go to state 130
    declaration                    shift and go to state 131
    condition                      shift and go to state 134
    instruction                    shift and go to state 136
    localmsgdirective              shift and go to state 137
    localdecisiondirective         shift and go to state 138
    output                         shift and go to state 139

state 94

    (19) main -> MAIN ( ) block .

    DEF             reduce using rule 19 (main -> MAIN ( ) block .)
    $end            reduce using rule 19 (main -> MAIN ( ) block .)


state 95

    (20) func -> DEF returntype ID ( paramsOpt . ) block

    )               shift and go to state 140


state 96

    (22) paramsOpt -> empty .

    )               reduce using rule 22 (paramsOpt -> empty .)


state 97

    (21) paramsOpt -> params .

    )               reduce using rule 21 (paramsOpt -> params .)


state 98

    (110) params -> type . ID paramsB

    ID              shift and go to state 141


state 99

    (102) funccall -> DEF ID ( . funccallB
    (103) funccallB -> . superexpression funccallC
    (104) funccallB -> . )
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    )               shift and go to state 143
    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    funccallB                      shift and go to state 142
    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 144
    exp                            shift and go to state 61
    factor                         shift and go to state 55
    expression                     shift and go to state 62
    empty                          shift and go to state 56

state 100

    (69) factor -> ( superexpression ) .

    /               reduce using rule 69 (factor -> ( superexpression ) .)
    *               reduce using rule 69 (factor -> ( superexpression ) .)
    -               reduce using rule 69 (factor -> ( superexpression ) .)
    +               reduce using rule 69 (factor -> ( superexpression ) .)
    &               reduce using rule 69 (factor -> ( superexpression ) .)
    |               reduce using rule 69 (factor -> ( superexpression ) .)
    ]               reduce using rule 69 (factor -> ( superexpression ) .)
    )               reduce using rule 69 (factor -> ( superexpression ) .)
    INT             reduce using rule 69 (factor -> ( superexpression ) .)
    FLOAT           reduce using rule 69 (factor -> ( superexpression ) .)
    STRING          reduce using rule 69 (factor -> ( superexpression ) .)
    DEF             reduce using rule 69 (factor -> ( superexpression ) .)
    MAIN            reduce using rule 69 (factor -> ( superexpression ) .)
    ;               reduce using rule 69 (factor -> ( superexpression ) .)
    ,               reduce using rule 69 (factor -> ( superexpression ) .)
    <               reduce using rule 69 (factor -> ( superexpression ) .)
    >               reduce using rule 69 (factor -> ( superexpression ) .)
    =               reduce using rule 69 (factor -> ( superexpression ) .)


state 101

    (66) termB -> * term .

    -               reduce using rule 66 (termB -> * term .)
    +               reduce using rule 66 (termB -> * term .)
    <               reduce using rule 66 (termB -> * term .)
    >               reduce using rule 66 (termB -> * term .)
    =               reduce using rule 66 (termB -> * term .)
    &               reduce using rule 66 (termB -> * term .)
    |               reduce using rule 66 (termB -> * term .)
    ]               reduce using rule 66 (termB -> * term .)
    )               reduce using rule 66 (termB -> * term .)
    INT             reduce using rule 66 (termB -> * term .)
    FLOAT           reduce using rule 66 (termB -> * term .)
    STRING          reduce using rule 66 (termB -> * term .)
    DEF             reduce using rule 66 (termB -> * term .)
    MAIN            reduce using rule 66 (termB -> * term .)
    ;               reduce using rule 66 (termB -> * term .)
    ,               reduce using rule 66 (termB -> * term .)


state 102

    (65) termB -> / term .

    -               reduce using rule 65 (termB -> / term .)
    +               reduce using rule 65 (termB -> / term .)
    <               reduce using rule 65 (termB -> / term .)
    >               reduce using rule 65 (termB -> / term .)
    =               reduce using rule 65 (termB -> / term .)
    &               reduce using rule 65 (termB -> / term .)
    |               reduce using rule 65 (termB -> / term .)
    ]               reduce using rule 65 (termB -> / term .)
    )               reduce using rule 65 (termB -> / term .)
    INT             reduce using rule 65 (termB -> / term .)
    FLOAT           reduce using rule 65 (termB -> / term .)
    STRING          reduce using rule 65 (termB -> / term .)
    DEF             reduce using rule 65 (termB -> / term .)
    MAIN            reduce using rule 65 (termB -> / term .)
    ;               reduce using rule 65 (termB -> / term .)
    ,               reduce using rule 65 (termB -> / term .)


state 103

    (107) dimensions -> [ superexpression ] dimensionsB .

    =               reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    /               reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    *               reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    -               reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    +               reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    <               reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    >               reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    &               reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    |               reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    ]               reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    )               reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    INT             reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    FLOAT           reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    STRING          reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    DEF             reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    MAIN            reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    ;               reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)
    ,               reduce using rule 107 (dimensions -> [ superexpression ] dimensionsB .)


state 104

    (108) dimensionsB -> [ . superexpression ]
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 145
    exp                            shift and go to state 61
    factor                         shift and go to state 55
    expression                     shift and go to state 62
    empty                          shift and go to state 56

state 105

    (62) expB -> + exp .

    <               reduce using rule 62 (expB -> + exp .)
    >               reduce using rule 62 (expB -> + exp .)
    =               reduce using rule 62 (expB -> + exp .)
    &               reduce using rule 62 (expB -> + exp .)
    |               reduce using rule 62 (expB -> + exp .)
    ]               reduce using rule 62 (expB -> + exp .)
    )               reduce using rule 62 (expB -> + exp .)
    INT             reduce using rule 62 (expB -> + exp .)
    FLOAT           reduce using rule 62 (expB -> + exp .)
    STRING          reduce using rule 62 (expB -> + exp .)
    DEF             reduce using rule 62 (expB -> + exp .)
    MAIN            reduce using rule 62 (expB -> + exp .)
    ;               reduce using rule 62 (expB -> + exp .)
    ,               reduce using rule 62 (expB -> + exp .)


state 106

    (61) expB -> - exp .

    <               reduce using rule 61 (expB -> - exp .)
    >               reduce using rule 61 (expB -> - exp .)
    =               reduce using rule 61 (expB -> - exp .)
    &               reduce using rule 61 (expB -> - exp .)
    |               reduce using rule 61 (expB -> - exp .)
    ]               reduce using rule 61 (expB -> - exp .)
    )               reduce using rule 61 (expB -> - exp .)
    INT             reduce using rule 61 (expB -> - exp .)
    FLOAT           reduce using rule 61 (expB -> - exp .)
    STRING          reduce using rule 61 (expB -> - exp .)
    DEF             reduce using rule 61 (expB -> - exp .)
    MAIN            reduce using rule 61 (expB -> - exp .)
    ;               reduce using rule 61 (expB -> - exp .)
    ,               reduce using rule 61 (expB -> - exp .)


state 107

    (56) expressionB -> = = . exp
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    exp                            shift and go to state 146
    factor                         shift and go to state 55
    empty                          shift and go to state 56

state 108

    (57) expressionB -> < = . exp
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    exp                            shift and go to state 147
    factor                         shift and go to state 55
    empty                          shift and go to state 56

state 109

    (55) expressionB -> < > . exp
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    exp                            shift and go to state 148
    factor                         shift and go to state 55
    empty                          shift and go to state 56

state 110

    (53) expressionB -> < exp .

    &               reduce using rule 53 (expressionB -> < exp .)
    |               reduce using rule 53 (expressionB -> < exp .)
    ]               reduce using rule 53 (expressionB -> < exp .)
    )               reduce using rule 53 (expressionB -> < exp .)
    INT             reduce using rule 53 (expressionB -> < exp .)
    FLOAT           reduce using rule 53 (expressionB -> < exp .)
    STRING          reduce using rule 53 (expressionB -> < exp .)
    DEF             reduce using rule 53 (expressionB -> < exp .)
    MAIN            reduce using rule 53 (expressionB -> < exp .)
    ;               reduce using rule 53 (expressionB -> < exp .)
    ,               reduce using rule 53 (expressionB -> < exp .)


state 111

    (54) expressionB -> > exp .

    &               reduce using rule 54 (expressionB -> > exp .)
    |               reduce using rule 54 (expressionB -> > exp .)
    ]               reduce using rule 54 (expressionB -> > exp .)
    )               reduce using rule 54 (expressionB -> > exp .)
    INT             reduce using rule 54 (expressionB -> > exp .)
    FLOAT           reduce using rule 54 (expressionB -> > exp .)
    STRING          reduce using rule 54 (expressionB -> > exp .)
    DEF             reduce using rule 54 (expressionB -> > exp .)
    MAIN            reduce using rule 54 (expressionB -> > exp .)
    ;               reduce using rule 54 (expressionB -> > exp .)
    ,               reduce using rule 54 (expressionB -> > exp .)


state 112

    (58) expressionB -> > = . exp
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    exp                            shift and go to state 149
    factor                         shift and go to state 55
    empty                          shift and go to state 56

state 113

    (49) superexpressionB -> & & . superexpression
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 150
    exp                            shift and go to state 61
    factor                         shift and go to state 55
    expression                     shift and go to state 62
    empty                          shift and go to state 56

state 114

    (50) superexpressionB -> | | . superexpression
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 151
    exp                            shift and go to state 61
    factor                         shift and go to state 55
    expression                     shift and go to state 62
    empty                          shift and go to state 56

state 115

    (109) return -> RETURN . superexpression
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 152
    exp                            shift and go to state 61
    factor                         shift and go to state 55
    expression                     shift and go to state 62
    empty                          shift and go to state 56

state 116

    (33) instruction -> assignfunccall . ;

    ;               shift and go to state 153


state 117

    (80) whileloop -> WHILE . ( superexpression ) block

    (               shift and go to state 154


state 118

    (90) output -> PRINT . ( outputB

    (               shift and go to state 155


state 119

    (39) instruction -> whileloop .

    ID              reduce using rule 39 (instruction -> whileloop .)
    PRINT           reduce using rule 39 (instruction -> whileloop .)
    INPUT           reduce using rule 39 (instruction -> whileloop .)
    RETURN          reduce using rule 39 (instruction -> whileloop .)
    IF              reduce using rule 39 (instruction -> whileloop .)
    WHILE           reduce using rule 39 (instruction -> whileloop .)
    FOR             reduce using rule 39 (instruction -> whileloop .)
    INT             reduce using rule 39 (instruction -> whileloop .)
    FLOAT           reduce using rule 39 (instruction -> whileloop .)
    STRING          reduce using rule 39 (instruction -> whileloop .)
    #               reduce using rule 39 (instruction -> whileloop .)
    TRACKDECISION   reduce using rule 39 (instruction -> whileloop .)
    FORGETDECISION  reduce using rule 39 (instruction -> whileloop .)
    }               reduce using rule 39 (instruction -> whileloop .)


state 120

    (95) localvardirective -> # . localvardirectiveB ID
    (98) localmsgdirective -> # . SHOW STRING
    (96) localvardirectiveB -> . TRACK
    (97) localvardirectiveB -> . FORGET

    SHOW            shift and go to state 156
    TRACK           shift and go to state 157
    FORGET          shift and go to state 159

    localvardirectiveB             shift and go to state 158

state 121

    (45) localdirective -> localvardirective .

    ID              reduce using rule 45 (localdirective -> localvardirective .)
    PRINT           reduce using rule 45 (localdirective -> localvardirective .)
    INPUT           reduce using rule 45 (localdirective -> localvardirective .)
    RETURN          reduce using rule 45 (localdirective -> localvardirective .)
    IF              reduce using rule 45 (localdirective -> localvardirective .)
    WHILE           reduce using rule 45 (localdirective -> localvardirective .)
    FOR             reduce using rule 45 (localdirective -> localvardirective .)
    INT             reduce using rule 45 (localdirective -> localvardirective .)
    FLOAT           reduce using rule 45 (localdirective -> localvardirective .)
    STRING          reduce using rule 45 (localdirective -> localvardirective .)
    #               reduce using rule 45 (localdirective -> localvardirective .)
    TRACKDECISION   reduce using rule 45 (localdirective -> localvardirective .)
    FORGETDECISION  reduce using rule 45 (localdirective -> localvardirective .)
    }               reduce using rule 45 (localdirective -> localvardirective .)


state 122

    (99) localdecisiondirective -> TRACKDECISION .

    ID              reduce using rule 99 (localdecisiondirective -> TRACKDECISION .)
    PRINT           reduce using rule 99 (localdecisiondirective -> TRACKDECISION .)
    INPUT           reduce using rule 99 (localdecisiondirective -> TRACKDECISION .)
    RETURN          reduce using rule 99 (localdecisiondirective -> TRACKDECISION .)
    IF              reduce using rule 99 (localdecisiondirective -> TRACKDECISION .)
    WHILE           reduce using rule 99 (localdecisiondirective -> TRACKDECISION .)
    FOR             reduce using rule 99 (localdecisiondirective -> TRACKDECISION .)
    INT             reduce using rule 99 (localdecisiondirective -> TRACKDECISION .)
    FLOAT           reduce using rule 99 (localdecisiondirective -> TRACKDECISION .)
    STRING          reduce using rule 99 (localdecisiondirective -> TRACKDECISION .)
    #               reduce using rule 99 (localdecisiondirective -> TRACKDECISION .)
    TRACKDECISION   reduce using rule 99 (localdecisiondirective -> TRACKDECISION .)
    FORGETDECISION  reduce using rule 99 (localdecisiondirective -> TRACKDECISION .)
    }               reduce using rule 99 (localdecisiondirective -> TRACKDECISION .)


state 123

    (35) instruction -> input . ;

    ;               shift and go to state 160


state 124

    (25) instructionsOpt -> empty .
    (101) localdecisiondirective -> empty .

  ! reduce/reduce conflict for } resolved using rule 25 (instructionsOpt -> empty .)
    }               reduce using rule 25 (instructionsOpt -> empty .)
    ID              reduce using rule 101 (localdecisiondirective -> empty .)
    PRINT           reduce using rule 101 (localdecisiondirective -> empty .)
    INPUT           reduce using rule 101 (localdecisiondirective -> empty .)
    RETURN          reduce using rule 101 (localdecisiondirective -> empty .)
    IF              reduce using rule 101 (localdecisiondirective -> empty .)
    WHILE           reduce using rule 101 (localdecisiondirective -> empty .)
    FOR             reduce using rule 101 (localdecisiondirective -> empty .)
    INT             reduce using rule 101 (localdecisiondirective -> empty .)
    FLOAT           reduce using rule 101 (localdecisiondirective -> empty .)
    STRING          reduce using rule 101 (localdecisiondirective -> empty .)
    #               reduce using rule 101 (localdecisiondirective -> empty .)
    TRACKDECISION   reduce using rule 101 (localdecisiondirective -> empty .)
    FORGETDECISION  reduce using rule 101 (localdecisiondirective -> empty .)

  ! }               [ reduce using rule 101 (localdecisiondirective -> empty .) ]


state 125

    (40) instruction -> forloop .

    ID              reduce using rule 40 (instruction -> forloop .)
    PRINT           reduce using rule 40 (instruction -> forloop .)
    INPUT           reduce using rule 40 (instruction -> forloop .)
    RETURN          reduce using rule 40 (instruction -> forloop .)
    IF              reduce using rule 40 (instruction -> forloop .)
    WHILE           reduce using rule 40 (instruction -> forloop .)
    FOR             reduce using rule 40 (instruction -> forloop .)
    INT             reduce using rule 40 (instruction -> forloop .)
    FLOAT           reduce using rule 40 (instruction -> forloop .)
    STRING          reduce using rule 40 (instruction -> forloop .)
    #               reduce using rule 40 (instruction -> forloop .)
    TRACKDECISION   reduce using rule 40 (instruction -> forloop .)
    FORGETDECISION  reduce using rule 40 (instruction -> forloop .)
    }               reduce using rule 40 (instruction -> forloop .)


state 126

    (36) instruction -> return . ;

    ;               shift and go to state 161


state 127

    (86) forloop -> FOR . ( assign ; superexpression ; superexpression ) block

    (               shift and go to state 162


state 128

    (23) block -> { instructionsOpt . }

    }               shift and go to state 163


state 129

    (100) localdecisiondirective -> FORGETDECISION .

    ID              reduce using rule 100 (localdecisiondirective -> FORGETDECISION .)
    PRINT           reduce using rule 100 (localdecisiondirective -> FORGETDECISION .)
    INPUT           reduce using rule 100 (localdecisiondirective -> FORGETDECISION .)
    RETURN          reduce using rule 100 (localdecisiondirective -> FORGETDECISION .)
    IF              reduce using rule 100 (localdecisiondirective -> FORGETDECISION .)
    WHILE           reduce using rule 100 (localdecisiondirective -> FORGETDECISION .)
    FOR             reduce using rule 100 (localdecisiondirective -> FORGETDECISION .)
    INT             reduce using rule 100 (localdecisiondirective -> FORGETDECISION .)
    FLOAT           reduce using rule 100 (localdecisiondirective -> FORGETDECISION .)
    STRING          reduce using rule 100 (localdecisiondirective -> FORGETDECISION .)
    #               reduce using rule 100 (localdecisiondirective -> FORGETDECISION .)
    TRACKDECISION   reduce using rule 100 (localdecisiondirective -> FORGETDECISION .)
    FORGETDECISION  reduce using rule 100 (localdecisiondirective -> FORGETDECISION .)
    }               reduce using rule 100 (localdecisiondirective -> FORGETDECISION .)


state 130

    (41) instruction -> localdirective .

    ID              reduce using rule 41 (instruction -> localdirective .)
    PRINT           reduce using rule 41 (instruction -> localdirective .)
    INPUT           reduce using rule 41 (instruction -> localdirective .)
    RETURN          reduce using rule 41 (instruction -> localdirective .)
    IF              reduce using rule 41 (instruction -> localdirective .)
    WHILE           reduce using rule 41 (instruction -> localdirective .)
    FOR             reduce using rule 41 (instruction -> localdirective .)
    INT             reduce using rule 41 (instruction -> localdirective .)
    FLOAT           reduce using rule 41 (instruction -> localdirective .)
    STRING          reduce using rule 41 (instruction -> localdirective .)
    #               reduce using rule 41 (instruction -> localdirective .)
    TRACKDECISION   reduce using rule 41 (instruction -> localdirective .)
    FORGETDECISION  reduce using rule 41 (instruction -> localdirective .)
    }               reduce using rule 41 (instruction -> localdirective .)


state 131

    (37) instruction -> declaration . ;

    ;               shift and go to state 164


state 132

    (87) input -> INPUT . ( ID inputB )

    (               shift and go to state 165


state 133

    (42) assignfunccall -> ID . assignfunccallB
    (43) assignfunccallB -> . ( funccallB
    (44) assignfunccallB -> . assignB
    (27) assignB -> . dimensionsOpt = superexpression
    (28) dimensionsOpt -> . dimensions
    (29) dimensionsOpt -> . empty
    (107) dimensions -> . [ superexpression ] dimensionsB
    (113) empty -> .

    (               shift and go to state 167
    [               shift and go to state 43
    =               reduce using rule 113 (empty -> .)

    dimensions                     shift and go to state 42
    assignfunccallB                shift and go to state 166
    assignB                        shift and go to state 168
    dimensionsOpt                  shift and go to state 169
    empty                          shift and go to state 45

state 134

    (38) instruction -> condition .

    ID              reduce using rule 38 (instruction -> condition .)
    PRINT           reduce using rule 38 (instruction -> condition .)
    INPUT           reduce using rule 38 (instruction -> condition .)
    RETURN          reduce using rule 38 (instruction -> condition .)
    IF              reduce using rule 38 (instruction -> condition .)
    WHILE           reduce using rule 38 (instruction -> condition .)
    FOR             reduce using rule 38 (instruction -> condition .)
    INT             reduce using rule 38 (instruction -> condition .)
    FLOAT           reduce using rule 38 (instruction -> condition .)
    STRING          reduce using rule 38 (instruction -> condition .)
    #               reduce using rule 38 (instruction -> condition .)
    TRACKDECISION   reduce using rule 38 (instruction -> condition .)
    FORGETDECISION  reduce using rule 38 (instruction -> condition .)
    }               reduce using rule 38 (instruction -> condition .)


state 135

    (30) condition -> IF . ( superexpression ) block else

    (               shift and go to state 170


state 136

    (24) instructionsOpt -> instruction . instructionsOpt
    (24) instructionsOpt -> . instruction instructionsOpt
    (25) instructionsOpt -> . empty
    (33) instruction -> . assignfunccall ;
    (34) instruction -> . output ;
    (35) instruction -> . input ;
    (36) instruction -> . return ;
    (37) instruction -> . declaration ;
    (38) instruction -> . condition
    (39) instruction -> . whileloop
    (40) instruction -> . forloop
    (41) instruction -> . localdirective
    (113) empty -> .
    (42) assignfunccall -> . ID assignfunccallB
    (90) output -> . PRINT ( outputB
    (87) input -> . INPUT ( ID inputB )
    (109) return -> . RETURN superexpression
    (18) declaration -> . type assign
    (30) condition -> . IF ( superexpression ) block else
    (80) whileloop -> . WHILE ( superexpression ) block
    (86) forloop -> . FOR ( assign ; superexpression ; superexpression ) block
    (45) localdirective -> . localvardirective
    (46) localdirective -> . localdecisiondirective
    (47) localdirective -> . localmsgdirective
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . STRING
    (95) localvardirective -> . # localvardirectiveB ID
    (99) localdecisiondirective -> . TRACKDECISION
    (100) localdecisiondirective -> . FORGETDECISION
    (101) localdecisiondirective -> . empty
    (98) localmsgdirective -> . # SHOW STRING

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for TRACKDECISION resolved as shift
  ! shift/reduce conflict for FORGETDECISION resolved as shift
    }               reduce using rule 113 (empty -> .)
    ID              shift and go to state 133
    PRINT           shift and go to state 118
    INPUT           shift and go to state 132
    RETURN          shift and go to state 115
    IF              shift and go to state 135
    WHILE           shift and go to state 117
    FOR             shift and go to state 127
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    #               shift and go to state 120
    TRACKDECISION   shift and go to state 122
    FORGETDECISION  shift and go to state 129

  ! ID              [ reduce using rule 113 (empty -> .) ]
  ! PRINT           [ reduce using rule 113 (empty -> .) ]
  ! INPUT           [ reduce using rule 113 (empty -> .) ]
  ! RETURN          [ reduce using rule 113 (empty -> .) ]
  ! IF              [ reduce using rule 113 (empty -> .) ]
  ! WHILE           [ reduce using rule 113 (empty -> .) ]
  ! FOR             [ reduce using rule 113 (empty -> .) ]
  ! INT             [ reduce using rule 113 (empty -> .) ]
  ! FLOAT           [ reduce using rule 113 (empty -> .) ]
  ! STRING          [ reduce using rule 113 (empty -> .) ]
  ! #               [ reduce using rule 113 (empty -> .) ]
  ! TRACKDECISION   [ reduce using rule 113 (empty -> .) ]
  ! FORGETDECISION  [ reduce using rule 113 (empty -> .) ]

    assignfunccall                 shift and go to state 116
    whileloop                      shift and go to state 119
    localvardirective              shift and go to state 121
    input                          shift and go to state 123
    type                           shift and go to state 16
    empty                          shift and go to state 124
    forloop                        shift and go to state 125
    return                         shift and go to state 126
    instructionsOpt                shift and go to state 171
    localdirective                 shift and go to state 130
    declaration                    shift and go to state 131
    condition                      shift and go to state 134
    instruction                    shift and go to state 136
    localmsgdirective              shift and go to state 137
    localdecisiondirective         shift and go to state 138
    output                         shift and go to state 139

state 137

    (47) localdirective -> localmsgdirective .

    ID              reduce using rule 47 (localdirective -> localmsgdirective .)
    PRINT           reduce using rule 47 (localdirective -> localmsgdirective .)
    INPUT           reduce using rule 47 (localdirective -> localmsgdirective .)
    RETURN          reduce using rule 47 (localdirective -> localmsgdirective .)
    IF              reduce using rule 47 (localdirective -> localmsgdirective .)
    WHILE           reduce using rule 47 (localdirective -> localmsgdirective .)
    FOR             reduce using rule 47 (localdirective -> localmsgdirective .)
    INT             reduce using rule 47 (localdirective -> localmsgdirective .)
    FLOAT           reduce using rule 47 (localdirective -> localmsgdirective .)
    STRING          reduce using rule 47 (localdirective -> localmsgdirective .)
    #               reduce using rule 47 (localdirective -> localmsgdirective .)
    TRACKDECISION   reduce using rule 47 (localdirective -> localmsgdirective .)
    FORGETDECISION  reduce using rule 47 (localdirective -> localmsgdirective .)
    }               reduce using rule 47 (localdirective -> localmsgdirective .)


state 138

    (46) localdirective -> localdecisiondirective .

    ID              reduce using rule 46 (localdirective -> localdecisiondirective .)
    PRINT           reduce using rule 46 (localdirective -> localdecisiondirective .)
    INPUT           reduce using rule 46 (localdirective -> localdecisiondirective .)
    RETURN          reduce using rule 46 (localdirective -> localdecisiondirective .)
    IF              reduce using rule 46 (localdirective -> localdecisiondirective .)
    WHILE           reduce using rule 46 (localdirective -> localdecisiondirective .)
    FOR             reduce using rule 46 (localdirective -> localdecisiondirective .)
    INT             reduce using rule 46 (localdirective -> localdecisiondirective .)
    FLOAT           reduce using rule 46 (localdirective -> localdecisiondirective .)
    STRING          reduce using rule 46 (localdirective -> localdecisiondirective .)
    #               reduce using rule 46 (localdirective -> localdecisiondirective .)
    TRACKDECISION   reduce using rule 46 (localdirective -> localdecisiondirective .)
    FORGETDECISION  reduce using rule 46 (localdirective -> localdecisiondirective .)
    }               reduce using rule 46 (localdirective -> localdecisiondirective .)


state 139

    (34) instruction -> output . ;

    ;               shift and go to state 172


state 140

    (20) func -> DEF returntype ID ( paramsOpt ) . block
    (23) block -> . { instructionsOpt }

    {               shift and go to state 93

    block                          shift and go to state 173

state 141

    (110) params -> type ID . paramsB
    (111) paramsB -> . , type ID paramsB
    (112) paramsB -> . empty
    (113) empty -> .

    ,               shift and go to state 176
    )               reduce using rule 113 (empty -> .)

    paramsB                        shift and go to state 174
    empty                          shift and go to state 175

state 142

    (102) funccall -> DEF ID ( funccallB .

    /               reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    *               reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    -               reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    +               reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    &               reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    |               reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    ]               reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    )               reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    INT             reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    FLOAT           reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    STRING          reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    DEF             reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    MAIN            reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    ;               reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    ,               reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    <               reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    >               reduce using rule 102 (funccall -> DEF ID ( funccallB .)
    =               reduce using rule 102 (funccall -> DEF ID ( funccallB .)


state 143

    (104) funccallB -> ) .

    ;               reduce using rule 104 (funccallB -> ) .)
    /               reduce using rule 104 (funccallB -> ) .)
    *               reduce using rule 104 (funccallB -> ) .)
    -               reduce using rule 104 (funccallB -> ) .)
    +               reduce using rule 104 (funccallB -> ) .)
    <               reduce using rule 104 (funccallB -> ) .)
    >               reduce using rule 104 (funccallB -> ) .)
    =               reduce using rule 104 (funccallB -> ) .)
    &               reduce using rule 104 (funccallB -> ) .)
    |               reduce using rule 104 (funccallB -> ) .)
    ]               reduce using rule 104 (funccallB -> ) .)
    )               reduce using rule 104 (funccallB -> ) .)
    INT             reduce using rule 104 (funccallB -> ) .)
    FLOAT           reduce using rule 104 (funccallB -> ) .)
    STRING          reduce using rule 104 (funccallB -> ) .)
    DEF             reduce using rule 104 (funccallB -> ) .)
    MAIN            reduce using rule 104 (funccallB -> ) .)
    ,               reduce using rule 104 (funccallB -> ) .)


state 144

    (103) funccallB -> superexpression . funccallC
    (105) funccallC -> . , superexpression funccallC
    (106) funccallC -> . )

    ,               shift and go to state 179
    )               shift and go to state 178

    funccallC                      shift and go to state 177

state 145

    (108) dimensionsB -> [ superexpression . ]

    ]               shift and go to state 180


state 146

    (56) expressionB -> = = exp .

    &               reduce using rule 56 (expressionB -> = = exp .)
    |               reduce using rule 56 (expressionB -> = = exp .)
    ]               reduce using rule 56 (expressionB -> = = exp .)
    )               reduce using rule 56 (expressionB -> = = exp .)
    INT             reduce using rule 56 (expressionB -> = = exp .)
    FLOAT           reduce using rule 56 (expressionB -> = = exp .)
    STRING          reduce using rule 56 (expressionB -> = = exp .)
    DEF             reduce using rule 56 (expressionB -> = = exp .)
    MAIN            reduce using rule 56 (expressionB -> = = exp .)
    ;               reduce using rule 56 (expressionB -> = = exp .)
    ,               reduce using rule 56 (expressionB -> = = exp .)


state 147

    (57) expressionB -> < = exp .

    &               reduce using rule 57 (expressionB -> < = exp .)
    |               reduce using rule 57 (expressionB -> < = exp .)
    ]               reduce using rule 57 (expressionB -> < = exp .)
    )               reduce using rule 57 (expressionB -> < = exp .)
    INT             reduce using rule 57 (expressionB -> < = exp .)
    FLOAT           reduce using rule 57 (expressionB -> < = exp .)
    STRING          reduce using rule 57 (expressionB -> < = exp .)
    DEF             reduce using rule 57 (expressionB -> < = exp .)
    MAIN            reduce using rule 57 (expressionB -> < = exp .)
    ;               reduce using rule 57 (expressionB -> < = exp .)
    ,               reduce using rule 57 (expressionB -> < = exp .)


state 148

    (55) expressionB -> < > exp .

    &               reduce using rule 55 (expressionB -> < > exp .)
    |               reduce using rule 55 (expressionB -> < > exp .)
    ]               reduce using rule 55 (expressionB -> < > exp .)
    )               reduce using rule 55 (expressionB -> < > exp .)
    INT             reduce using rule 55 (expressionB -> < > exp .)
    FLOAT           reduce using rule 55 (expressionB -> < > exp .)
    STRING          reduce using rule 55 (expressionB -> < > exp .)
    DEF             reduce using rule 55 (expressionB -> < > exp .)
    MAIN            reduce using rule 55 (expressionB -> < > exp .)
    ;               reduce using rule 55 (expressionB -> < > exp .)
    ,               reduce using rule 55 (expressionB -> < > exp .)


state 149

    (58) expressionB -> > = exp .

    &               reduce using rule 58 (expressionB -> > = exp .)
    |               reduce using rule 58 (expressionB -> > = exp .)
    ]               reduce using rule 58 (expressionB -> > = exp .)
    )               reduce using rule 58 (expressionB -> > = exp .)
    INT             reduce using rule 58 (expressionB -> > = exp .)
    FLOAT           reduce using rule 58 (expressionB -> > = exp .)
    STRING          reduce using rule 58 (expressionB -> > = exp .)
    DEF             reduce using rule 58 (expressionB -> > = exp .)
    MAIN            reduce using rule 58 (expressionB -> > = exp .)
    ;               reduce using rule 58 (expressionB -> > = exp .)
    ,               reduce using rule 58 (expressionB -> > = exp .)


state 150

    (49) superexpressionB -> & & superexpression .

    ]               reduce using rule 49 (superexpressionB -> & & superexpression .)
    )               reduce using rule 49 (superexpressionB -> & & superexpression .)
    INT             reduce using rule 49 (superexpressionB -> & & superexpression .)
    FLOAT           reduce using rule 49 (superexpressionB -> & & superexpression .)
    STRING          reduce using rule 49 (superexpressionB -> & & superexpression .)
    DEF             reduce using rule 49 (superexpressionB -> & & superexpression .)
    MAIN            reduce using rule 49 (superexpressionB -> & & superexpression .)
    ;               reduce using rule 49 (superexpressionB -> & & superexpression .)
    ,               reduce using rule 49 (superexpressionB -> & & superexpression .)


state 151

    (50) superexpressionB -> | | superexpression .

    ]               reduce using rule 50 (superexpressionB -> | | superexpression .)
    )               reduce using rule 50 (superexpressionB -> | | superexpression .)
    INT             reduce using rule 50 (superexpressionB -> | | superexpression .)
    FLOAT           reduce using rule 50 (superexpressionB -> | | superexpression .)
    STRING          reduce using rule 50 (superexpressionB -> | | superexpression .)
    DEF             reduce using rule 50 (superexpressionB -> | | superexpression .)
    MAIN            reduce using rule 50 (superexpressionB -> | | superexpression .)
    ;               reduce using rule 50 (superexpressionB -> | | superexpression .)
    ,               reduce using rule 50 (superexpressionB -> | | superexpression .)


state 152

    (109) return -> RETURN superexpression .

    ;               reduce using rule 109 (return -> RETURN superexpression .)


state 153

    (33) instruction -> assignfunccall ; .

    ID              reduce using rule 33 (instruction -> assignfunccall ; .)
    PRINT           reduce using rule 33 (instruction -> assignfunccall ; .)
    INPUT           reduce using rule 33 (instruction -> assignfunccall ; .)
    RETURN          reduce using rule 33 (instruction -> assignfunccall ; .)
    IF              reduce using rule 33 (instruction -> assignfunccall ; .)
    WHILE           reduce using rule 33 (instruction -> assignfunccall ; .)
    FOR             reduce using rule 33 (instruction -> assignfunccall ; .)
    INT             reduce using rule 33 (instruction -> assignfunccall ; .)
    FLOAT           reduce using rule 33 (instruction -> assignfunccall ; .)
    STRING          reduce using rule 33 (instruction -> assignfunccall ; .)
    #               reduce using rule 33 (instruction -> assignfunccall ; .)
    TRACKDECISION   reduce using rule 33 (instruction -> assignfunccall ; .)
    FORGETDECISION  reduce using rule 33 (instruction -> assignfunccall ; .)
    }               reduce using rule 33 (instruction -> assignfunccall ; .)


state 154

    (80) whileloop -> WHILE ( . superexpression ) block
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 181
    empty                          shift and go to state 56
    exp                            shift and go to state 61
    factor                         shift and go to state 55
    expression                     shift and go to state 62

state 155

    (90) output -> PRINT ( . outputB
    (91) outputB -> . STRING outputC
    (92) outputB -> . superexpression outputC
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    STRING          shift and go to state 182
    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    factor                         shift and go to state 55
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 183
    exp                            shift and go to state 61
    outputB                        shift and go to state 184
    expression                     shift and go to state 62
    empty                          shift and go to state 56

state 156

    (98) localmsgdirective -> # SHOW . STRING

    STRING          shift and go to state 185


state 157

    (96) localvardirectiveB -> TRACK .

    ID              reduce using rule 96 (localvardirectiveB -> TRACK .)


state 158

    (95) localvardirective -> # localvardirectiveB . ID

    ID              shift and go to state 186


state 159

    (97) localvardirectiveB -> FORGET .

    ID              reduce using rule 97 (localvardirectiveB -> FORGET .)


state 160

    (35) instruction -> input ; .

    ID              reduce using rule 35 (instruction -> input ; .)
    PRINT           reduce using rule 35 (instruction -> input ; .)
    INPUT           reduce using rule 35 (instruction -> input ; .)
    RETURN          reduce using rule 35 (instruction -> input ; .)
    IF              reduce using rule 35 (instruction -> input ; .)
    WHILE           reduce using rule 35 (instruction -> input ; .)
    FOR             reduce using rule 35 (instruction -> input ; .)
    INT             reduce using rule 35 (instruction -> input ; .)
    FLOAT           reduce using rule 35 (instruction -> input ; .)
    STRING          reduce using rule 35 (instruction -> input ; .)
    #               reduce using rule 35 (instruction -> input ; .)
    TRACKDECISION   reduce using rule 35 (instruction -> input ; .)
    FORGETDECISION  reduce using rule 35 (instruction -> input ; .)
    }               reduce using rule 35 (instruction -> input ; .)


state 161

    (36) instruction -> return ; .

    ID              reduce using rule 36 (instruction -> return ; .)
    PRINT           reduce using rule 36 (instruction -> return ; .)
    INPUT           reduce using rule 36 (instruction -> return ; .)
    RETURN          reduce using rule 36 (instruction -> return ; .)
    IF              reduce using rule 36 (instruction -> return ; .)
    WHILE           reduce using rule 36 (instruction -> return ; .)
    FOR             reduce using rule 36 (instruction -> return ; .)
    INT             reduce using rule 36 (instruction -> return ; .)
    FLOAT           reduce using rule 36 (instruction -> return ; .)
    STRING          reduce using rule 36 (instruction -> return ; .)
    #               reduce using rule 36 (instruction -> return ; .)
    TRACKDECISION   reduce using rule 36 (instruction -> return ; .)
    FORGETDECISION  reduce using rule 36 (instruction -> return ; .)
    }               reduce using rule 36 (instruction -> return ; .)


state 162

    (86) forloop -> FOR ( . assign ; superexpression ; superexpression ) block
    (26) assign -> . ID dimensionsOpt = superexpression

    ID              shift and go to state 33

    assign                         shift and go to state 187

state 163

    (23) block -> { instructionsOpt } .

    ID              reduce using rule 23 (block -> { instructionsOpt } .)
    PRINT           reduce using rule 23 (block -> { instructionsOpt } .)
    INPUT           reduce using rule 23 (block -> { instructionsOpt } .)
    RETURN          reduce using rule 23 (block -> { instructionsOpt } .)
    IF              reduce using rule 23 (block -> { instructionsOpt } .)
    WHILE           reduce using rule 23 (block -> { instructionsOpt } .)
    FOR             reduce using rule 23 (block -> { instructionsOpt } .)
    INT             reduce using rule 23 (block -> { instructionsOpt } .)
    FLOAT           reduce using rule 23 (block -> { instructionsOpt } .)
    STRING          reduce using rule 23 (block -> { instructionsOpt } .)
    #               reduce using rule 23 (block -> { instructionsOpt } .)
    TRACKDECISION   reduce using rule 23 (block -> { instructionsOpt } .)
    FORGETDECISION  reduce using rule 23 (block -> { instructionsOpt } .)
    }               reduce using rule 23 (block -> { instructionsOpt } .)
    ELSE            reduce using rule 23 (block -> { instructionsOpt } .)
    DEF             reduce using rule 23 (block -> { instructionsOpt } .)
    $end            reduce using rule 23 (block -> { instructionsOpt } .)
    MAIN            reduce using rule 23 (block -> { instructionsOpt } .)


state 164

    (37) instruction -> declaration ; .

    ID              reduce using rule 37 (instruction -> declaration ; .)
    PRINT           reduce using rule 37 (instruction -> declaration ; .)
    INPUT           reduce using rule 37 (instruction -> declaration ; .)
    RETURN          reduce using rule 37 (instruction -> declaration ; .)
    IF              reduce using rule 37 (instruction -> declaration ; .)
    WHILE           reduce using rule 37 (instruction -> declaration ; .)
    FOR             reduce using rule 37 (instruction -> declaration ; .)
    INT             reduce using rule 37 (instruction -> declaration ; .)
    FLOAT           reduce using rule 37 (instruction -> declaration ; .)
    STRING          reduce using rule 37 (instruction -> declaration ; .)
    #               reduce using rule 37 (instruction -> declaration ; .)
    TRACKDECISION   reduce using rule 37 (instruction -> declaration ; .)
    FORGETDECISION  reduce using rule 37 (instruction -> declaration ; .)
    }               reduce using rule 37 (instruction -> declaration ; .)


state 165

    (87) input -> INPUT ( . ID inputB )

    ID              shift and go to state 188


state 166

    (42) assignfunccall -> ID assignfunccallB .

    ;               reduce using rule 42 (assignfunccall -> ID assignfunccallB .)


state 167

    (43) assignfunccallB -> ( . funccallB
    (103) funccallB -> . superexpression funccallC
    (104) funccallB -> . )
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    )               shift and go to state 143
    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    funccallB                      shift and go to state 189
    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 144
    exp                            shift and go to state 61
    factor                         shift and go to state 55
    expression                     shift and go to state 62
    empty                          shift and go to state 56

state 168

    (44) assignfunccallB -> assignB .

    ;               reduce using rule 44 (assignfunccallB -> assignB .)


state 169

    (27) assignB -> dimensionsOpt . = superexpression

    =               shift and go to state 190


state 170

    (30) condition -> IF ( . superexpression ) block else
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 191
    empty                          shift and go to state 56
    exp                            shift and go to state 61
    factor                         shift and go to state 55
    expression                     shift and go to state 62

state 171

    (24) instructionsOpt -> instruction instructionsOpt .

    }               reduce using rule 24 (instructionsOpt -> instruction instructionsOpt .)


state 172

    (34) instruction -> output ; .

    ID              reduce using rule 34 (instruction -> output ; .)
    PRINT           reduce using rule 34 (instruction -> output ; .)
    INPUT           reduce using rule 34 (instruction -> output ; .)
    RETURN          reduce using rule 34 (instruction -> output ; .)
    IF              reduce using rule 34 (instruction -> output ; .)
    WHILE           reduce using rule 34 (instruction -> output ; .)
    FOR             reduce using rule 34 (instruction -> output ; .)
    INT             reduce using rule 34 (instruction -> output ; .)
    FLOAT           reduce using rule 34 (instruction -> output ; .)
    STRING          reduce using rule 34 (instruction -> output ; .)
    #               reduce using rule 34 (instruction -> output ; .)
    TRACKDECISION   reduce using rule 34 (instruction -> output ; .)
    FORGETDECISION  reduce using rule 34 (instruction -> output ; .)
    }               reduce using rule 34 (instruction -> output ; .)


state 173

    (20) func -> DEF returntype ID ( paramsOpt ) block .

    DEF             reduce using rule 20 (func -> DEF returntype ID ( paramsOpt ) block .)
    $end            reduce using rule 20 (func -> DEF returntype ID ( paramsOpt ) block .)
    MAIN            reduce using rule 20 (func -> DEF returntype ID ( paramsOpt ) block .)


state 174

    (110) params -> type ID paramsB .

    )               reduce using rule 110 (params -> type ID paramsB .)


state 175

    (112) paramsB -> empty .

    )               reduce using rule 112 (paramsB -> empty .)


state 176

    (111) paramsB -> , . type ID paramsB
    (81) type -> . INT
    (82) type -> . FLOAT
    (83) type -> . STRING

    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14

    type                           shift and go to state 192

state 177

    (103) funccallB -> superexpression funccallC .

    ;               reduce using rule 103 (funccallB -> superexpression funccallC .)
    /               reduce using rule 103 (funccallB -> superexpression funccallC .)
    *               reduce using rule 103 (funccallB -> superexpression funccallC .)
    -               reduce using rule 103 (funccallB -> superexpression funccallC .)
    +               reduce using rule 103 (funccallB -> superexpression funccallC .)
    <               reduce using rule 103 (funccallB -> superexpression funccallC .)
    >               reduce using rule 103 (funccallB -> superexpression funccallC .)
    =               reduce using rule 103 (funccallB -> superexpression funccallC .)
    &               reduce using rule 103 (funccallB -> superexpression funccallC .)
    |               reduce using rule 103 (funccallB -> superexpression funccallC .)
    ]               reduce using rule 103 (funccallB -> superexpression funccallC .)
    )               reduce using rule 103 (funccallB -> superexpression funccallC .)
    INT             reduce using rule 103 (funccallB -> superexpression funccallC .)
    FLOAT           reduce using rule 103 (funccallB -> superexpression funccallC .)
    STRING          reduce using rule 103 (funccallB -> superexpression funccallC .)
    DEF             reduce using rule 103 (funccallB -> superexpression funccallC .)
    MAIN            reduce using rule 103 (funccallB -> superexpression funccallC .)
    ,               reduce using rule 103 (funccallB -> superexpression funccallC .)


state 178

    (106) funccallC -> ) .

    /               reduce using rule 106 (funccallC -> ) .)
    *               reduce using rule 106 (funccallC -> ) .)
    -               reduce using rule 106 (funccallC -> ) .)
    +               reduce using rule 106 (funccallC -> ) .)
    <               reduce using rule 106 (funccallC -> ) .)
    >               reduce using rule 106 (funccallC -> ) .)
    =               reduce using rule 106 (funccallC -> ) .)
    &               reduce using rule 106 (funccallC -> ) .)
    |               reduce using rule 106 (funccallC -> ) .)
    ]               reduce using rule 106 (funccallC -> ) .)
    )               reduce using rule 106 (funccallC -> ) .)
    INT             reduce using rule 106 (funccallC -> ) .)
    FLOAT           reduce using rule 106 (funccallC -> ) .)
    STRING          reduce using rule 106 (funccallC -> ) .)
    DEF             reduce using rule 106 (funccallC -> ) .)
    MAIN            reduce using rule 106 (funccallC -> ) .)
    ;               reduce using rule 106 (funccallC -> ) .)
    ,               reduce using rule 106 (funccallC -> ) .)


state 179

    (105) funccallC -> , . superexpression funccallC
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 193
    exp                            shift and go to state 61
    factor                         shift and go to state 55
    expression                     shift and go to state 62
    empty                          shift and go to state 56

state 180

    (108) dimensionsB -> [ superexpression ] .

    =               reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    /               reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    *               reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    -               reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    +               reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    <               reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    >               reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    &               reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    |               reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    ]               reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    )               reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    INT             reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    FLOAT           reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    STRING          reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    DEF             reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    MAIN            reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    ;               reduce using rule 108 (dimensionsB -> [ superexpression ] .)
    ,               reduce using rule 108 (dimensionsB -> [ superexpression ] .)


state 181

    (80) whileloop -> WHILE ( superexpression . ) block

    )               shift and go to state 194


state 182

    (91) outputB -> STRING . outputC
    (93) outputC -> . )
    (94) outputC -> . , outputB

    )               shift and go to state 195
    ,               shift and go to state 197

    outputC                        shift and go to state 196

state 183

    (92) outputB -> superexpression . outputC
    (93) outputC -> . )
    (94) outputC -> . , outputB

    )               shift and go to state 195
    ,               shift and go to state 197

    outputC                        shift and go to state 198

state 184

    (90) output -> PRINT ( outputB .

    ;               reduce using rule 90 (output -> PRINT ( outputB .)


state 185

    (98) localmsgdirective -> # SHOW STRING .

    ID              reduce using rule 98 (localmsgdirective -> # SHOW STRING .)
    PRINT           reduce using rule 98 (localmsgdirective -> # SHOW STRING .)
    INPUT           reduce using rule 98 (localmsgdirective -> # SHOW STRING .)
    RETURN          reduce using rule 98 (localmsgdirective -> # SHOW STRING .)
    IF              reduce using rule 98 (localmsgdirective -> # SHOW STRING .)
    WHILE           reduce using rule 98 (localmsgdirective -> # SHOW STRING .)
    FOR             reduce using rule 98 (localmsgdirective -> # SHOW STRING .)
    INT             reduce using rule 98 (localmsgdirective -> # SHOW STRING .)
    FLOAT           reduce using rule 98 (localmsgdirective -> # SHOW STRING .)
    STRING          reduce using rule 98 (localmsgdirective -> # SHOW STRING .)
    #               reduce using rule 98 (localmsgdirective -> # SHOW STRING .)
    TRACKDECISION   reduce using rule 98 (localmsgdirective -> # SHOW STRING .)
    FORGETDECISION  reduce using rule 98 (localmsgdirective -> # SHOW STRING .)
    }               reduce using rule 98 (localmsgdirective -> # SHOW STRING .)


state 186

    (95) localvardirective -> # localvardirectiveB ID .

    ID              reduce using rule 95 (localvardirective -> # localvardirectiveB ID .)
    PRINT           reduce using rule 95 (localvardirective -> # localvardirectiveB ID .)
    INPUT           reduce using rule 95 (localvardirective -> # localvardirectiveB ID .)
    RETURN          reduce using rule 95 (localvardirective -> # localvardirectiveB ID .)
    IF              reduce using rule 95 (localvardirective -> # localvardirectiveB ID .)
    WHILE           reduce using rule 95 (localvardirective -> # localvardirectiveB ID .)
    FOR             reduce using rule 95 (localvardirective -> # localvardirectiveB ID .)
    INT             reduce using rule 95 (localvardirective -> # localvardirectiveB ID .)
    FLOAT           reduce using rule 95 (localvardirective -> # localvardirectiveB ID .)
    STRING          reduce using rule 95 (localvardirective -> # localvardirectiveB ID .)
    #               reduce using rule 95 (localvardirective -> # localvardirectiveB ID .)
    TRACKDECISION   reduce using rule 95 (localvardirective -> # localvardirectiveB ID .)
    FORGETDECISION  reduce using rule 95 (localvardirective -> # localvardirectiveB ID .)
    }               reduce using rule 95 (localvardirective -> # localvardirectiveB ID .)


state 187

    (86) forloop -> FOR ( assign . ; superexpression ; superexpression ) block

    ;               shift and go to state 199


state 188

    (87) input -> INPUT ( ID . inputB )
    (88) inputB -> . , ID inputB
    (89) inputB -> . empty
    (113) empty -> .

    ,               shift and go to state 200
    )               reduce using rule 113 (empty -> .)

    inputB                         shift and go to state 201
    empty                          shift and go to state 202

state 189

    (43) assignfunccallB -> ( funccallB .

    ;               reduce using rule 43 (assignfunccallB -> ( funccallB .)


state 190

    (27) assignB -> dimensionsOpt = . superexpression
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 203
    exp                            shift and go to state 61
    factor                         shift and go to state 55
    expression                     shift and go to state 62
    empty                          shift and go to state 56

state 191

    (30) condition -> IF ( superexpression . ) block else

    )               shift and go to state 204


state 192

    (111) paramsB -> , type . ID paramsB

    ID              shift and go to state 205


state 193

    (105) funccallC -> , superexpression . funccallC
    (105) funccallC -> . , superexpression funccallC
    (106) funccallC -> . )

    ,               shift and go to state 179
    )               shift and go to state 178

    funccallC                      shift and go to state 206

state 194

    (80) whileloop -> WHILE ( superexpression ) . block
    (23) block -> . { instructionsOpt }

    {               shift and go to state 93

    block                          shift and go to state 207

state 195

    (93) outputC -> ) .

    ;               reduce using rule 93 (outputC -> ) .)


state 196

    (91) outputB -> STRING outputC .

    ;               reduce using rule 91 (outputB -> STRING outputC .)


state 197

    (94) outputC -> , . outputB
    (91) outputB -> . STRING outputC
    (92) outputB -> . superexpression outputC
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    STRING          shift and go to state 182
    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    factor                         shift and go to state 55
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 183
    exp                            shift and go to state 61
    outputB                        shift and go to state 208
    expression                     shift and go to state 62
    empty                          shift and go to state 56

state 198

    (92) outputB -> superexpression outputC .

    ;               reduce using rule 92 (outputB -> superexpression outputC .)


state 199

    (86) forloop -> FOR ( assign ; . superexpression ; superexpression ) block
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 209
    empty                          shift and go to state 56
    exp                            shift and go to state 61
    factor                         shift and go to state 55
    expression                     shift and go to state 62

state 200

    (88) inputB -> , . ID inputB

    ID              shift and go to state 210


state 201

    (87) input -> INPUT ( ID inputB . )

    )               shift and go to state 211


state 202

    (89) inputB -> empty .

    )               reduce using rule 89 (inputB -> empty .)


state 203

    (27) assignB -> dimensionsOpt = superexpression .

    ;               reduce using rule 27 (assignB -> dimensionsOpt = superexpression .)


state 204

    (30) condition -> IF ( superexpression ) . block else
    (23) block -> . { instructionsOpt }

    {               shift and go to state 93

    block                          shift and go to state 212

state 205

    (111) paramsB -> , type ID . paramsB
    (111) paramsB -> . , type ID paramsB
    (112) paramsB -> . empty
    (113) empty -> .

    ,               shift and go to state 176
    )               reduce using rule 113 (empty -> .)

    paramsB                        shift and go to state 213
    empty                          shift and go to state 175

state 206

    (105) funccallC -> , superexpression funccallC .

    /               reduce using rule 105 (funccallC -> , superexpression funccallC .)
    *               reduce using rule 105 (funccallC -> , superexpression funccallC .)
    -               reduce using rule 105 (funccallC -> , superexpression funccallC .)
    +               reduce using rule 105 (funccallC -> , superexpression funccallC .)
    <               reduce using rule 105 (funccallC -> , superexpression funccallC .)
    >               reduce using rule 105 (funccallC -> , superexpression funccallC .)
    =               reduce using rule 105 (funccallC -> , superexpression funccallC .)
    &               reduce using rule 105 (funccallC -> , superexpression funccallC .)
    |               reduce using rule 105 (funccallC -> , superexpression funccallC .)
    ]               reduce using rule 105 (funccallC -> , superexpression funccallC .)
    )               reduce using rule 105 (funccallC -> , superexpression funccallC .)
    INT             reduce using rule 105 (funccallC -> , superexpression funccallC .)
    FLOAT           reduce using rule 105 (funccallC -> , superexpression funccallC .)
    STRING          reduce using rule 105 (funccallC -> , superexpression funccallC .)
    DEF             reduce using rule 105 (funccallC -> , superexpression funccallC .)
    MAIN            reduce using rule 105 (funccallC -> , superexpression funccallC .)
    ;               reduce using rule 105 (funccallC -> , superexpression funccallC .)
    ,               reduce using rule 105 (funccallC -> , superexpression funccallC .)


state 207

    (80) whileloop -> WHILE ( superexpression ) block .

    ID              reduce using rule 80 (whileloop -> WHILE ( superexpression ) block .)
    PRINT           reduce using rule 80 (whileloop -> WHILE ( superexpression ) block .)
    INPUT           reduce using rule 80 (whileloop -> WHILE ( superexpression ) block .)
    RETURN          reduce using rule 80 (whileloop -> WHILE ( superexpression ) block .)
    IF              reduce using rule 80 (whileloop -> WHILE ( superexpression ) block .)
    WHILE           reduce using rule 80 (whileloop -> WHILE ( superexpression ) block .)
    FOR             reduce using rule 80 (whileloop -> WHILE ( superexpression ) block .)
    INT             reduce using rule 80 (whileloop -> WHILE ( superexpression ) block .)
    FLOAT           reduce using rule 80 (whileloop -> WHILE ( superexpression ) block .)
    STRING          reduce using rule 80 (whileloop -> WHILE ( superexpression ) block .)
    #               reduce using rule 80 (whileloop -> WHILE ( superexpression ) block .)
    TRACKDECISION   reduce using rule 80 (whileloop -> WHILE ( superexpression ) block .)
    FORGETDECISION  reduce using rule 80 (whileloop -> WHILE ( superexpression ) block .)
    }               reduce using rule 80 (whileloop -> WHILE ( superexpression ) block .)


state 208

    (94) outputC -> , outputB .

    ;               reduce using rule 94 (outputC -> , outputB .)


state 209

    (86) forloop -> FOR ( assign ; superexpression . ; superexpression ) block

    ;               shift and go to state 214


state 210

    (88) inputB -> , ID . inputB
    (88) inputB -> . , ID inputB
    (89) inputB -> . empty
    (113) empty -> .

    ,               shift and go to state 200
    )               reduce using rule 113 (empty -> .)

    inputB                         shift and go to state 215
    empty                          shift and go to state 202

state 211

    (87) input -> INPUT ( ID inputB ) .

    ;               reduce using rule 87 (input -> INPUT ( ID inputB ) .)


state 212

    (30) condition -> IF ( superexpression ) block . else
    (31) else -> . ELSE block
    (32) else -> . empty
    (113) empty -> .

    ELSE            shift and go to state 218
    ID              reduce using rule 113 (empty -> .)
    PRINT           reduce using rule 113 (empty -> .)
    INPUT           reduce using rule 113 (empty -> .)
    RETURN          reduce using rule 113 (empty -> .)
    IF              reduce using rule 113 (empty -> .)
    WHILE           reduce using rule 113 (empty -> .)
    FOR             reduce using rule 113 (empty -> .)
    INT             reduce using rule 113 (empty -> .)
    FLOAT           reduce using rule 113 (empty -> .)
    STRING          reduce using rule 113 (empty -> .)
    #               reduce using rule 113 (empty -> .)
    TRACKDECISION   reduce using rule 113 (empty -> .)
    FORGETDECISION  reduce using rule 113 (empty -> .)
    }               reduce using rule 113 (empty -> .)

    empty                          shift and go to state 217
    else                           shift and go to state 216

state 213

    (111) paramsB -> , type ID paramsB .

    )               reduce using rule 111 (paramsB -> , type ID paramsB .)


state 214

    (86) forloop -> FOR ( assign ; superexpression ; . superexpression ) block
    (48) superexpression -> . expression superexpressionB
    (52) expression -> . exp expressionB
    (60) exp -> . term expB
    (64) term -> . factor termB
    (68) factor -> . signB constant
    (69) factor -> . ( superexpression )
    (70) factor -> . funccall
    (71) factor -> . ID dimensionsOpt
    (72) signB -> . sign
    (73) signB -> . empty
    (102) funccall -> . DEF ID ( funccallB
    (78) sign -> . +
    (79) sign -> . -
    (113) empty -> .

    (               shift and go to state 52
    ID              shift and go to state 59
    DEF             shift and go to state 50
    +               shift and go to state 53
    -               shift and go to state 54
    FCONST          reduce using rule 113 (empty -> .)
    ICONST          reduce using rule 113 (empty -> .)
    TRUE            reduce using rule 113 (empty -> .)
    FALSE           reduce using rule 113 (empty -> .)

    term                           shift and go to state 60
    funccall                       shift and go to state 57
    signB                          shift and go to state 51
    sign                           shift and go to state 49
    superexpression                shift and go to state 219
    empty                          shift and go to state 56
    exp                            shift and go to state 61
    factor                         shift and go to state 55
    expression                     shift and go to state 62

state 215

    (88) inputB -> , ID inputB .

    )               reduce using rule 88 (inputB -> , ID inputB .)


state 216

    (30) condition -> IF ( superexpression ) block else .

    ID              reduce using rule 30 (condition -> IF ( superexpression ) block else .)
    PRINT           reduce using rule 30 (condition -> IF ( superexpression ) block else .)
    INPUT           reduce using rule 30 (condition -> IF ( superexpression ) block else .)
    RETURN          reduce using rule 30 (condition -> IF ( superexpression ) block else .)
    IF              reduce using rule 30 (condition -> IF ( superexpression ) block else .)
    WHILE           reduce using rule 30 (condition -> IF ( superexpression ) block else .)
    FOR             reduce using rule 30 (condition -> IF ( superexpression ) block else .)
    INT             reduce using rule 30 (condition -> IF ( superexpression ) block else .)
    FLOAT           reduce using rule 30 (condition -> IF ( superexpression ) block else .)
    STRING          reduce using rule 30 (condition -> IF ( superexpression ) block else .)
    #               reduce using rule 30 (condition -> IF ( superexpression ) block else .)
    TRACKDECISION   reduce using rule 30 (condition -> IF ( superexpression ) block else .)
    FORGETDECISION  reduce using rule 30 (condition -> IF ( superexpression ) block else .)
    }               reduce using rule 30 (condition -> IF ( superexpression ) block else .)


state 217

    (32) else -> empty .

    ID              reduce using rule 32 (else -> empty .)
    PRINT           reduce using rule 32 (else -> empty .)
    INPUT           reduce using rule 32 (else -> empty .)
    RETURN          reduce using rule 32 (else -> empty .)
    IF              reduce using rule 32 (else -> empty .)
    WHILE           reduce using rule 32 (else -> empty .)
    FOR             reduce using rule 32 (else -> empty .)
    INT             reduce using rule 32 (else -> empty .)
    FLOAT           reduce using rule 32 (else -> empty .)
    STRING          reduce using rule 32 (else -> empty .)
    #               reduce using rule 32 (else -> empty .)
    TRACKDECISION   reduce using rule 32 (else -> empty .)
    FORGETDECISION  reduce using rule 32 (else -> empty .)
    }               reduce using rule 32 (else -> empty .)


state 218

    (31) else -> ELSE . block
    (23) block -> . { instructionsOpt }

    {               shift and go to state 93

    block                          shift and go to state 220

state 219

    (86) forloop -> FOR ( assign ; superexpression ; superexpression . ) block

    )               shift and go to state 221


state 220

    (31) else -> ELSE block .

    ID              reduce using rule 31 (else -> ELSE block .)
    PRINT           reduce using rule 31 (else -> ELSE block .)
    INPUT           reduce using rule 31 (else -> ELSE block .)
    RETURN          reduce using rule 31 (else -> ELSE block .)
    IF              reduce using rule 31 (else -> ELSE block .)
    WHILE           reduce using rule 31 (else -> ELSE block .)
    FOR             reduce using rule 31 (else -> ELSE block .)
    INT             reduce using rule 31 (else -> ELSE block .)
    FLOAT           reduce using rule 31 (else -> ELSE block .)
    STRING          reduce using rule 31 (else -> ELSE block .)
    #               reduce using rule 31 (else -> ELSE block .)
    TRACKDECISION   reduce using rule 31 (else -> ELSE block .)
    FORGETDECISION  reduce using rule 31 (else -> ELSE block .)
    }               reduce using rule 31 (else -> ELSE block .)


state 221

    (86) forloop -> FOR ( assign ; superexpression ; superexpression ) . block
    (23) block -> . { instructionsOpt }

    {               shift and go to state 93

    block                          shift and go to state 222

state 222

    (86) forloop -> FOR ( assign ; superexpression ; superexpression ) block .

    ID              reduce using rule 86 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    PRINT           reduce using rule 86 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    INPUT           reduce using rule 86 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    RETURN          reduce using rule 86 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    IF              reduce using rule 86 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    WHILE           reduce using rule 86 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    FOR             reduce using rule 86 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    INT             reduce using rule 86 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    FLOAT           reduce using rule 86 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    STRING          reduce using rule 86 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    #               reduce using rule 86 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    TRACKDECISION   reduce using rule 86 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    FORGETDECISION  reduce using rule 86 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    }               reduce using rule 86 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 93 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 93 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 93 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 93 resolved as shift
WARNING: shift/reduce conflict for IF in state 93 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 93 resolved as shift
WARNING: shift/reduce conflict for FOR in state 93 resolved as shift
WARNING: shift/reduce conflict for INT in state 93 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 93 resolved as shift
WARNING: shift/reduce conflict for STRING in state 93 resolved as shift
WARNING: shift/reduce conflict for # in state 93 resolved as shift
WARNING: shift/reduce conflict for TRACKDECISION in state 93 resolved as shift
WARNING: shift/reduce conflict for FORGETDECISION in state 93 resolved as shift
WARNING: shift/reduce conflict for ID in state 136 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 136 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 136 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 136 resolved as shift
WARNING: shift/reduce conflict for IF in state 136 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 136 resolved as shift
WARNING: shift/reduce conflict for FOR in state 136 resolved as shift
WARNING: shift/reduce conflict for INT in state 136 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 136 resolved as shift
WARNING: shift/reduce conflict for STRING in state 136 resolved as shift
WARNING: shift/reduce conflict for # in state 136 resolved as shift
WARNING: shift/reduce conflict for TRACKDECISION in state 136 resolved as shift
WARNING: shift/reduce conflict for FORGETDECISION in state 136 resolved as shift
WARNING: reduce/reduce conflict in state 124 resolved using rule (instructionsOpt -> empty)
WARNING: rejected rule (localdecisiondirective -> empty) in state 124
