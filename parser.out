Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL

Grammar

Rule 0     S' -> program
Rule 1     program -> config body
Rule 2     config -> configdirective config
Rule 3     config -> empty
Rule 4     configdirective -> # VARS = options
Rule 5     configdirective -> # DECISIONS = options
Rule 6     configdirective -> # COMPLEXITY = optionsyesno
Rule 7     options -> SOME
Rule 8     options -> ALL
Rule 9     options -> MOST
Rule 10    options -> NONE
Rule 11    optionsyesno -> YES
Rule 12    optionsyesno -> NO
Rule 13    body -> declarations func funcB main func funcB
Rule 14    funcB -> func
Rule 15    funcB -> empty
Rule 16    declarations -> type declarationsB ; declarations
Rule 17    declarations -> empty
Rule 18    declarationsB -> ID dimensionB constantB declarationsC
Rule 19    declarationsC -> , declarationsB
Rule 20    declarationsC -> empty
Rule 21    dimensionB -> dimension
Rule 22    dimensionB -> empty
Rule 23    constantB -> = constant
Rule 24    constantB -> empty
Rule 25    main -> MAIN ( ) block
Rule 26    func -> DEF returntype ID ( optionalparams ) block
Rule 27    func -> empty
Rule 28    optionalparams -> params
Rule 29    optionalparams -> empty
Rule 30    block -> { instruction }
Rule 31    asign -> ID dimensionB = superexpression
Rule 32    condition -> IF ( superexpression ) block else
Rule 33    else -> ELSE block
Rule 34    else -> empty
Rule 35    instruction -> asign ; instructionB
Rule 36    instruction -> condition ; instructionB
Rule 37    instruction -> output ; instructionB
Rule 38    instruction -> whileloop instructionB
Rule 39    instruction -> forloop instructionB
Rule 40    instruction -> input ; instructionB
Rule 41    instruction -> funccall ; instructionB
Rule 42    instruction -> return ; instructionB
Rule 43    instruction -> localdirective instructionB
Rule 44    instruction -> declarations instructionB
Rule 45    instructionB -> instruction
Rule 46    instructionB -> empty
Rule 47    localdirective -> localvardirective
Rule 48    localdirective -> localdecisiondirective
Rule 49    localdirective -> localmsgdirective
Rule 50    superexpression -> expression superexpressionB
Rule 51    superexpressionB -> & & superexpression
Rule 52    superexpressionB -> | | superexpression
Rule 53    superexpressionB -> empty
Rule 54    expression -> exp expressionB
Rule 55    expressionB -> < exp
Rule 56    expressionB -> > exp
Rule 57    expressionB -> < > exp
Rule 58    expressionB -> = = exp
Rule 59    expressionB -> < = exp
Rule 60    expressionB -> > = exp
Rule 61    expressionB -> empty
Rule 62    exp -> term expB
Rule 63    expB -> - exp
Rule 64    expB -> + exp
Rule 65    expB -> empty
Rule 66    term -> factor termB
Rule 67    termB -> / term
Rule 68    termB -> * term
Rule 69    termB -> empty
Rule 70    factor -> signB constant
Rule 71    factor -> ( superexpression )
Rule 72    factor -> funccall
Rule 73    factor -> ID dimensionB
Rule 74    signB -> sign
Rule 75    signB -> empty
Rule 76    constant -> FCONST
Rule 77    constant -> ICONST
Rule 78    constant -> TRUE
Rule 79    constant -> FALSE
Rule 80    sign -> +
Rule 81    sign -> -
Rule 82    whileloop -> WHILE ( superexpression ) block
Rule 83    type -> INT
Rule 84    type -> FLOAT
Rule 85    type -> STRING
Rule 86    returntype -> VOID
Rule 87    returntype -> type
Rule 88    forloop -> FOR ( asign ; superexpression ; superexpression ) block
Rule 89    input -> INPUT ( ID inputB )
Rule 90    inputB -> , ID inputB
Rule 91    inputB -> empty
Rule 92    output -> PRINT ( outputB
Rule 93    outputB -> STRING outputC
Rule 94    outputB -> superexpression outputC
Rule 95    outputC -> )
Rule 96    outputC -> , outputB
Rule 97    localvardirective -> # localvardirectiveB ID
Rule 98    localvardirectiveB -> TRACK
Rule 99    localvardirectiveB -> FORGET
Rule 100   localmsgdirective -> # SHOW STRING
Rule 101   localdecisiondirective -> # localdecisiondirectiveB DECISION
Rule 102   localdecisiondirective -> empty
Rule 103   localdecisiondirectiveB -> TRACK
Rule 104   localdecisiondirectiveB -> FORGET
Rule 105   funccall -> ID ( funccallB )
Rule 106   funccallB -> superexpression funccallC
Rule 107   funccallB -> empty
Rule 108   funccallC -> , superexpression funccallC
Rule 109   funccallC -> empty
Rule 110   dimension -> [ superexpression ] dimensionB
Rule 111   return -> RETURN superexpression
Rule 112   params -> type ID paramsB
Rule 113   paramsB -> , type ID paramsB
Rule 114   paramsB -> empty
Rule 115   empty -> <empty>

Terminals, with rules where they appear

#                    : 4 5 6 97 100 101
&                    : 51 51
(                    : 25 26 32 71 82 88 89 92 105
)                    : 25 26 32 71 82 88 89 95 105
*                    : 68
+                    : 64 80
,                    : 19 90 96 108 113
-                    : 63 81
/                    : 67
;                    : 16 35 36 37 40 41 42 88 88
<                    : 55 57 59
=                    : 4 5 6 23 31 58 58 59 60
>                    : 56 57 60
ALL                  : 8
BOOL                 : 
COMPLEXITY           : 6
DECISION             : 101
DECISIONS            : 5
DEF                  : 26
ELSE                 : 33
FALSE                : 79
FCONST               : 76
FLOAT                : 84
FOR                  : 88
FORGET               : 99 104
ICONST               : 77
ID                   : 18 26 31 73 89 90 97 105 112 113
IF                   : 32
INPUT                : 89
INT                  : 83
MAIN                 : 25
MOST                 : 9
NO                   : 12
NONE                 : 10
PRINT                : 92
RETURN               : 111
SHOW                 : 100
SOME                 : 7
STRING               : 85 93 100
TRACK                : 98 103
TRUE                 : 78
VARS                 : 4
VOID                 : 86
WHILE                : 82
YES                  : 11
[                    : 110
]                    : 110
error                : 
{                    : 30
|                    : 52 52
}                    : 30

Nonterminals, with rules where they appear

asign                : 35 88
block                : 25 26 32 33 82 88
body                 : 1
condition            : 36
config               : 1 2
configdirective      : 2
constant             : 23 70
constantB            : 18
declarations         : 13 16 44
declarationsB        : 16 19
declarationsC        : 18
dimension            : 21
dimensionB           : 18 31 73 110
else                 : 32
empty                : 3 15 17 20 22 24 27 29 34 46 53 61 65 69 75 91 102 107 109 114
exp                  : 54 55 56 57 58 59 60 63 64
expB                 : 62
expression           : 50
expressionB          : 54
factor               : 66
forloop              : 39
func                 : 13 13 14
funcB                : 13 13
funccall             : 41 72
funccallB            : 105
funccallC            : 106 108
input                : 40
inputB               : 89 90
instruction          : 30 45
instructionB         : 35 36 37 38 39 40 41 42 43 44
localdecisiondirective : 48
localdecisiondirectiveB : 101
localdirective       : 43
localmsgdirective    : 49
localvardirective    : 47
localvardirectiveB   : 97
main                 : 13
optionalparams       : 26
options              : 4 5
optionsyesno         : 6
output               : 37
outputB              : 92 96
outputC              : 93 94
params               : 28
paramsB              : 112 113
program              : 0
return               : 42
returntype           : 26
sign                 : 74
signB                : 70
superexpression      : 31 32 51 52 71 82 88 88 94 106 108 110 111
superexpressionB     : 50
term                 : 62 67 68
termB                : 66
type                 : 16 87 112 113
whileloop            : 38

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . config body
    (2) config -> . configdirective config
    (3) config -> . empty
    (4) configdirective -> . # VARS = options
    (5) configdirective -> . # DECISIONS = options
    (6) configdirective -> . # COMPLEXITY = optionsyesno
    (115) empty -> .

    #               shift and go to state 1
    INT             reduce using rule 115 (empty -> .)
    FLOAT           reduce using rule 115 (empty -> .)
    STRING          reduce using rule 115 (empty -> .)
    DEF             reduce using rule 115 (empty -> .)
    MAIN            reduce using rule 115 (empty -> .)

    configdirective                shift and go to state 2
    program                        shift and go to state 3
    config                         shift and go to state 4
    empty                          shift and go to state 5

state 1

    (4) configdirective -> # . VARS = options
    (5) configdirective -> # . DECISIONS = options
    (6) configdirective -> # . COMPLEXITY = optionsyesno

    VARS            shift and go to state 6
    DECISIONS       shift and go to state 8
    COMPLEXITY      shift and go to state 7


state 2

    (2) config -> configdirective . config
    (2) config -> . configdirective config
    (3) config -> . empty
    (4) configdirective -> . # VARS = options
    (5) configdirective -> . # DECISIONS = options
    (6) configdirective -> . # COMPLEXITY = optionsyesno
    (115) empty -> .

    #               shift and go to state 1
    INT             reduce using rule 115 (empty -> .)
    FLOAT           reduce using rule 115 (empty -> .)
    STRING          reduce using rule 115 (empty -> .)
    DEF             reduce using rule 115 (empty -> .)
    MAIN            reduce using rule 115 (empty -> .)

    config                         shift and go to state 9
    empty                          shift and go to state 5
    configdirective                shift and go to state 2

state 3

    (0) S' -> program .



state 4

    (1) program -> config . body
    (13) body -> . declarations func funcB main func funcB
    (16) declarations -> . type declarationsB ; declarations
    (17) declarations -> . empty
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING
    (115) empty -> .

    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12
    DEF             reduce using rule 115 (empty -> .)
    MAIN            reduce using rule 115 (empty -> .)

    body                           shift and go to state 10
    type                           shift and go to state 14
    declarations                   shift and go to state 15
    empty                          shift and go to state 16

state 5

    (3) config -> empty .

    INT             reduce using rule 3 (config -> empty .)
    FLOAT           reduce using rule 3 (config -> empty .)
    STRING          reduce using rule 3 (config -> empty .)
    DEF             reduce using rule 3 (config -> empty .)
    MAIN            reduce using rule 3 (config -> empty .)


state 6

    (4) configdirective -> # VARS . = options

    =               shift and go to state 17


state 7

    (6) configdirective -> # COMPLEXITY . = optionsyesno

    =               shift and go to state 18


state 8

    (5) configdirective -> # DECISIONS . = options

    =               shift and go to state 19


state 9

    (2) config -> configdirective config .

    INT             reduce using rule 2 (config -> configdirective config .)
    FLOAT           reduce using rule 2 (config -> configdirective config .)
    STRING          reduce using rule 2 (config -> configdirective config .)
    DEF             reduce using rule 2 (config -> configdirective config .)
    MAIN            reduce using rule 2 (config -> configdirective config .)


state 10

    (1) program -> config body .

    $end            reduce using rule 1 (program -> config body .)


state 11

    (84) type -> FLOAT .

    ID              reduce using rule 84 (type -> FLOAT .)


state 12

    (85) type -> STRING .

    ID              reduce using rule 85 (type -> STRING .)


state 13

    (83) type -> INT .

    ID              reduce using rule 83 (type -> INT .)


state 14

    (16) declarations -> type . declarationsB ; declarations
    (18) declarationsB -> . ID dimensionB constantB declarationsC

    ID              shift and go to state 20

    declarationsB                  shift and go to state 21

state 15

    (13) body -> declarations . func funcB main func funcB
    (26) func -> . DEF returntype ID ( optionalparams ) block
    (27) func -> . empty
    (115) empty -> .

  ! shift/reduce conflict for DEF resolved as shift
    DEF             shift and go to state 24
    MAIN            reduce using rule 115 (empty -> .)

  ! DEF             [ reduce using rule 115 (empty -> .) ]

    empty                          shift and go to state 22
    func                           shift and go to state 23

state 16

    (17) declarations -> empty .

    DEF             reduce using rule 17 (declarations -> empty .)
    MAIN            reduce using rule 17 (declarations -> empty .)
    ID              reduce using rule 17 (declarations -> empty .)
    IF              reduce using rule 17 (declarations -> empty .)
    PRINT           reduce using rule 17 (declarations -> empty .)
    WHILE           reduce using rule 17 (declarations -> empty .)
    FOR             reduce using rule 17 (declarations -> empty .)
    INPUT           reduce using rule 17 (declarations -> empty .)
    RETURN          reduce using rule 17 (declarations -> empty .)
    #               reduce using rule 17 (declarations -> empty .)
    INT             reduce using rule 17 (declarations -> empty .)
    FLOAT           reduce using rule 17 (declarations -> empty .)
    STRING          reduce using rule 17 (declarations -> empty .)
    }               reduce using rule 17 (declarations -> empty .)


state 17

    (4) configdirective -> # VARS = . options
    (7) options -> . SOME
    (8) options -> . ALL
    (9) options -> . MOST
    (10) options -> . NONE

    SOME            shift and go to state 27
    ALL             shift and go to state 25
    MOST            shift and go to state 28
    NONE            shift and go to state 26

    options                        shift and go to state 29

state 18

    (6) configdirective -> # COMPLEXITY = . optionsyesno
    (11) optionsyesno -> . YES
    (12) optionsyesno -> . NO

    YES             shift and go to state 32
    NO              shift and go to state 31

    optionsyesno                   shift and go to state 30

state 19

    (5) configdirective -> # DECISIONS = . options
    (7) options -> . SOME
    (8) options -> . ALL
    (9) options -> . MOST
    (10) options -> . NONE

    SOME            shift and go to state 27
    ALL             shift and go to state 25
    MOST            shift and go to state 28
    NONE            shift and go to state 26

    options                        shift and go to state 33

state 20

    (18) declarationsB -> ID . dimensionB constantB declarationsC
    (21) dimensionB -> . dimension
    (22) dimensionB -> . empty
    (110) dimension -> . [ superexpression ] dimensionB
    (115) empty -> .

    [               shift and go to state 35
    =               reduce using rule 115 (empty -> .)
    ,               reduce using rule 115 (empty -> .)
    ;               reduce using rule 115 (empty -> .)

    dimensionB                     shift and go to state 34
    dimension                      shift and go to state 36
    empty                          shift and go to state 37

state 21

    (16) declarations -> type declarationsB . ; declarations

    ;               shift and go to state 38


state 22

    (27) func -> empty .

    DEF             reduce using rule 27 (func -> empty .)
    MAIN            reduce using rule 27 (func -> empty .)
    $end            reduce using rule 27 (func -> empty .)


state 23

    (13) body -> declarations func . funcB main func funcB
    (14) funcB -> . func
    (15) funcB -> . empty
    (26) func -> . DEF returntype ID ( optionalparams ) block
    (27) func -> . empty
    (115) empty -> .

    DEF             shift and go to state 24
    MAIN            reduce using rule 115 (empty -> .)

    funcB                          shift and go to state 39
    func                           shift and go to state 41
    empty                          shift and go to state 40

state 24

    (26) func -> DEF . returntype ID ( optionalparams ) block
    (86) returntype -> . VOID
    (87) returntype -> . type
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING

    VOID            shift and go to state 42
    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12

    returntype                     shift and go to state 43
    type                           shift and go to state 44

state 25

    (8) options -> ALL .

    #               reduce using rule 8 (options -> ALL .)
    INT             reduce using rule 8 (options -> ALL .)
    FLOAT           reduce using rule 8 (options -> ALL .)
    STRING          reduce using rule 8 (options -> ALL .)
    DEF             reduce using rule 8 (options -> ALL .)
    MAIN            reduce using rule 8 (options -> ALL .)


state 26

    (10) options -> NONE .

    #               reduce using rule 10 (options -> NONE .)
    INT             reduce using rule 10 (options -> NONE .)
    FLOAT           reduce using rule 10 (options -> NONE .)
    STRING          reduce using rule 10 (options -> NONE .)
    DEF             reduce using rule 10 (options -> NONE .)
    MAIN            reduce using rule 10 (options -> NONE .)


state 27

    (7) options -> SOME .

    #               reduce using rule 7 (options -> SOME .)
    INT             reduce using rule 7 (options -> SOME .)
    FLOAT           reduce using rule 7 (options -> SOME .)
    STRING          reduce using rule 7 (options -> SOME .)
    DEF             reduce using rule 7 (options -> SOME .)
    MAIN            reduce using rule 7 (options -> SOME .)


state 28

    (9) options -> MOST .

    #               reduce using rule 9 (options -> MOST .)
    INT             reduce using rule 9 (options -> MOST .)
    FLOAT           reduce using rule 9 (options -> MOST .)
    STRING          reduce using rule 9 (options -> MOST .)
    DEF             reduce using rule 9 (options -> MOST .)
    MAIN            reduce using rule 9 (options -> MOST .)


state 29

    (4) configdirective -> # VARS = options .

    #               reduce using rule 4 (configdirective -> # VARS = options .)
    INT             reduce using rule 4 (configdirective -> # VARS = options .)
    FLOAT           reduce using rule 4 (configdirective -> # VARS = options .)
    STRING          reduce using rule 4 (configdirective -> # VARS = options .)
    DEF             reduce using rule 4 (configdirective -> # VARS = options .)
    MAIN            reduce using rule 4 (configdirective -> # VARS = options .)


state 30

    (6) configdirective -> # COMPLEXITY = optionsyesno .

    #               reduce using rule 6 (configdirective -> # COMPLEXITY = optionsyesno .)
    INT             reduce using rule 6 (configdirective -> # COMPLEXITY = optionsyesno .)
    FLOAT           reduce using rule 6 (configdirective -> # COMPLEXITY = optionsyesno .)
    STRING          reduce using rule 6 (configdirective -> # COMPLEXITY = optionsyesno .)
    DEF             reduce using rule 6 (configdirective -> # COMPLEXITY = optionsyesno .)
    MAIN            reduce using rule 6 (configdirective -> # COMPLEXITY = optionsyesno .)


state 31

    (12) optionsyesno -> NO .

    #               reduce using rule 12 (optionsyesno -> NO .)
    INT             reduce using rule 12 (optionsyesno -> NO .)
    FLOAT           reduce using rule 12 (optionsyesno -> NO .)
    STRING          reduce using rule 12 (optionsyesno -> NO .)
    DEF             reduce using rule 12 (optionsyesno -> NO .)
    MAIN            reduce using rule 12 (optionsyesno -> NO .)


state 32

    (11) optionsyesno -> YES .

    #               reduce using rule 11 (optionsyesno -> YES .)
    INT             reduce using rule 11 (optionsyesno -> YES .)
    FLOAT           reduce using rule 11 (optionsyesno -> YES .)
    STRING          reduce using rule 11 (optionsyesno -> YES .)
    DEF             reduce using rule 11 (optionsyesno -> YES .)
    MAIN            reduce using rule 11 (optionsyesno -> YES .)


state 33

    (5) configdirective -> # DECISIONS = options .

    #               reduce using rule 5 (configdirective -> # DECISIONS = options .)
    INT             reduce using rule 5 (configdirective -> # DECISIONS = options .)
    FLOAT           reduce using rule 5 (configdirective -> # DECISIONS = options .)
    STRING          reduce using rule 5 (configdirective -> # DECISIONS = options .)
    DEF             reduce using rule 5 (configdirective -> # DECISIONS = options .)
    MAIN            reduce using rule 5 (configdirective -> # DECISIONS = options .)


state 34

    (18) declarationsB -> ID dimensionB . constantB declarationsC
    (23) constantB -> . = constant
    (24) constantB -> . empty
    (115) empty -> .

    =               shift and go to state 46
    ,               reduce using rule 115 (empty -> .)
    ;               reduce using rule 115 (empty -> .)

    empty                          shift and go to state 47
    constantB                      shift and go to state 45

state 35

    (110) dimension -> [ . superexpression ] dimensionB
    (50) superexpression -> . expression superexpressionB
    (54) expression -> . exp expressionB
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    superexpression                shift and go to state 55
    exp                            shift and go to state 59
    factor                         shift and go to state 52
    sign                           shift and go to state 56
    expression                     shift and go to state 60
    empty                          shift and go to state 53

state 36

    (21) dimensionB -> dimension .

    =               reduce using rule 21 (dimensionB -> dimension .)
    ,               reduce using rule 21 (dimensionB -> dimension .)
    ;               reduce using rule 21 (dimensionB -> dimension .)
    /               reduce using rule 21 (dimensionB -> dimension .)
    *               reduce using rule 21 (dimensionB -> dimension .)
    -               reduce using rule 21 (dimensionB -> dimension .)
    +               reduce using rule 21 (dimensionB -> dimension .)
    <               reduce using rule 21 (dimensionB -> dimension .)
    >               reduce using rule 21 (dimensionB -> dimension .)
    &               reduce using rule 21 (dimensionB -> dimension .)
    |               reduce using rule 21 (dimensionB -> dimension .)
    ]               reduce using rule 21 (dimensionB -> dimension .)
    )               reduce using rule 21 (dimensionB -> dimension .)


state 37

    (22) dimensionB -> empty .

    =               reduce using rule 22 (dimensionB -> empty .)
    ,               reduce using rule 22 (dimensionB -> empty .)
    ;               reduce using rule 22 (dimensionB -> empty .)
    /               reduce using rule 22 (dimensionB -> empty .)
    *               reduce using rule 22 (dimensionB -> empty .)
    -               reduce using rule 22 (dimensionB -> empty .)
    +               reduce using rule 22 (dimensionB -> empty .)
    <               reduce using rule 22 (dimensionB -> empty .)
    >               reduce using rule 22 (dimensionB -> empty .)
    &               reduce using rule 22 (dimensionB -> empty .)
    |               reduce using rule 22 (dimensionB -> empty .)
    ]               reduce using rule 22 (dimensionB -> empty .)
    )               reduce using rule 22 (dimensionB -> empty .)


state 38

    (16) declarations -> type declarationsB ; . declarations
    (16) declarations -> . type declarationsB ; declarations
    (17) declarations -> . empty
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING
    (115) empty -> .

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12
    DEF             reduce using rule 115 (empty -> .)
    MAIN            reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    PRINT           reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FOR             reduce using rule 115 (empty -> .)
    INPUT           reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    #               reduce using rule 115 (empty -> .)
    }               reduce using rule 115 (empty -> .)

  ! INT             [ reduce using rule 115 (empty -> .) ]
  ! FLOAT           [ reduce using rule 115 (empty -> .) ]
  ! STRING          [ reduce using rule 115 (empty -> .) ]

    declarations                   shift and go to state 61
    type                           shift and go to state 14
    empty                          shift and go to state 16

state 39

    (13) body -> declarations func funcB . main func funcB
    (25) main -> . MAIN ( ) block

    MAIN            shift and go to state 62

    main                           shift and go to state 63

state 40

    (15) funcB -> empty .
    (27) func -> empty .

  ! reduce/reduce conflict for $end resolved using rule 15 (funcB -> empty .)
  ! reduce/reduce conflict for MAIN resolved using rule 15 (funcB -> empty .)
    MAIN            reduce using rule 15 (funcB -> empty .)
    $end            reduce using rule 15 (funcB -> empty .)

  ! $end            [ reduce using rule 27 (func -> empty .) ]
  ! MAIN            [ reduce using rule 27 (func -> empty .) ]


state 41

    (14) funcB -> func .

    MAIN            reduce using rule 14 (funcB -> func .)
    $end            reduce using rule 14 (funcB -> func .)


state 42

    (86) returntype -> VOID .

    ID              reduce using rule 86 (returntype -> VOID .)


state 43

    (26) func -> DEF returntype . ID ( optionalparams ) block

    ID              shift and go to state 64


state 44

    (87) returntype -> type .

    ID              reduce using rule 87 (returntype -> type .)


state 45

    (18) declarationsB -> ID dimensionB constantB . declarationsC
    (19) declarationsC -> . , declarationsB
    (20) declarationsC -> . empty
    (115) empty -> .

    ,               shift and go to state 65
    ;               reduce using rule 115 (empty -> .)

    declarationsC                  shift and go to state 66
    empty                          shift and go to state 67

state 46

    (23) constantB -> = . constant
    (76) constant -> . FCONST
    (77) constant -> . ICONST
    (78) constant -> . TRUE
    (79) constant -> . FALSE

    FCONST          shift and go to state 69
    ICONST          shift and go to state 71
    TRUE            shift and go to state 70
    FALSE           shift and go to state 72

    constant                       shift and go to state 68

state 47

    (24) constantB -> empty .

    ,               reduce using rule 24 (constantB -> empty .)
    ;               reduce using rule 24 (constantB -> empty .)


state 48

    (70) factor -> signB . constant
    (76) constant -> . FCONST
    (77) constant -> . ICONST
    (78) constant -> . TRUE
    (79) constant -> . FALSE

    FCONST          shift and go to state 69
    ICONST          shift and go to state 71
    TRUE            shift and go to state 70
    FALSE           shift and go to state 72

    constant                       shift and go to state 73

state 49

    (71) factor -> ( . superexpression )
    (50) superexpression -> . expression superexpressionB
    (54) expression -> . exp expressionB
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    superexpression                shift and go to state 74
    exp                            shift and go to state 59
    factor                         shift and go to state 52
    sign                           shift and go to state 56
    expression                     shift and go to state 60
    empty                          shift and go to state 53

state 50

    (80) sign -> + .

    FCONST          reduce using rule 80 (sign -> + .)
    ICONST          reduce using rule 80 (sign -> + .)
    TRUE            reduce using rule 80 (sign -> + .)
    FALSE           reduce using rule 80 (sign -> + .)


state 51

    (81) sign -> - .

    FCONST          reduce using rule 81 (sign -> - .)
    ICONST          reduce using rule 81 (sign -> - .)
    TRUE            reduce using rule 81 (sign -> - .)
    FALSE           reduce using rule 81 (sign -> - .)


state 52

    (66) term -> factor . termB
    (67) termB -> . / term
    (68) termB -> . * term
    (69) termB -> . empty
    (115) empty -> .

    /               shift and go to state 76
    *               shift and go to state 75
    -               reduce using rule 115 (empty -> .)
    +               reduce using rule 115 (empty -> .)
    <               reduce using rule 115 (empty -> .)
    >               reduce using rule 115 (empty -> .)
    =               reduce using rule 115 (empty -> .)
    &               reduce using rule 115 (empty -> .)
    |               reduce using rule 115 (empty -> .)
    ]               reduce using rule 115 (empty -> .)
    )               reduce using rule 115 (empty -> .)
    ,               reduce using rule 115 (empty -> .)
    ;               reduce using rule 115 (empty -> .)

    termB                          shift and go to state 77
    empty                          shift and go to state 78

state 53

    (75) signB -> empty .

    FCONST          reduce using rule 75 (signB -> empty .)
    ICONST          reduce using rule 75 (signB -> empty .)
    TRUE            reduce using rule 75 (signB -> empty .)
    FALSE           reduce using rule 75 (signB -> empty .)


state 54

    (72) factor -> funccall .

    /               reduce using rule 72 (factor -> funccall .)
    *               reduce using rule 72 (factor -> funccall .)
    -               reduce using rule 72 (factor -> funccall .)
    +               reduce using rule 72 (factor -> funccall .)
    <               reduce using rule 72 (factor -> funccall .)
    >               reduce using rule 72 (factor -> funccall .)
    =               reduce using rule 72 (factor -> funccall .)
    &               reduce using rule 72 (factor -> funccall .)
    |               reduce using rule 72 (factor -> funccall .)
    ]               reduce using rule 72 (factor -> funccall .)
    )               reduce using rule 72 (factor -> funccall .)
    ,               reduce using rule 72 (factor -> funccall .)
    ;               reduce using rule 72 (factor -> funccall .)


state 55

    (110) dimension -> [ superexpression . ] dimensionB

    ]               shift and go to state 79


state 56

    (74) signB -> sign .

    FCONST          reduce using rule 74 (signB -> sign .)
    ICONST          reduce using rule 74 (signB -> sign .)
    TRUE            reduce using rule 74 (signB -> sign .)
    FALSE           reduce using rule 74 (signB -> sign .)


state 57

    (73) factor -> ID . dimensionB
    (105) funccall -> ID . ( funccallB )
    (21) dimensionB -> . dimension
    (22) dimensionB -> . empty
    (110) dimension -> . [ superexpression ] dimensionB
    (115) empty -> .

    (               shift and go to state 80
    [               shift and go to state 35
    /               reduce using rule 115 (empty -> .)
    *               reduce using rule 115 (empty -> .)
    -               reduce using rule 115 (empty -> .)
    +               reduce using rule 115 (empty -> .)
    <               reduce using rule 115 (empty -> .)
    >               reduce using rule 115 (empty -> .)
    =               reduce using rule 115 (empty -> .)
    &               reduce using rule 115 (empty -> .)
    |               reduce using rule 115 (empty -> .)
    ]               reduce using rule 115 (empty -> .)
    )               reduce using rule 115 (empty -> .)
    ,               reduce using rule 115 (empty -> .)
    ;               reduce using rule 115 (empty -> .)

    dimensionB                     shift and go to state 81
    dimension                      shift and go to state 36
    empty                          shift and go to state 37

state 58

    (62) exp -> term . expB
    (63) expB -> . - exp
    (64) expB -> . + exp
    (65) expB -> . empty
    (115) empty -> .

    -               shift and go to state 83
    +               shift and go to state 82
    <               reduce using rule 115 (empty -> .)
    >               reduce using rule 115 (empty -> .)
    =               reduce using rule 115 (empty -> .)
    &               reduce using rule 115 (empty -> .)
    |               reduce using rule 115 (empty -> .)
    ]               reduce using rule 115 (empty -> .)
    )               reduce using rule 115 (empty -> .)
    ,               reduce using rule 115 (empty -> .)
    ;               reduce using rule 115 (empty -> .)

    expB                           shift and go to state 84
    empty                          shift and go to state 85

state 59

    (54) expression -> exp . expressionB
    (55) expressionB -> . < exp
    (56) expressionB -> . > exp
    (57) expressionB -> . < > exp
    (58) expressionB -> . = = exp
    (59) expressionB -> . < = exp
    (60) expressionB -> . > = exp
    (61) expressionB -> . empty
    (115) empty -> .

    <               shift and go to state 88
    >               shift and go to state 90
    =               shift and go to state 87
    &               reduce using rule 115 (empty -> .)
    |               reduce using rule 115 (empty -> .)
    ]               reduce using rule 115 (empty -> .)
    )               reduce using rule 115 (empty -> .)
    ,               reduce using rule 115 (empty -> .)
    ;               reduce using rule 115 (empty -> .)

    expressionB                    shift and go to state 86
    empty                          shift and go to state 89

state 60

    (50) superexpression -> expression . superexpressionB
    (51) superexpressionB -> . & & superexpression
    (52) superexpressionB -> . | | superexpression
    (53) superexpressionB -> . empty
    (115) empty -> .

    &               shift and go to state 91
    |               shift and go to state 93
    ]               reduce using rule 115 (empty -> .)
    )               reduce using rule 115 (empty -> .)
    ,               reduce using rule 115 (empty -> .)
    ;               reduce using rule 115 (empty -> .)

    empty                          shift and go to state 94
    superexpressionB               shift and go to state 92

state 61

    (16) declarations -> type declarationsB ; declarations .

    ID              reduce using rule 16 (declarations -> type declarationsB ; declarations .)
    IF              reduce using rule 16 (declarations -> type declarationsB ; declarations .)
    PRINT           reduce using rule 16 (declarations -> type declarationsB ; declarations .)
    WHILE           reduce using rule 16 (declarations -> type declarationsB ; declarations .)
    FOR             reduce using rule 16 (declarations -> type declarationsB ; declarations .)
    INPUT           reduce using rule 16 (declarations -> type declarationsB ; declarations .)
    RETURN          reduce using rule 16 (declarations -> type declarationsB ; declarations .)
    #               reduce using rule 16 (declarations -> type declarationsB ; declarations .)
    INT             reduce using rule 16 (declarations -> type declarationsB ; declarations .)
    FLOAT           reduce using rule 16 (declarations -> type declarationsB ; declarations .)
    STRING          reduce using rule 16 (declarations -> type declarationsB ; declarations .)
    }               reduce using rule 16 (declarations -> type declarationsB ; declarations .)
    DEF             reduce using rule 16 (declarations -> type declarationsB ; declarations .)
    MAIN            reduce using rule 16 (declarations -> type declarationsB ; declarations .)


state 62

    (25) main -> MAIN . ( ) block

    (               shift and go to state 95


state 63

    (13) body -> declarations func funcB main . func funcB
    (26) func -> . DEF returntype ID ( optionalparams ) block
    (27) func -> . empty
    (115) empty -> .

  ! shift/reduce conflict for DEF resolved as shift
    DEF             shift and go to state 24
    $end            reduce using rule 115 (empty -> .)

  ! DEF             [ reduce using rule 115 (empty -> .) ]

    empty                          shift and go to state 22
    func                           shift and go to state 96

state 64

    (26) func -> DEF returntype ID . ( optionalparams ) block

    (               shift and go to state 97


state 65

    (19) declarationsC -> , . declarationsB
    (18) declarationsB -> . ID dimensionB constantB declarationsC

    ID              shift and go to state 20

    declarationsB                  shift and go to state 98

state 66

    (18) declarationsB -> ID dimensionB constantB declarationsC .

    ;               reduce using rule 18 (declarationsB -> ID dimensionB constantB declarationsC .)


state 67

    (20) declarationsC -> empty .

    ;               reduce using rule 20 (declarationsC -> empty .)


state 68

    (23) constantB -> = constant .

    ,               reduce using rule 23 (constantB -> = constant .)
    ;               reduce using rule 23 (constantB -> = constant .)


state 69

    (76) constant -> FCONST .

    /               reduce using rule 76 (constant -> FCONST .)
    *               reduce using rule 76 (constant -> FCONST .)
    -               reduce using rule 76 (constant -> FCONST .)
    +               reduce using rule 76 (constant -> FCONST .)
    <               reduce using rule 76 (constant -> FCONST .)
    >               reduce using rule 76 (constant -> FCONST .)
    =               reduce using rule 76 (constant -> FCONST .)
    &               reduce using rule 76 (constant -> FCONST .)
    |               reduce using rule 76 (constant -> FCONST .)
    ]               reduce using rule 76 (constant -> FCONST .)
    )               reduce using rule 76 (constant -> FCONST .)
    ,               reduce using rule 76 (constant -> FCONST .)
    ;               reduce using rule 76 (constant -> FCONST .)


state 70

    (78) constant -> TRUE .

    /               reduce using rule 78 (constant -> TRUE .)
    *               reduce using rule 78 (constant -> TRUE .)
    -               reduce using rule 78 (constant -> TRUE .)
    +               reduce using rule 78 (constant -> TRUE .)
    <               reduce using rule 78 (constant -> TRUE .)
    >               reduce using rule 78 (constant -> TRUE .)
    =               reduce using rule 78 (constant -> TRUE .)
    &               reduce using rule 78 (constant -> TRUE .)
    |               reduce using rule 78 (constant -> TRUE .)
    ]               reduce using rule 78 (constant -> TRUE .)
    )               reduce using rule 78 (constant -> TRUE .)
    ,               reduce using rule 78 (constant -> TRUE .)
    ;               reduce using rule 78 (constant -> TRUE .)


state 71

    (77) constant -> ICONST .

    /               reduce using rule 77 (constant -> ICONST .)
    *               reduce using rule 77 (constant -> ICONST .)
    -               reduce using rule 77 (constant -> ICONST .)
    +               reduce using rule 77 (constant -> ICONST .)
    <               reduce using rule 77 (constant -> ICONST .)
    >               reduce using rule 77 (constant -> ICONST .)
    =               reduce using rule 77 (constant -> ICONST .)
    &               reduce using rule 77 (constant -> ICONST .)
    |               reduce using rule 77 (constant -> ICONST .)
    ]               reduce using rule 77 (constant -> ICONST .)
    )               reduce using rule 77 (constant -> ICONST .)
    ,               reduce using rule 77 (constant -> ICONST .)
    ;               reduce using rule 77 (constant -> ICONST .)


state 72

    (79) constant -> FALSE .

    /               reduce using rule 79 (constant -> FALSE .)
    *               reduce using rule 79 (constant -> FALSE .)
    -               reduce using rule 79 (constant -> FALSE .)
    +               reduce using rule 79 (constant -> FALSE .)
    <               reduce using rule 79 (constant -> FALSE .)
    >               reduce using rule 79 (constant -> FALSE .)
    =               reduce using rule 79 (constant -> FALSE .)
    &               reduce using rule 79 (constant -> FALSE .)
    |               reduce using rule 79 (constant -> FALSE .)
    ]               reduce using rule 79 (constant -> FALSE .)
    )               reduce using rule 79 (constant -> FALSE .)
    ,               reduce using rule 79 (constant -> FALSE .)
    ;               reduce using rule 79 (constant -> FALSE .)


state 73

    (70) factor -> signB constant .

    /               reduce using rule 70 (factor -> signB constant .)
    *               reduce using rule 70 (factor -> signB constant .)
    -               reduce using rule 70 (factor -> signB constant .)
    +               reduce using rule 70 (factor -> signB constant .)
    <               reduce using rule 70 (factor -> signB constant .)
    >               reduce using rule 70 (factor -> signB constant .)
    =               reduce using rule 70 (factor -> signB constant .)
    &               reduce using rule 70 (factor -> signB constant .)
    |               reduce using rule 70 (factor -> signB constant .)
    ]               reduce using rule 70 (factor -> signB constant .)
    )               reduce using rule 70 (factor -> signB constant .)
    ,               reduce using rule 70 (factor -> signB constant .)
    ;               reduce using rule 70 (factor -> signB constant .)


state 74

    (71) factor -> ( superexpression . )

    )               shift and go to state 99


state 75

    (68) termB -> * . term
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 100
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    sign                           shift and go to state 56
    factor                         shift and go to state 52
    empty                          shift and go to state 53

state 76

    (67) termB -> / . term
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 101
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    sign                           shift and go to state 56
    factor                         shift and go to state 52
    empty                          shift and go to state 53

state 77

    (66) term -> factor termB .

    -               reduce using rule 66 (term -> factor termB .)
    +               reduce using rule 66 (term -> factor termB .)
    <               reduce using rule 66 (term -> factor termB .)
    >               reduce using rule 66 (term -> factor termB .)
    =               reduce using rule 66 (term -> factor termB .)
    &               reduce using rule 66 (term -> factor termB .)
    |               reduce using rule 66 (term -> factor termB .)
    ]               reduce using rule 66 (term -> factor termB .)
    )               reduce using rule 66 (term -> factor termB .)
    ,               reduce using rule 66 (term -> factor termB .)
    ;               reduce using rule 66 (term -> factor termB .)


state 78

    (69) termB -> empty .

    -               reduce using rule 69 (termB -> empty .)
    +               reduce using rule 69 (termB -> empty .)
    <               reduce using rule 69 (termB -> empty .)
    >               reduce using rule 69 (termB -> empty .)
    =               reduce using rule 69 (termB -> empty .)
    &               reduce using rule 69 (termB -> empty .)
    |               reduce using rule 69 (termB -> empty .)
    ]               reduce using rule 69 (termB -> empty .)
    )               reduce using rule 69 (termB -> empty .)
    ,               reduce using rule 69 (termB -> empty .)
    ;               reduce using rule 69 (termB -> empty .)


state 79

    (110) dimension -> [ superexpression ] . dimensionB
    (21) dimensionB -> . dimension
    (22) dimensionB -> . empty
    (110) dimension -> . [ superexpression ] dimensionB
    (115) empty -> .

    [               shift and go to state 35
    =               reduce using rule 115 (empty -> .)
    ,               reduce using rule 115 (empty -> .)
    ;               reduce using rule 115 (empty -> .)
    /               reduce using rule 115 (empty -> .)
    *               reduce using rule 115 (empty -> .)
    -               reduce using rule 115 (empty -> .)
    +               reduce using rule 115 (empty -> .)
    <               reduce using rule 115 (empty -> .)
    >               reduce using rule 115 (empty -> .)
    &               reduce using rule 115 (empty -> .)
    |               reduce using rule 115 (empty -> .)
    ]               reduce using rule 115 (empty -> .)
    )               reduce using rule 115 (empty -> .)

    dimensionB                     shift and go to state 102
    dimension                      shift and go to state 36
    empty                          shift and go to state 37

state 80

    (105) funccall -> ID ( . funccallB )
    (106) funccallB -> . superexpression funccallC
    (107) funccallB -> . empty
    (50) superexpression -> . expression superexpressionB
    (115) empty -> .
    (54) expression -> . exp expressionB
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -

    )               reduce using rule 115 (empty -> .)
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)
    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51

    funccallB                      shift and go to state 103
    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    superexpression                shift and go to state 105
    exp                            shift and go to state 59
    factor                         shift and go to state 52
    sign                           shift and go to state 56
    expression                     shift and go to state 60
    empty                          shift and go to state 104

state 81

    (73) factor -> ID dimensionB .

    /               reduce using rule 73 (factor -> ID dimensionB .)
    *               reduce using rule 73 (factor -> ID dimensionB .)
    -               reduce using rule 73 (factor -> ID dimensionB .)
    +               reduce using rule 73 (factor -> ID dimensionB .)
    <               reduce using rule 73 (factor -> ID dimensionB .)
    >               reduce using rule 73 (factor -> ID dimensionB .)
    =               reduce using rule 73 (factor -> ID dimensionB .)
    &               reduce using rule 73 (factor -> ID dimensionB .)
    |               reduce using rule 73 (factor -> ID dimensionB .)
    ]               reduce using rule 73 (factor -> ID dimensionB .)
    )               reduce using rule 73 (factor -> ID dimensionB .)
    ,               reduce using rule 73 (factor -> ID dimensionB .)
    ;               reduce using rule 73 (factor -> ID dimensionB .)


state 82

    (64) expB -> + . exp
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    sign                           shift and go to state 56
    exp                            shift and go to state 106
    factor                         shift and go to state 52
    empty                          shift and go to state 53

state 83

    (63) expB -> - . exp
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    sign                           shift and go to state 56
    exp                            shift and go to state 107
    factor                         shift and go to state 52
    empty                          shift and go to state 53

state 84

    (62) exp -> term expB .

    <               reduce using rule 62 (exp -> term expB .)
    >               reduce using rule 62 (exp -> term expB .)
    =               reduce using rule 62 (exp -> term expB .)
    &               reduce using rule 62 (exp -> term expB .)
    |               reduce using rule 62 (exp -> term expB .)
    ]               reduce using rule 62 (exp -> term expB .)
    )               reduce using rule 62 (exp -> term expB .)
    ,               reduce using rule 62 (exp -> term expB .)
    ;               reduce using rule 62 (exp -> term expB .)


state 85

    (65) expB -> empty .

    <               reduce using rule 65 (expB -> empty .)
    >               reduce using rule 65 (expB -> empty .)
    =               reduce using rule 65 (expB -> empty .)
    &               reduce using rule 65 (expB -> empty .)
    |               reduce using rule 65 (expB -> empty .)
    ]               reduce using rule 65 (expB -> empty .)
    )               reduce using rule 65 (expB -> empty .)
    ,               reduce using rule 65 (expB -> empty .)
    ;               reduce using rule 65 (expB -> empty .)


state 86

    (54) expression -> exp expressionB .

    &               reduce using rule 54 (expression -> exp expressionB .)
    |               reduce using rule 54 (expression -> exp expressionB .)
    ]               reduce using rule 54 (expression -> exp expressionB .)
    )               reduce using rule 54 (expression -> exp expressionB .)
    ,               reduce using rule 54 (expression -> exp expressionB .)
    ;               reduce using rule 54 (expression -> exp expressionB .)


state 87

    (58) expressionB -> = . = exp

    =               shift and go to state 108


state 88

    (55) expressionB -> < . exp
    (57) expressionB -> < . > exp
    (59) expressionB -> < . = exp
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    >               shift and go to state 111
    =               shift and go to state 110
    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    sign                           shift and go to state 56
    exp                            shift and go to state 109
    factor                         shift and go to state 52
    empty                          shift and go to state 53

state 89

    (61) expressionB -> empty .

    &               reduce using rule 61 (expressionB -> empty .)
    |               reduce using rule 61 (expressionB -> empty .)
    ]               reduce using rule 61 (expressionB -> empty .)
    )               reduce using rule 61 (expressionB -> empty .)
    ,               reduce using rule 61 (expressionB -> empty .)
    ;               reduce using rule 61 (expressionB -> empty .)


state 90

    (56) expressionB -> > . exp
    (60) expressionB -> > . = exp
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    =               shift and go to state 113
    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    sign                           shift and go to state 56
    exp                            shift and go to state 112
    factor                         shift and go to state 52
    empty                          shift and go to state 53

state 91

    (51) superexpressionB -> & . & superexpression

    &               shift and go to state 114


state 92

    (50) superexpression -> expression superexpressionB .

    )               reduce using rule 50 (superexpression -> expression superexpressionB .)
    ,               reduce using rule 50 (superexpression -> expression superexpressionB .)
    ;               reduce using rule 50 (superexpression -> expression superexpressionB .)
    ]               reduce using rule 50 (superexpression -> expression superexpressionB .)


state 93

    (52) superexpressionB -> | . | superexpression

    |               shift and go to state 115


state 94

    (53) superexpressionB -> empty .

    ]               reduce using rule 53 (superexpressionB -> empty .)
    )               reduce using rule 53 (superexpressionB -> empty .)
    ,               reduce using rule 53 (superexpressionB -> empty .)
    ;               reduce using rule 53 (superexpressionB -> empty .)


state 95

    (25) main -> MAIN ( . ) block

    )               shift and go to state 116


state 96

    (13) body -> declarations func funcB main func . funcB
    (14) funcB -> . func
    (15) funcB -> . empty
    (26) func -> . DEF returntype ID ( optionalparams ) block
    (27) func -> . empty
    (115) empty -> .

    DEF             shift and go to state 24
    $end            reduce using rule 115 (empty -> .)

    funcB                          shift and go to state 117
    func                           shift and go to state 41
    empty                          shift and go to state 40

state 97

    (26) func -> DEF returntype ID ( . optionalparams ) block
    (28) optionalparams -> . params
    (29) optionalparams -> . empty
    (112) params -> . type ID paramsB
    (115) empty -> .
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING

    )               reduce using rule 115 (empty -> .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12

    optionalparams                 shift and go to state 118
    params                         shift and go to state 120
    type                           shift and go to state 121
    empty                          shift and go to state 119

state 98

    (19) declarationsC -> , declarationsB .

    ;               reduce using rule 19 (declarationsC -> , declarationsB .)


state 99

    (71) factor -> ( superexpression ) .

    /               reduce using rule 71 (factor -> ( superexpression ) .)
    *               reduce using rule 71 (factor -> ( superexpression ) .)
    -               reduce using rule 71 (factor -> ( superexpression ) .)
    +               reduce using rule 71 (factor -> ( superexpression ) .)
    <               reduce using rule 71 (factor -> ( superexpression ) .)
    >               reduce using rule 71 (factor -> ( superexpression ) .)
    =               reduce using rule 71 (factor -> ( superexpression ) .)
    &               reduce using rule 71 (factor -> ( superexpression ) .)
    |               reduce using rule 71 (factor -> ( superexpression ) .)
    ]               reduce using rule 71 (factor -> ( superexpression ) .)
    )               reduce using rule 71 (factor -> ( superexpression ) .)
    ,               reduce using rule 71 (factor -> ( superexpression ) .)
    ;               reduce using rule 71 (factor -> ( superexpression ) .)


state 100

    (68) termB -> * term .

    -               reduce using rule 68 (termB -> * term .)
    +               reduce using rule 68 (termB -> * term .)
    <               reduce using rule 68 (termB -> * term .)
    >               reduce using rule 68 (termB -> * term .)
    =               reduce using rule 68 (termB -> * term .)
    &               reduce using rule 68 (termB -> * term .)
    |               reduce using rule 68 (termB -> * term .)
    ]               reduce using rule 68 (termB -> * term .)
    )               reduce using rule 68 (termB -> * term .)
    ,               reduce using rule 68 (termB -> * term .)
    ;               reduce using rule 68 (termB -> * term .)


state 101

    (67) termB -> / term .

    -               reduce using rule 67 (termB -> / term .)
    +               reduce using rule 67 (termB -> / term .)
    <               reduce using rule 67 (termB -> / term .)
    >               reduce using rule 67 (termB -> / term .)
    =               reduce using rule 67 (termB -> / term .)
    &               reduce using rule 67 (termB -> / term .)
    |               reduce using rule 67 (termB -> / term .)
    ]               reduce using rule 67 (termB -> / term .)
    )               reduce using rule 67 (termB -> / term .)
    ,               reduce using rule 67 (termB -> / term .)
    ;               reduce using rule 67 (termB -> / term .)


state 102

    (110) dimension -> [ superexpression ] dimensionB .

    /               reduce using rule 110 (dimension -> [ superexpression ] dimensionB .)
    *               reduce using rule 110 (dimension -> [ superexpression ] dimensionB .)
    -               reduce using rule 110 (dimension -> [ superexpression ] dimensionB .)
    +               reduce using rule 110 (dimension -> [ superexpression ] dimensionB .)
    <               reduce using rule 110 (dimension -> [ superexpression ] dimensionB .)
    >               reduce using rule 110 (dimension -> [ superexpression ] dimensionB .)
    =               reduce using rule 110 (dimension -> [ superexpression ] dimensionB .)
    &               reduce using rule 110 (dimension -> [ superexpression ] dimensionB .)
    |               reduce using rule 110 (dimension -> [ superexpression ] dimensionB .)
    ]               reduce using rule 110 (dimension -> [ superexpression ] dimensionB .)
    )               reduce using rule 110 (dimension -> [ superexpression ] dimensionB .)
    ,               reduce using rule 110 (dimension -> [ superexpression ] dimensionB .)
    ;               reduce using rule 110 (dimension -> [ superexpression ] dimensionB .)


state 103

    (105) funccall -> ID ( funccallB . )

    )               shift and go to state 122


state 104

    (107) funccallB -> empty .
    (75) signB -> empty .

    )               reduce using rule 107 (funccallB -> empty .)
    FCONST          reduce using rule 75 (signB -> empty .)
    ICONST          reduce using rule 75 (signB -> empty .)
    TRUE            reduce using rule 75 (signB -> empty .)
    FALSE           reduce using rule 75 (signB -> empty .)


state 105

    (106) funccallB -> superexpression . funccallC
    (108) funccallC -> . , superexpression funccallC
    (109) funccallC -> . empty
    (115) empty -> .

    ,               shift and go to state 124
    )               reduce using rule 115 (empty -> .)

    funccallC                      shift and go to state 123
    empty                          shift and go to state 125

state 106

    (64) expB -> + exp .

    <               reduce using rule 64 (expB -> + exp .)
    >               reduce using rule 64 (expB -> + exp .)
    =               reduce using rule 64 (expB -> + exp .)
    &               reduce using rule 64 (expB -> + exp .)
    |               reduce using rule 64 (expB -> + exp .)
    ]               reduce using rule 64 (expB -> + exp .)
    )               reduce using rule 64 (expB -> + exp .)
    ,               reduce using rule 64 (expB -> + exp .)
    ;               reduce using rule 64 (expB -> + exp .)


state 107

    (63) expB -> - exp .

    <               reduce using rule 63 (expB -> - exp .)
    >               reduce using rule 63 (expB -> - exp .)
    =               reduce using rule 63 (expB -> - exp .)
    &               reduce using rule 63 (expB -> - exp .)
    |               reduce using rule 63 (expB -> - exp .)
    ]               reduce using rule 63 (expB -> - exp .)
    )               reduce using rule 63 (expB -> - exp .)
    ,               reduce using rule 63 (expB -> - exp .)
    ;               reduce using rule 63 (expB -> - exp .)


state 108

    (58) expressionB -> = = . exp
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    sign                           shift and go to state 56
    exp                            shift and go to state 126
    factor                         shift and go to state 52
    empty                          shift and go to state 53

state 109

    (55) expressionB -> < exp .

    &               reduce using rule 55 (expressionB -> < exp .)
    |               reduce using rule 55 (expressionB -> < exp .)
    ]               reduce using rule 55 (expressionB -> < exp .)
    )               reduce using rule 55 (expressionB -> < exp .)
    ,               reduce using rule 55 (expressionB -> < exp .)
    ;               reduce using rule 55 (expressionB -> < exp .)


state 110

    (59) expressionB -> < = . exp
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    sign                           shift and go to state 56
    exp                            shift and go to state 127
    factor                         shift and go to state 52
    empty                          shift and go to state 53

state 111

    (57) expressionB -> < > . exp
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    sign                           shift and go to state 56
    exp                            shift and go to state 128
    factor                         shift and go to state 52
    empty                          shift and go to state 53

state 112

    (56) expressionB -> > exp .

    &               reduce using rule 56 (expressionB -> > exp .)
    |               reduce using rule 56 (expressionB -> > exp .)
    ]               reduce using rule 56 (expressionB -> > exp .)
    )               reduce using rule 56 (expressionB -> > exp .)
    ,               reduce using rule 56 (expressionB -> > exp .)
    ;               reduce using rule 56 (expressionB -> > exp .)


state 113

    (60) expressionB -> > = . exp
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    sign                           shift and go to state 56
    exp                            shift and go to state 129
    factor                         shift and go to state 52
    empty                          shift and go to state 53

state 114

    (51) superexpressionB -> & & . superexpression
    (50) superexpression -> . expression superexpressionB
    (54) expression -> . exp expressionB
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    superexpression                shift and go to state 130
    exp                            shift and go to state 59
    factor                         shift and go to state 52
    sign                           shift and go to state 56
    expression                     shift and go to state 60
    empty                          shift and go to state 53

state 115

    (52) superexpressionB -> | | . superexpression
    (50) superexpression -> . expression superexpressionB
    (54) expression -> . exp expressionB
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    superexpression                shift and go to state 131
    exp                            shift and go to state 59
    factor                         shift and go to state 52
    sign                           shift and go to state 56
    expression                     shift and go to state 60
    empty                          shift and go to state 53

state 116

    (25) main -> MAIN ( ) . block
    (30) block -> . { instruction }

    {               shift and go to state 132

    block                          shift and go to state 133

state 117

    (13) body -> declarations func funcB main func funcB .

    $end            reduce using rule 13 (body -> declarations func funcB main func funcB .)


state 118

    (26) func -> DEF returntype ID ( optionalparams . ) block

    )               shift and go to state 134


state 119

    (29) optionalparams -> empty .

    )               reduce using rule 29 (optionalparams -> empty .)


state 120

    (28) optionalparams -> params .

    )               reduce using rule 28 (optionalparams -> params .)


state 121

    (112) params -> type . ID paramsB

    ID              shift and go to state 135


state 122

    (105) funccall -> ID ( funccallB ) .

    /               reduce using rule 105 (funccall -> ID ( funccallB ) .)
    *               reduce using rule 105 (funccall -> ID ( funccallB ) .)
    -               reduce using rule 105 (funccall -> ID ( funccallB ) .)
    +               reduce using rule 105 (funccall -> ID ( funccallB ) .)
    <               reduce using rule 105 (funccall -> ID ( funccallB ) .)
    >               reduce using rule 105 (funccall -> ID ( funccallB ) .)
    =               reduce using rule 105 (funccall -> ID ( funccallB ) .)
    &               reduce using rule 105 (funccall -> ID ( funccallB ) .)
    |               reduce using rule 105 (funccall -> ID ( funccallB ) .)
    ]               reduce using rule 105 (funccall -> ID ( funccallB ) .)
    )               reduce using rule 105 (funccall -> ID ( funccallB ) .)
    ,               reduce using rule 105 (funccall -> ID ( funccallB ) .)
    ;               reduce using rule 105 (funccall -> ID ( funccallB ) .)


state 123

    (106) funccallB -> superexpression funccallC .

    )               reduce using rule 106 (funccallB -> superexpression funccallC .)


state 124

    (108) funccallC -> , . superexpression funccallC
    (50) superexpression -> . expression superexpressionB
    (54) expression -> . exp expressionB
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    superexpression                shift and go to state 136
    exp                            shift and go to state 59
    factor                         shift and go to state 52
    sign                           shift and go to state 56
    expression                     shift and go to state 60
    empty                          shift and go to state 53

state 125

    (109) funccallC -> empty .

    )               reduce using rule 109 (funccallC -> empty .)


state 126

    (58) expressionB -> = = exp .

    &               reduce using rule 58 (expressionB -> = = exp .)
    |               reduce using rule 58 (expressionB -> = = exp .)
    ]               reduce using rule 58 (expressionB -> = = exp .)
    )               reduce using rule 58 (expressionB -> = = exp .)
    ,               reduce using rule 58 (expressionB -> = = exp .)
    ;               reduce using rule 58 (expressionB -> = = exp .)


state 127

    (59) expressionB -> < = exp .

    &               reduce using rule 59 (expressionB -> < = exp .)
    |               reduce using rule 59 (expressionB -> < = exp .)
    ]               reduce using rule 59 (expressionB -> < = exp .)
    )               reduce using rule 59 (expressionB -> < = exp .)
    ,               reduce using rule 59 (expressionB -> < = exp .)
    ;               reduce using rule 59 (expressionB -> < = exp .)


state 128

    (57) expressionB -> < > exp .

    &               reduce using rule 57 (expressionB -> < > exp .)
    |               reduce using rule 57 (expressionB -> < > exp .)
    ]               reduce using rule 57 (expressionB -> < > exp .)
    )               reduce using rule 57 (expressionB -> < > exp .)
    ,               reduce using rule 57 (expressionB -> < > exp .)
    ;               reduce using rule 57 (expressionB -> < > exp .)


state 129

    (60) expressionB -> > = exp .

    &               reduce using rule 60 (expressionB -> > = exp .)
    |               reduce using rule 60 (expressionB -> > = exp .)
    ]               reduce using rule 60 (expressionB -> > = exp .)
    )               reduce using rule 60 (expressionB -> > = exp .)
    ,               reduce using rule 60 (expressionB -> > = exp .)
    ;               reduce using rule 60 (expressionB -> > = exp .)


state 130

    (51) superexpressionB -> & & superexpression .

    ]               reduce using rule 51 (superexpressionB -> & & superexpression .)
    )               reduce using rule 51 (superexpressionB -> & & superexpression .)
    ,               reduce using rule 51 (superexpressionB -> & & superexpression .)
    ;               reduce using rule 51 (superexpressionB -> & & superexpression .)


state 131

    (52) superexpressionB -> | | superexpression .

    ]               reduce using rule 52 (superexpressionB -> | | superexpression .)
    )               reduce using rule 52 (superexpressionB -> | | superexpression .)
    ,               reduce using rule 52 (superexpressionB -> | | superexpression .)
    ;               reduce using rule 52 (superexpressionB -> | | superexpression .)


state 132

    (30) block -> { . instruction }
    (35) instruction -> . asign ; instructionB
    (36) instruction -> . condition ; instructionB
    (37) instruction -> . output ; instructionB
    (38) instruction -> . whileloop instructionB
    (39) instruction -> . forloop instructionB
    (40) instruction -> . input ; instructionB
    (41) instruction -> . funccall ; instructionB
    (42) instruction -> . return ; instructionB
    (43) instruction -> . localdirective instructionB
    (44) instruction -> . declarations instructionB
    (31) asign -> . ID dimensionB = superexpression
    (32) condition -> . IF ( superexpression ) block else
    (92) output -> . PRINT ( outputB
    (82) whileloop -> . WHILE ( superexpression ) block
    (88) forloop -> . FOR ( asign ; superexpression ; superexpression ) block
    (89) input -> . INPUT ( ID inputB )
    (105) funccall -> . ID ( funccallB )
    (111) return -> . RETURN superexpression
    (47) localdirective -> . localvardirective
    (48) localdirective -> . localdecisiondirective
    (49) localdirective -> . localmsgdirective
    (16) declarations -> . type declarationsB ; declarations
    (17) declarations -> . empty
    (97) localvardirective -> . # localvardirectiveB ID
    (101) localdecisiondirective -> . # localdecisiondirectiveB DECISION
    (102) localdecisiondirective -> . empty
    (100) localmsgdirective -> . # SHOW STRING
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING
    (115) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 152
    IF              shift and go to state 154
    PRINT           shift and go to state 140
    WHILE           shift and go to state 139
    FOR             shift and go to state 143
    INPUT           shift and go to state 151
    RETURN          shift and go to state 138
    #               shift and go to state 142
    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12
    }               reduce using rule 115 (empty -> .)

  ! ID              [ reduce using rule 115 (empty -> .) ]
  ! IF              [ reduce using rule 115 (empty -> .) ]
  ! PRINT           [ reduce using rule 115 (empty -> .) ]
  ! WHILE           [ reduce using rule 115 (empty -> .) ]
  ! FOR             [ reduce using rule 115 (empty -> .) ]
  ! INPUT           [ reduce using rule 115 (empty -> .) ]
  ! RETURN          [ reduce using rule 115 (empty -> .) ]
  ! #               [ reduce using rule 115 (empty -> .) ]
  ! INT             [ reduce using rule 115 (empty -> .) ]
  ! FLOAT           [ reduce using rule 115 (empty -> .) ]
  ! STRING          [ reduce using rule 115 (empty -> .) ]

    instruction                    shift and go to state 137
    whileloop                      shift and go to state 141
    localvardirective              shift and go to state 144
    input                          shift and go to state 145
    type                           shift and go to state 14
    empty                          shift and go to state 146
    forloop                        shift and go to state 147
    return                         shift and go to state 148
    funccall                       shift and go to state 149
    localdirective                 shift and go to state 150
    condition                      shift and go to state 153
    declarations                   shift and go to state 155
    asign                          shift and go to state 156
    localmsgdirective              shift and go to state 157
    localdecisiondirective         shift and go to state 158
    output                         shift and go to state 159

state 133

    (25) main -> MAIN ( ) block .

    DEF             reduce using rule 25 (main -> MAIN ( ) block .)
    $end            reduce using rule 25 (main -> MAIN ( ) block .)


state 134

    (26) func -> DEF returntype ID ( optionalparams ) . block
    (30) block -> . { instruction }

    {               shift and go to state 132

    block                          shift and go to state 160

state 135

    (112) params -> type ID . paramsB
    (113) paramsB -> . , type ID paramsB
    (114) paramsB -> . empty
    (115) empty -> .

    ,               shift and go to state 163
    )               reduce using rule 115 (empty -> .)

    paramsB                        shift and go to state 161
    empty                          shift and go to state 162

state 136

    (108) funccallC -> , superexpression . funccallC
    (108) funccallC -> . , superexpression funccallC
    (109) funccallC -> . empty
    (115) empty -> .

    ,               shift and go to state 124
    )               reduce using rule 115 (empty -> .)

    funccallC                      shift and go to state 164
    empty                          shift and go to state 125

state 137

    (30) block -> { instruction . }

    }               shift and go to state 165


state 138

    (111) return -> RETURN . superexpression
    (50) superexpression -> . expression superexpressionB
    (54) expression -> . exp expressionB
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    superexpression                shift and go to state 166
    exp                            shift and go to state 59
    factor                         shift and go to state 52
    sign                           shift and go to state 56
    expression                     shift and go to state 60
    empty                          shift and go to state 53

state 139

    (82) whileloop -> WHILE . ( superexpression ) block

    (               shift and go to state 167


state 140

    (92) output -> PRINT . ( outputB

    (               shift and go to state 168


state 141

    (38) instruction -> whileloop . instructionB
    (45) instructionB -> . instruction
    (46) instructionB -> . empty
    (35) instruction -> . asign ; instructionB
    (36) instruction -> . condition ; instructionB
    (37) instruction -> . output ; instructionB
    (38) instruction -> . whileloop instructionB
    (39) instruction -> . forloop instructionB
    (40) instruction -> . input ; instructionB
    (41) instruction -> . funccall ; instructionB
    (42) instruction -> . return ; instructionB
    (43) instruction -> . localdirective instructionB
    (44) instruction -> . declarations instructionB
    (115) empty -> .
    (31) asign -> . ID dimensionB = superexpression
    (32) condition -> . IF ( superexpression ) block else
    (92) output -> . PRINT ( outputB
    (82) whileloop -> . WHILE ( superexpression ) block
    (88) forloop -> . FOR ( asign ; superexpression ; superexpression ) block
    (89) input -> . INPUT ( ID inputB )
    (105) funccall -> . ID ( funccallB )
    (111) return -> . RETURN superexpression
    (47) localdirective -> . localvardirective
    (48) localdirective -> . localdecisiondirective
    (49) localdirective -> . localmsgdirective
    (16) declarations -> . type declarationsB ; declarations
    (17) declarations -> . empty
    (97) localvardirective -> . # localvardirectiveB ID
    (101) localdecisiondirective -> . # localdecisiondirectiveB DECISION
    (102) localdecisiondirective -> . empty
    (100) localmsgdirective -> . # SHOW STRING
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    }               reduce using rule 115 (empty -> .)
    ID              shift and go to state 152
    IF              shift and go to state 154
    PRINT           shift and go to state 140
    WHILE           shift and go to state 139
    FOR             shift and go to state 143
    INPUT           shift and go to state 151
    RETURN          shift and go to state 138
    #               shift and go to state 142
    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12

  ! ID              [ reduce using rule 115 (empty -> .) ]
  ! IF              [ reduce using rule 115 (empty -> .) ]
  ! PRINT           [ reduce using rule 115 (empty -> .) ]
  ! WHILE           [ reduce using rule 115 (empty -> .) ]
  ! FOR             [ reduce using rule 115 (empty -> .) ]
  ! INPUT           [ reduce using rule 115 (empty -> .) ]
  ! RETURN          [ reduce using rule 115 (empty -> .) ]
  ! #               [ reduce using rule 115 (empty -> .) ]
  ! INT             [ reduce using rule 115 (empty -> .) ]
  ! FLOAT           [ reduce using rule 115 (empty -> .) ]
  ! STRING          [ reduce using rule 115 (empty -> .) ]

    instruction                    shift and go to state 169
    whileloop                      shift and go to state 141
    localvardirective              shift and go to state 144
    input                          shift and go to state 145
    type                           shift and go to state 14
    empty                          shift and go to state 170
    forloop                        shift and go to state 147
    return                         shift and go to state 148
    funccall                       shift and go to state 149
    localdirective                 shift and go to state 150
    condition                      shift and go to state 153
    declarations                   shift and go to state 155
    instructionB                   shift and go to state 171
    asign                          shift and go to state 156
    localmsgdirective              shift and go to state 157
    localdecisiondirective         shift and go to state 158
    output                         shift and go to state 159

state 142

    (97) localvardirective -> # . localvardirectiveB ID
    (101) localdecisiondirective -> # . localdecisiondirectiveB DECISION
    (100) localmsgdirective -> # . SHOW STRING
    (98) localvardirectiveB -> . TRACK
    (99) localvardirectiveB -> . FORGET
    (103) localdecisiondirectiveB -> . TRACK
    (104) localdecisiondirectiveB -> . FORGET

    SHOW            shift and go to state 172
    TRACK           shift and go to state 173
    FORGET          shift and go to state 176

    localdecisiondirectiveB        shift and go to state 175
    localvardirectiveB             shift and go to state 174

state 143

    (88) forloop -> FOR . ( asign ; superexpression ; superexpression ) block

    (               shift and go to state 177


state 144

    (47) localdirective -> localvardirective .

    ID              reduce using rule 47 (localdirective -> localvardirective .)
    IF              reduce using rule 47 (localdirective -> localvardirective .)
    PRINT           reduce using rule 47 (localdirective -> localvardirective .)
    WHILE           reduce using rule 47 (localdirective -> localvardirective .)
    FOR             reduce using rule 47 (localdirective -> localvardirective .)
    INPUT           reduce using rule 47 (localdirective -> localvardirective .)
    RETURN          reduce using rule 47 (localdirective -> localvardirective .)
    #               reduce using rule 47 (localdirective -> localvardirective .)
    INT             reduce using rule 47 (localdirective -> localvardirective .)
    FLOAT           reduce using rule 47 (localdirective -> localvardirective .)
    STRING          reduce using rule 47 (localdirective -> localvardirective .)
    }               reduce using rule 47 (localdirective -> localvardirective .)


state 145

    (40) instruction -> input . ; instructionB

    ;               shift and go to state 178


state 146

    (17) declarations -> empty .
    (102) localdecisiondirective -> empty .

  ! reduce/reduce conflict for ID resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for INPUT resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for # resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for INT resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for STRING resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for } resolved using rule 17 (declarations -> empty .)
    ID              reduce using rule 17 (declarations -> empty .)
    IF              reduce using rule 17 (declarations -> empty .)
    PRINT           reduce using rule 17 (declarations -> empty .)
    WHILE           reduce using rule 17 (declarations -> empty .)
    FOR             reduce using rule 17 (declarations -> empty .)
    INPUT           reduce using rule 17 (declarations -> empty .)
    RETURN          reduce using rule 17 (declarations -> empty .)
    #               reduce using rule 17 (declarations -> empty .)
    INT             reduce using rule 17 (declarations -> empty .)
    FLOAT           reduce using rule 17 (declarations -> empty .)
    STRING          reduce using rule 17 (declarations -> empty .)
    }               reduce using rule 17 (declarations -> empty .)

  ! ID              [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! IF              [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! PRINT           [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! WHILE           [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! FOR             [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! INPUT           [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! RETURN          [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! #               [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! INT             [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! FLOAT           [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! STRING          [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! }               [ reduce using rule 102 (localdecisiondirective -> empty .) ]


state 147

    (39) instruction -> forloop . instructionB
    (45) instructionB -> . instruction
    (46) instructionB -> . empty
    (35) instruction -> . asign ; instructionB
    (36) instruction -> . condition ; instructionB
    (37) instruction -> . output ; instructionB
    (38) instruction -> . whileloop instructionB
    (39) instruction -> . forloop instructionB
    (40) instruction -> . input ; instructionB
    (41) instruction -> . funccall ; instructionB
    (42) instruction -> . return ; instructionB
    (43) instruction -> . localdirective instructionB
    (44) instruction -> . declarations instructionB
    (115) empty -> .
    (31) asign -> . ID dimensionB = superexpression
    (32) condition -> . IF ( superexpression ) block else
    (92) output -> . PRINT ( outputB
    (82) whileloop -> . WHILE ( superexpression ) block
    (88) forloop -> . FOR ( asign ; superexpression ; superexpression ) block
    (89) input -> . INPUT ( ID inputB )
    (105) funccall -> . ID ( funccallB )
    (111) return -> . RETURN superexpression
    (47) localdirective -> . localvardirective
    (48) localdirective -> . localdecisiondirective
    (49) localdirective -> . localmsgdirective
    (16) declarations -> . type declarationsB ; declarations
    (17) declarations -> . empty
    (97) localvardirective -> . # localvardirectiveB ID
    (101) localdecisiondirective -> . # localdecisiondirectiveB DECISION
    (102) localdecisiondirective -> . empty
    (100) localmsgdirective -> . # SHOW STRING
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    }               reduce using rule 115 (empty -> .)
    ID              shift and go to state 152
    IF              shift and go to state 154
    PRINT           shift and go to state 140
    WHILE           shift and go to state 139
    FOR             shift and go to state 143
    INPUT           shift and go to state 151
    RETURN          shift and go to state 138
    #               shift and go to state 142
    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12

  ! ID              [ reduce using rule 115 (empty -> .) ]
  ! IF              [ reduce using rule 115 (empty -> .) ]
  ! PRINT           [ reduce using rule 115 (empty -> .) ]
  ! WHILE           [ reduce using rule 115 (empty -> .) ]
  ! FOR             [ reduce using rule 115 (empty -> .) ]
  ! INPUT           [ reduce using rule 115 (empty -> .) ]
  ! RETURN          [ reduce using rule 115 (empty -> .) ]
  ! #               [ reduce using rule 115 (empty -> .) ]
  ! INT             [ reduce using rule 115 (empty -> .) ]
  ! FLOAT           [ reduce using rule 115 (empty -> .) ]
  ! STRING          [ reduce using rule 115 (empty -> .) ]

    instruction                    shift and go to state 169
    forloop                        shift and go to state 147
    localvardirective              shift and go to state 144
    input                          shift and go to state 145
    type                           shift and go to state 14
    empty                          shift and go to state 170
    whileloop                      shift and go to state 141
    return                         shift and go to state 148
    funccall                       shift and go to state 149
    localdirective                 shift and go to state 150
    condition                      shift and go to state 153
    declarations                   shift and go to state 155
    instructionB                   shift and go to state 179
    asign                          shift and go to state 156
    localmsgdirective              shift and go to state 157
    localdecisiondirective         shift and go to state 158
    output                         shift and go to state 159

state 148

    (42) instruction -> return . ; instructionB

    ;               shift and go to state 180


state 149

    (41) instruction -> funccall . ; instructionB

    ;               shift and go to state 181


state 150

    (43) instruction -> localdirective . instructionB
    (45) instructionB -> . instruction
    (46) instructionB -> . empty
    (35) instruction -> . asign ; instructionB
    (36) instruction -> . condition ; instructionB
    (37) instruction -> . output ; instructionB
    (38) instruction -> . whileloop instructionB
    (39) instruction -> . forloop instructionB
    (40) instruction -> . input ; instructionB
    (41) instruction -> . funccall ; instructionB
    (42) instruction -> . return ; instructionB
    (43) instruction -> . localdirective instructionB
    (44) instruction -> . declarations instructionB
    (115) empty -> .
    (31) asign -> . ID dimensionB = superexpression
    (32) condition -> . IF ( superexpression ) block else
    (92) output -> . PRINT ( outputB
    (82) whileloop -> . WHILE ( superexpression ) block
    (88) forloop -> . FOR ( asign ; superexpression ; superexpression ) block
    (89) input -> . INPUT ( ID inputB )
    (105) funccall -> . ID ( funccallB )
    (111) return -> . RETURN superexpression
    (47) localdirective -> . localvardirective
    (48) localdirective -> . localdecisiondirective
    (49) localdirective -> . localmsgdirective
    (16) declarations -> . type declarationsB ; declarations
    (17) declarations -> . empty
    (97) localvardirective -> . # localvardirectiveB ID
    (101) localdecisiondirective -> . # localdecisiondirectiveB DECISION
    (102) localdecisiondirective -> . empty
    (100) localmsgdirective -> . # SHOW STRING
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    }               reduce using rule 115 (empty -> .)
    ID              shift and go to state 152
    IF              shift and go to state 154
    PRINT           shift and go to state 140
    WHILE           shift and go to state 139
    FOR             shift and go to state 143
    INPUT           shift and go to state 151
    RETURN          shift and go to state 138
    #               shift and go to state 142
    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12

  ! ID              [ reduce using rule 115 (empty -> .) ]
  ! IF              [ reduce using rule 115 (empty -> .) ]
  ! PRINT           [ reduce using rule 115 (empty -> .) ]
  ! WHILE           [ reduce using rule 115 (empty -> .) ]
  ! FOR             [ reduce using rule 115 (empty -> .) ]
  ! INPUT           [ reduce using rule 115 (empty -> .) ]
  ! RETURN          [ reduce using rule 115 (empty -> .) ]
  ! #               [ reduce using rule 115 (empty -> .) ]
  ! INT             [ reduce using rule 115 (empty -> .) ]
  ! FLOAT           [ reduce using rule 115 (empty -> .) ]
  ! STRING          [ reduce using rule 115 (empty -> .) ]

    instruction                    shift and go to state 169
    whileloop                      shift and go to state 141
    localvardirective              shift and go to state 144
    input                          shift and go to state 145
    type                           shift and go to state 14
    empty                          shift and go to state 170
    forloop                        shift and go to state 147
    return                         shift and go to state 148
    funccall                       shift and go to state 149
    localdirective                 shift and go to state 150
    condition                      shift and go to state 153
    declarations                   shift and go to state 155
    instructionB                   shift and go to state 182
    asign                          shift and go to state 156
    localmsgdirective              shift and go to state 157
    localdecisiondirective         shift and go to state 158
    output                         shift and go to state 159

state 151

    (89) input -> INPUT . ( ID inputB )

    (               shift and go to state 183


state 152

    (31) asign -> ID . dimensionB = superexpression
    (105) funccall -> ID . ( funccallB )
    (21) dimensionB -> . dimension
    (22) dimensionB -> . empty
    (110) dimension -> . [ superexpression ] dimensionB
    (115) empty -> .

    (               shift and go to state 80
    [               shift and go to state 35
    =               reduce using rule 115 (empty -> .)

    dimensionB                     shift and go to state 184
    dimension                      shift and go to state 36
    empty                          shift and go to state 37

state 153

    (36) instruction -> condition . ; instructionB

    ;               shift and go to state 185


state 154

    (32) condition -> IF . ( superexpression ) block else

    (               shift and go to state 186


state 155

    (44) instruction -> declarations . instructionB
    (45) instructionB -> . instruction
    (46) instructionB -> . empty
    (35) instruction -> . asign ; instructionB
    (36) instruction -> . condition ; instructionB
    (37) instruction -> . output ; instructionB
    (38) instruction -> . whileloop instructionB
    (39) instruction -> . forloop instructionB
    (40) instruction -> . input ; instructionB
    (41) instruction -> . funccall ; instructionB
    (42) instruction -> . return ; instructionB
    (43) instruction -> . localdirective instructionB
    (44) instruction -> . declarations instructionB
    (115) empty -> .
    (31) asign -> . ID dimensionB = superexpression
    (32) condition -> . IF ( superexpression ) block else
    (92) output -> . PRINT ( outputB
    (82) whileloop -> . WHILE ( superexpression ) block
    (88) forloop -> . FOR ( asign ; superexpression ; superexpression ) block
    (89) input -> . INPUT ( ID inputB )
    (105) funccall -> . ID ( funccallB )
    (111) return -> . RETURN superexpression
    (47) localdirective -> . localvardirective
    (48) localdirective -> . localdecisiondirective
    (49) localdirective -> . localmsgdirective
    (16) declarations -> . type declarationsB ; declarations
    (17) declarations -> . empty
    (97) localvardirective -> . # localvardirectiveB ID
    (101) localdecisiondirective -> . # localdecisiondirectiveB DECISION
    (102) localdecisiondirective -> . empty
    (100) localmsgdirective -> . # SHOW STRING
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    }               reduce using rule 115 (empty -> .)
    ID              shift and go to state 152
    IF              shift and go to state 154
    PRINT           shift and go to state 140
    WHILE           shift and go to state 139
    FOR             shift and go to state 143
    INPUT           shift and go to state 151
    RETURN          shift and go to state 138
    #               shift and go to state 142
    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12

  ! ID              [ reduce using rule 115 (empty -> .) ]
  ! IF              [ reduce using rule 115 (empty -> .) ]
  ! PRINT           [ reduce using rule 115 (empty -> .) ]
  ! WHILE           [ reduce using rule 115 (empty -> .) ]
  ! FOR             [ reduce using rule 115 (empty -> .) ]
  ! INPUT           [ reduce using rule 115 (empty -> .) ]
  ! RETURN          [ reduce using rule 115 (empty -> .) ]
  ! #               [ reduce using rule 115 (empty -> .) ]
  ! INT             [ reduce using rule 115 (empty -> .) ]
  ! FLOAT           [ reduce using rule 115 (empty -> .) ]
  ! STRING          [ reduce using rule 115 (empty -> .) ]

    declarations                   shift and go to state 155
    whileloop                      shift and go to state 141
    localvardirective              shift and go to state 144
    input                          shift and go to state 145
    type                           shift and go to state 14
    empty                          shift and go to state 170
    forloop                        shift and go to state 147
    return                         shift and go to state 148
    funccall                       shift and go to state 149
    localdirective                 shift and go to state 150
    condition                      shift and go to state 153
    instruction                    shift and go to state 169
    instructionB                   shift and go to state 187
    asign                          shift and go to state 156
    localmsgdirective              shift and go to state 157
    localdecisiondirective         shift and go to state 158
    output                         shift and go to state 159

state 156

    (35) instruction -> asign . ; instructionB

    ;               shift and go to state 188


state 157

    (49) localdirective -> localmsgdirective .

    ID              reduce using rule 49 (localdirective -> localmsgdirective .)
    IF              reduce using rule 49 (localdirective -> localmsgdirective .)
    PRINT           reduce using rule 49 (localdirective -> localmsgdirective .)
    WHILE           reduce using rule 49 (localdirective -> localmsgdirective .)
    FOR             reduce using rule 49 (localdirective -> localmsgdirective .)
    INPUT           reduce using rule 49 (localdirective -> localmsgdirective .)
    RETURN          reduce using rule 49 (localdirective -> localmsgdirective .)
    #               reduce using rule 49 (localdirective -> localmsgdirective .)
    INT             reduce using rule 49 (localdirective -> localmsgdirective .)
    FLOAT           reduce using rule 49 (localdirective -> localmsgdirective .)
    STRING          reduce using rule 49 (localdirective -> localmsgdirective .)
    }               reduce using rule 49 (localdirective -> localmsgdirective .)


state 158

    (48) localdirective -> localdecisiondirective .

    ID              reduce using rule 48 (localdirective -> localdecisiondirective .)
    IF              reduce using rule 48 (localdirective -> localdecisiondirective .)
    PRINT           reduce using rule 48 (localdirective -> localdecisiondirective .)
    WHILE           reduce using rule 48 (localdirective -> localdecisiondirective .)
    FOR             reduce using rule 48 (localdirective -> localdecisiondirective .)
    INPUT           reduce using rule 48 (localdirective -> localdecisiondirective .)
    RETURN          reduce using rule 48 (localdirective -> localdecisiondirective .)
    #               reduce using rule 48 (localdirective -> localdecisiondirective .)
    INT             reduce using rule 48 (localdirective -> localdecisiondirective .)
    FLOAT           reduce using rule 48 (localdirective -> localdecisiondirective .)
    STRING          reduce using rule 48 (localdirective -> localdecisiondirective .)
    }               reduce using rule 48 (localdirective -> localdecisiondirective .)


state 159

    (37) instruction -> output . ; instructionB

    ;               shift and go to state 189


state 160

    (26) func -> DEF returntype ID ( optionalparams ) block .

    $end            reduce using rule 26 (func -> DEF returntype ID ( optionalparams ) block .)
    MAIN            reduce using rule 26 (func -> DEF returntype ID ( optionalparams ) block .)
    DEF             reduce using rule 26 (func -> DEF returntype ID ( optionalparams ) block .)


state 161

    (112) params -> type ID paramsB .

    )               reduce using rule 112 (params -> type ID paramsB .)


state 162

    (114) paramsB -> empty .

    )               reduce using rule 114 (paramsB -> empty .)


state 163

    (113) paramsB -> , . type ID paramsB
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING

    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12

    type                           shift and go to state 190

state 164

    (108) funccallC -> , superexpression funccallC .

    )               reduce using rule 108 (funccallC -> , superexpression funccallC .)


state 165

    (30) block -> { instruction } .

    DEF             reduce using rule 30 (block -> { instruction } .)
    $end            reduce using rule 30 (block -> { instruction } .)
    ;               reduce using rule 30 (block -> { instruction } .)
    MAIN            reduce using rule 30 (block -> { instruction } .)
    ELSE            reduce using rule 30 (block -> { instruction } .)
    ID              reduce using rule 30 (block -> { instruction } .)
    IF              reduce using rule 30 (block -> { instruction } .)
    PRINT           reduce using rule 30 (block -> { instruction } .)
    WHILE           reduce using rule 30 (block -> { instruction } .)
    FOR             reduce using rule 30 (block -> { instruction } .)
    INPUT           reduce using rule 30 (block -> { instruction } .)
    RETURN          reduce using rule 30 (block -> { instruction } .)
    #               reduce using rule 30 (block -> { instruction } .)
    INT             reduce using rule 30 (block -> { instruction } .)
    FLOAT           reduce using rule 30 (block -> { instruction } .)
    STRING          reduce using rule 30 (block -> { instruction } .)
    }               reduce using rule 30 (block -> { instruction } .)


state 166

    (111) return -> RETURN superexpression .

    ;               reduce using rule 111 (return -> RETURN superexpression .)


state 167

    (82) whileloop -> WHILE ( . superexpression ) block
    (50) superexpression -> . expression superexpressionB
    (54) expression -> . exp expressionB
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    superexpression                shift and go to state 191
    empty                          shift and go to state 53
    exp                            shift and go to state 59
    factor                         shift and go to state 52
    sign                           shift and go to state 56
    expression                     shift and go to state 60

state 168

    (92) output -> PRINT ( . outputB
    (93) outputB -> . STRING outputC
    (94) outputB -> . superexpression outputC
    (50) superexpression -> . expression superexpressionB
    (54) expression -> . exp expressionB
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    STRING          shift and go to state 192
    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    factor                         shift and go to state 52
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    superexpression                shift and go to state 193
    exp                            shift and go to state 59
    outputB                        shift and go to state 194
    sign                           shift and go to state 56
    expression                     shift and go to state 60
    empty                          shift and go to state 53

state 169

    (45) instructionB -> instruction .

    }               reduce using rule 45 (instructionB -> instruction .)


state 170

    (46) instructionB -> empty .
    (17) declarations -> empty .
    (102) localdecisiondirective -> empty .

  ! reduce/reduce conflict for } resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for ID resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for INPUT resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for # resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for INT resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for STRING resolved using rule 17 (declarations -> empty .)
  ! reduce/reduce conflict for } resolved using rule 17 (declarations -> empty .)
    ID              reduce using rule 17 (declarations -> empty .)
    IF              reduce using rule 17 (declarations -> empty .)
    PRINT           reduce using rule 17 (declarations -> empty .)
    WHILE           reduce using rule 17 (declarations -> empty .)
    FOR             reduce using rule 17 (declarations -> empty .)
    INPUT           reduce using rule 17 (declarations -> empty .)
    RETURN          reduce using rule 17 (declarations -> empty .)
    #               reduce using rule 17 (declarations -> empty .)
    INT             reduce using rule 17 (declarations -> empty .)
    FLOAT           reduce using rule 17 (declarations -> empty .)
    STRING          reduce using rule 17 (declarations -> empty .)
    }               reduce using rule 17 (declarations -> empty .)

  ! }               [ reduce using rule 46 (instructionB -> empty .) ]
  ! ID              [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! IF              [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! PRINT           [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! WHILE           [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! FOR             [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! INPUT           [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! RETURN          [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! #               [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! INT             [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! FLOAT           [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! STRING          [ reduce using rule 102 (localdecisiondirective -> empty .) ]
  ! }               [ reduce using rule 102 (localdecisiondirective -> empty .) ]


state 171

    (38) instruction -> whileloop instructionB .

    }               reduce using rule 38 (instruction -> whileloop instructionB .)


state 172

    (100) localmsgdirective -> # SHOW . STRING

    STRING          shift and go to state 195


state 173

    (98) localvardirectiveB -> TRACK .
    (103) localdecisiondirectiveB -> TRACK .

    ID              reduce using rule 98 (localvardirectiveB -> TRACK .)
    DECISION        reduce using rule 103 (localdecisiondirectiveB -> TRACK .)


state 174

    (97) localvardirective -> # localvardirectiveB . ID

    ID              shift and go to state 196


state 175

    (101) localdecisiondirective -> # localdecisiondirectiveB . DECISION

    DECISION        shift and go to state 197


state 176

    (99) localvardirectiveB -> FORGET .
    (104) localdecisiondirectiveB -> FORGET .

    ID              reduce using rule 99 (localvardirectiveB -> FORGET .)
    DECISION        reduce using rule 104 (localdecisiondirectiveB -> FORGET .)


state 177

    (88) forloop -> FOR ( . asign ; superexpression ; superexpression ) block
    (31) asign -> . ID dimensionB = superexpression

    ID              shift and go to state 199

    asign                          shift and go to state 198

state 178

    (40) instruction -> input ; . instructionB
    (45) instructionB -> . instruction
    (46) instructionB -> . empty
    (35) instruction -> . asign ; instructionB
    (36) instruction -> . condition ; instructionB
    (37) instruction -> . output ; instructionB
    (38) instruction -> . whileloop instructionB
    (39) instruction -> . forloop instructionB
    (40) instruction -> . input ; instructionB
    (41) instruction -> . funccall ; instructionB
    (42) instruction -> . return ; instructionB
    (43) instruction -> . localdirective instructionB
    (44) instruction -> . declarations instructionB
    (115) empty -> .
    (31) asign -> . ID dimensionB = superexpression
    (32) condition -> . IF ( superexpression ) block else
    (92) output -> . PRINT ( outputB
    (82) whileloop -> . WHILE ( superexpression ) block
    (88) forloop -> . FOR ( asign ; superexpression ; superexpression ) block
    (89) input -> . INPUT ( ID inputB )
    (105) funccall -> . ID ( funccallB )
    (111) return -> . RETURN superexpression
    (47) localdirective -> . localvardirective
    (48) localdirective -> . localdecisiondirective
    (49) localdirective -> . localmsgdirective
    (16) declarations -> . type declarationsB ; declarations
    (17) declarations -> . empty
    (97) localvardirective -> . # localvardirectiveB ID
    (101) localdecisiondirective -> . # localdecisiondirectiveB DECISION
    (102) localdecisiondirective -> . empty
    (100) localmsgdirective -> . # SHOW STRING
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    }               reduce using rule 115 (empty -> .)
    ID              shift and go to state 152
    IF              shift and go to state 154
    PRINT           shift and go to state 140
    WHILE           shift and go to state 139
    FOR             shift and go to state 143
    INPUT           shift and go to state 151
    RETURN          shift and go to state 138
    #               shift and go to state 142
    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12

  ! ID              [ reduce using rule 115 (empty -> .) ]
  ! IF              [ reduce using rule 115 (empty -> .) ]
  ! PRINT           [ reduce using rule 115 (empty -> .) ]
  ! WHILE           [ reduce using rule 115 (empty -> .) ]
  ! FOR             [ reduce using rule 115 (empty -> .) ]
  ! INPUT           [ reduce using rule 115 (empty -> .) ]
  ! RETURN          [ reduce using rule 115 (empty -> .) ]
  ! #               [ reduce using rule 115 (empty -> .) ]
  ! INT             [ reduce using rule 115 (empty -> .) ]
  ! FLOAT           [ reduce using rule 115 (empty -> .) ]
  ! STRING          [ reduce using rule 115 (empty -> .) ]

    instruction                    shift and go to state 169
    whileloop                      shift and go to state 141
    localvardirective              shift and go to state 144
    input                          shift and go to state 145
    type                           shift and go to state 14
    empty                          shift and go to state 170
    forloop                        shift and go to state 147
    return                         shift and go to state 148
    funccall                       shift and go to state 149
    localdirective                 shift and go to state 150
    condition                      shift and go to state 153
    declarations                   shift and go to state 155
    instructionB                   shift and go to state 200
    asign                          shift and go to state 156
    localmsgdirective              shift and go to state 157
    localdecisiondirective         shift and go to state 158
    output                         shift and go to state 159

state 179

    (39) instruction -> forloop instructionB .

    }               reduce using rule 39 (instruction -> forloop instructionB .)


state 180

    (42) instruction -> return ; . instructionB
    (45) instructionB -> . instruction
    (46) instructionB -> . empty
    (35) instruction -> . asign ; instructionB
    (36) instruction -> . condition ; instructionB
    (37) instruction -> . output ; instructionB
    (38) instruction -> . whileloop instructionB
    (39) instruction -> . forloop instructionB
    (40) instruction -> . input ; instructionB
    (41) instruction -> . funccall ; instructionB
    (42) instruction -> . return ; instructionB
    (43) instruction -> . localdirective instructionB
    (44) instruction -> . declarations instructionB
    (115) empty -> .
    (31) asign -> . ID dimensionB = superexpression
    (32) condition -> . IF ( superexpression ) block else
    (92) output -> . PRINT ( outputB
    (82) whileloop -> . WHILE ( superexpression ) block
    (88) forloop -> . FOR ( asign ; superexpression ; superexpression ) block
    (89) input -> . INPUT ( ID inputB )
    (105) funccall -> . ID ( funccallB )
    (111) return -> . RETURN superexpression
    (47) localdirective -> . localvardirective
    (48) localdirective -> . localdecisiondirective
    (49) localdirective -> . localmsgdirective
    (16) declarations -> . type declarationsB ; declarations
    (17) declarations -> . empty
    (97) localvardirective -> . # localvardirectiveB ID
    (101) localdecisiondirective -> . # localdecisiondirectiveB DECISION
    (102) localdecisiondirective -> . empty
    (100) localmsgdirective -> . # SHOW STRING
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    }               reduce using rule 115 (empty -> .)
    ID              shift and go to state 152
    IF              shift and go to state 154
    PRINT           shift and go to state 140
    WHILE           shift and go to state 139
    FOR             shift and go to state 143
    INPUT           shift and go to state 151
    RETURN          shift and go to state 138
    #               shift and go to state 142
    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12

  ! ID              [ reduce using rule 115 (empty -> .) ]
  ! IF              [ reduce using rule 115 (empty -> .) ]
  ! PRINT           [ reduce using rule 115 (empty -> .) ]
  ! WHILE           [ reduce using rule 115 (empty -> .) ]
  ! FOR             [ reduce using rule 115 (empty -> .) ]
  ! INPUT           [ reduce using rule 115 (empty -> .) ]
  ! RETURN          [ reduce using rule 115 (empty -> .) ]
  ! #               [ reduce using rule 115 (empty -> .) ]
  ! INT             [ reduce using rule 115 (empty -> .) ]
  ! FLOAT           [ reduce using rule 115 (empty -> .) ]
  ! STRING          [ reduce using rule 115 (empty -> .) ]

    instruction                    shift and go to state 169
    whileloop                      shift and go to state 141
    localvardirective              shift and go to state 144
    input                          shift and go to state 145
    type                           shift and go to state 14
    empty                          shift and go to state 170
    forloop                        shift and go to state 147
    return                         shift and go to state 148
    funccall                       shift and go to state 149
    localdirective                 shift and go to state 150
    condition                      shift and go to state 153
    declarations                   shift and go to state 155
    instructionB                   shift and go to state 201
    asign                          shift and go to state 156
    localmsgdirective              shift and go to state 157
    localdecisiondirective         shift and go to state 158
    output                         shift and go to state 159

state 181

    (41) instruction -> funccall ; . instructionB
    (45) instructionB -> . instruction
    (46) instructionB -> . empty
    (35) instruction -> . asign ; instructionB
    (36) instruction -> . condition ; instructionB
    (37) instruction -> . output ; instructionB
    (38) instruction -> . whileloop instructionB
    (39) instruction -> . forloop instructionB
    (40) instruction -> . input ; instructionB
    (41) instruction -> . funccall ; instructionB
    (42) instruction -> . return ; instructionB
    (43) instruction -> . localdirective instructionB
    (44) instruction -> . declarations instructionB
    (115) empty -> .
    (31) asign -> . ID dimensionB = superexpression
    (32) condition -> . IF ( superexpression ) block else
    (92) output -> . PRINT ( outputB
    (82) whileloop -> . WHILE ( superexpression ) block
    (88) forloop -> . FOR ( asign ; superexpression ; superexpression ) block
    (89) input -> . INPUT ( ID inputB )
    (105) funccall -> . ID ( funccallB )
    (111) return -> . RETURN superexpression
    (47) localdirective -> . localvardirective
    (48) localdirective -> . localdecisiondirective
    (49) localdirective -> . localmsgdirective
    (16) declarations -> . type declarationsB ; declarations
    (17) declarations -> . empty
    (97) localvardirective -> . # localvardirectiveB ID
    (101) localdecisiondirective -> . # localdecisiondirectiveB DECISION
    (102) localdecisiondirective -> . empty
    (100) localmsgdirective -> . # SHOW STRING
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    }               reduce using rule 115 (empty -> .)
    ID              shift and go to state 152
    IF              shift and go to state 154
    PRINT           shift and go to state 140
    WHILE           shift and go to state 139
    FOR             shift and go to state 143
    INPUT           shift and go to state 151
    RETURN          shift and go to state 138
    #               shift and go to state 142
    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12

  ! ID              [ reduce using rule 115 (empty -> .) ]
  ! IF              [ reduce using rule 115 (empty -> .) ]
  ! PRINT           [ reduce using rule 115 (empty -> .) ]
  ! WHILE           [ reduce using rule 115 (empty -> .) ]
  ! FOR             [ reduce using rule 115 (empty -> .) ]
  ! INPUT           [ reduce using rule 115 (empty -> .) ]
  ! RETURN          [ reduce using rule 115 (empty -> .) ]
  ! #               [ reduce using rule 115 (empty -> .) ]
  ! INT             [ reduce using rule 115 (empty -> .) ]
  ! FLOAT           [ reduce using rule 115 (empty -> .) ]
  ! STRING          [ reduce using rule 115 (empty -> .) ]

    instruction                    shift and go to state 169
    whileloop                      shift and go to state 141
    localvardirective              shift and go to state 144
    input                          shift and go to state 145
    type                           shift and go to state 14
    empty                          shift and go to state 170
    forloop                        shift and go to state 147
    return                         shift and go to state 148
    funccall                       shift and go to state 149
    localdirective                 shift and go to state 150
    condition                      shift and go to state 153
    declarations                   shift and go to state 155
    instructionB                   shift and go to state 202
    asign                          shift and go to state 156
    localmsgdirective              shift and go to state 157
    localdecisiondirective         shift and go to state 158
    output                         shift and go to state 159

state 182

    (43) instruction -> localdirective instructionB .

    }               reduce using rule 43 (instruction -> localdirective instructionB .)


state 183

    (89) input -> INPUT ( . ID inputB )

    ID              shift and go to state 203


state 184

    (31) asign -> ID dimensionB . = superexpression

    =               shift and go to state 204


state 185

    (36) instruction -> condition ; . instructionB
    (45) instructionB -> . instruction
    (46) instructionB -> . empty
    (35) instruction -> . asign ; instructionB
    (36) instruction -> . condition ; instructionB
    (37) instruction -> . output ; instructionB
    (38) instruction -> . whileloop instructionB
    (39) instruction -> . forloop instructionB
    (40) instruction -> . input ; instructionB
    (41) instruction -> . funccall ; instructionB
    (42) instruction -> . return ; instructionB
    (43) instruction -> . localdirective instructionB
    (44) instruction -> . declarations instructionB
    (115) empty -> .
    (31) asign -> . ID dimensionB = superexpression
    (32) condition -> . IF ( superexpression ) block else
    (92) output -> . PRINT ( outputB
    (82) whileloop -> . WHILE ( superexpression ) block
    (88) forloop -> . FOR ( asign ; superexpression ; superexpression ) block
    (89) input -> . INPUT ( ID inputB )
    (105) funccall -> . ID ( funccallB )
    (111) return -> . RETURN superexpression
    (47) localdirective -> . localvardirective
    (48) localdirective -> . localdecisiondirective
    (49) localdirective -> . localmsgdirective
    (16) declarations -> . type declarationsB ; declarations
    (17) declarations -> . empty
    (97) localvardirective -> . # localvardirectiveB ID
    (101) localdecisiondirective -> . # localdecisiondirectiveB DECISION
    (102) localdecisiondirective -> . empty
    (100) localmsgdirective -> . # SHOW STRING
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    }               reduce using rule 115 (empty -> .)
    ID              shift and go to state 152
    IF              shift and go to state 154
    PRINT           shift and go to state 140
    WHILE           shift and go to state 139
    FOR             shift and go to state 143
    INPUT           shift and go to state 151
    RETURN          shift and go to state 138
    #               shift and go to state 142
    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12

  ! ID              [ reduce using rule 115 (empty -> .) ]
  ! IF              [ reduce using rule 115 (empty -> .) ]
  ! PRINT           [ reduce using rule 115 (empty -> .) ]
  ! WHILE           [ reduce using rule 115 (empty -> .) ]
  ! FOR             [ reduce using rule 115 (empty -> .) ]
  ! INPUT           [ reduce using rule 115 (empty -> .) ]
  ! RETURN          [ reduce using rule 115 (empty -> .) ]
  ! #               [ reduce using rule 115 (empty -> .) ]
  ! INT             [ reduce using rule 115 (empty -> .) ]
  ! FLOAT           [ reduce using rule 115 (empty -> .) ]
  ! STRING          [ reduce using rule 115 (empty -> .) ]

    instruction                    shift and go to state 169
    whileloop                      shift and go to state 141
    localvardirective              shift and go to state 144
    input                          shift and go to state 145
    type                           shift and go to state 14
    empty                          shift and go to state 170
    forloop                        shift and go to state 147
    return                         shift and go to state 148
    funccall                       shift and go to state 149
    localdirective                 shift and go to state 150
    condition                      shift and go to state 153
    declarations                   shift and go to state 155
    instructionB                   shift and go to state 205
    asign                          shift and go to state 156
    localmsgdirective              shift and go to state 157
    localdecisiondirective         shift and go to state 158
    output                         shift and go to state 159

state 186

    (32) condition -> IF ( . superexpression ) block else
    (50) superexpression -> . expression superexpressionB
    (54) expression -> . exp expressionB
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    sign                           shift and go to state 56
    superexpression                shift and go to state 206
    empty                          shift and go to state 53
    exp                            shift and go to state 59
    factor                         shift and go to state 52
    expression                     shift and go to state 60

state 187

    (44) instruction -> declarations instructionB .

    }               reduce using rule 44 (instruction -> declarations instructionB .)


state 188

    (35) instruction -> asign ; . instructionB
    (45) instructionB -> . instruction
    (46) instructionB -> . empty
    (35) instruction -> . asign ; instructionB
    (36) instruction -> . condition ; instructionB
    (37) instruction -> . output ; instructionB
    (38) instruction -> . whileloop instructionB
    (39) instruction -> . forloop instructionB
    (40) instruction -> . input ; instructionB
    (41) instruction -> . funccall ; instructionB
    (42) instruction -> . return ; instructionB
    (43) instruction -> . localdirective instructionB
    (44) instruction -> . declarations instructionB
    (115) empty -> .
    (31) asign -> . ID dimensionB = superexpression
    (32) condition -> . IF ( superexpression ) block else
    (92) output -> . PRINT ( outputB
    (82) whileloop -> . WHILE ( superexpression ) block
    (88) forloop -> . FOR ( asign ; superexpression ; superexpression ) block
    (89) input -> . INPUT ( ID inputB )
    (105) funccall -> . ID ( funccallB )
    (111) return -> . RETURN superexpression
    (47) localdirective -> . localvardirective
    (48) localdirective -> . localdecisiondirective
    (49) localdirective -> . localmsgdirective
    (16) declarations -> . type declarationsB ; declarations
    (17) declarations -> . empty
    (97) localvardirective -> . # localvardirectiveB ID
    (101) localdecisiondirective -> . # localdecisiondirectiveB DECISION
    (102) localdecisiondirective -> . empty
    (100) localmsgdirective -> . # SHOW STRING
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    }               reduce using rule 115 (empty -> .)
    ID              shift and go to state 152
    IF              shift and go to state 154
    PRINT           shift and go to state 140
    WHILE           shift and go to state 139
    FOR             shift and go to state 143
    INPUT           shift and go to state 151
    RETURN          shift and go to state 138
    #               shift and go to state 142
    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12

  ! ID              [ reduce using rule 115 (empty -> .) ]
  ! IF              [ reduce using rule 115 (empty -> .) ]
  ! PRINT           [ reduce using rule 115 (empty -> .) ]
  ! WHILE           [ reduce using rule 115 (empty -> .) ]
  ! FOR             [ reduce using rule 115 (empty -> .) ]
  ! INPUT           [ reduce using rule 115 (empty -> .) ]
  ! RETURN          [ reduce using rule 115 (empty -> .) ]
  ! #               [ reduce using rule 115 (empty -> .) ]
  ! INT             [ reduce using rule 115 (empty -> .) ]
  ! FLOAT           [ reduce using rule 115 (empty -> .) ]
  ! STRING          [ reduce using rule 115 (empty -> .) ]

    instruction                    shift and go to state 169
    whileloop                      shift and go to state 141
    localvardirective              shift and go to state 144
    input                          shift and go to state 145
    type                           shift and go to state 14
    empty                          shift and go to state 170
    forloop                        shift and go to state 147
    return                         shift and go to state 148
    funccall                       shift and go to state 149
    localdirective                 shift and go to state 150
    condition                      shift and go to state 153
    declarations                   shift and go to state 155
    instructionB                   shift and go to state 207
    asign                          shift and go to state 156
    localmsgdirective              shift and go to state 157
    localdecisiondirective         shift and go to state 158
    output                         shift and go to state 159

state 189

    (37) instruction -> output ; . instructionB
    (45) instructionB -> . instruction
    (46) instructionB -> . empty
    (35) instruction -> . asign ; instructionB
    (36) instruction -> . condition ; instructionB
    (37) instruction -> . output ; instructionB
    (38) instruction -> . whileloop instructionB
    (39) instruction -> . forloop instructionB
    (40) instruction -> . input ; instructionB
    (41) instruction -> . funccall ; instructionB
    (42) instruction -> . return ; instructionB
    (43) instruction -> . localdirective instructionB
    (44) instruction -> . declarations instructionB
    (115) empty -> .
    (31) asign -> . ID dimensionB = superexpression
    (32) condition -> . IF ( superexpression ) block else
    (92) output -> . PRINT ( outputB
    (82) whileloop -> . WHILE ( superexpression ) block
    (88) forloop -> . FOR ( asign ; superexpression ; superexpression ) block
    (89) input -> . INPUT ( ID inputB )
    (105) funccall -> . ID ( funccallB )
    (111) return -> . RETURN superexpression
    (47) localdirective -> . localvardirective
    (48) localdirective -> . localdecisiondirective
    (49) localdirective -> . localmsgdirective
    (16) declarations -> . type declarationsB ; declarations
    (17) declarations -> . empty
    (97) localvardirective -> . # localvardirectiveB ID
    (101) localdecisiondirective -> . # localdecisiondirectiveB DECISION
    (102) localdecisiondirective -> . empty
    (100) localmsgdirective -> . # SHOW STRING
    (83) type -> . INT
    (84) type -> . FLOAT
    (85) type -> . STRING

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    }               reduce using rule 115 (empty -> .)
    ID              shift and go to state 152
    IF              shift and go to state 154
    PRINT           shift and go to state 140
    WHILE           shift and go to state 139
    FOR             shift and go to state 143
    INPUT           shift and go to state 151
    RETURN          shift and go to state 138
    #               shift and go to state 142
    INT             shift and go to state 13
    FLOAT           shift and go to state 11
    STRING          shift and go to state 12

  ! ID              [ reduce using rule 115 (empty -> .) ]
  ! IF              [ reduce using rule 115 (empty -> .) ]
  ! PRINT           [ reduce using rule 115 (empty -> .) ]
  ! WHILE           [ reduce using rule 115 (empty -> .) ]
  ! FOR             [ reduce using rule 115 (empty -> .) ]
  ! INPUT           [ reduce using rule 115 (empty -> .) ]
  ! RETURN          [ reduce using rule 115 (empty -> .) ]
  ! #               [ reduce using rule 115 (empty -> .) ]
  ! INT             [ reduce using rule 115 (empty -> .) ]
  ! FLOAT           [ reduce using rule 115 (empty -> .) ]
  ! STRING          [ reduce using rule 115 (empty -> .) ]

    instruction                    shift and go to state 169
    whileloop                      shift and go to state 141
    localvardirective              shift and go to state 144
    input                          shift and go to state 145
    type                           shift and go to state 14
    empty                          shift and go to state 170
    forloop                        shift and go to state 147
    return                         shift and go to state 148
    funccall                       shift and go to state 149
    localdirective                 shift and go to state 150
    condition                      shift and go to state 153
    declarations                   shift and go to state 155
    instructionB                   shift and go to state 208
    asign                          shift and go to state 156
    localmsgdirective              shift and go to state 157
    localdecisiondirective         shift and go to state 158
    output                         shift and go to state 159

state 190

    (113) paramsB -> , type . ID paramsB

    ID              shift and go to state 209


state 191

    (82) whileloop -> WHILE ( superexpression . ) block

    )               shift and go to state 210


state 192

    (93) outputB -> STRING . outputC
    (95) outputC -> . )
    (96) outputC -> . , outputB

    )               shift and go to state 211
    ,               shift and go to state 213

    outputC                        shift and go to state 212

state 193

    (94) outputB -> superexpression . outputC
    (95) outputC -> . )
    (96) outputC -> . , outputB

    )               shift and go to state 211
    ,               shift and go to state 213

    outputC                        shift and go to state 214

state 194

    (92) output -> PRINT ( outputB .

    ;               reduce using rule 92 (output -> PRINT ( outputB .)


state 195

    (100) localmsgdirective -> # SHOW STRING .

    ID              reduce using rule 100 (localmsgdirective -> # SHOW STRING .)
    IF              reduce using rule 100 (localmsgdirective -> # SHOW STRING .)
    PRINT           reduce using rule 100 (localmsgdirective -> # SHOW STRING .)
    WHILE           reduce using rule 100 (localmsgdirective -> # SHOW STRING .)
    FOR             reduce using rule 100 (localmsgdirective -> # SHOW STRING .)
    INPUT           reduce using rule 100 (localmsgdirective -> # SHOW STRING .)
    RETURN          reduce using rule 100 (localmsgdirective -> # SHOW STRING .)
    #               reduce using rule 100 (localmsgdirective -> # SHOW STRING .)
    INT             reduce using rule 100 (localmsgdirective -> # SHOW STRING .)
    FLOAT           reduce using rule 100 (localmsgdirective -> # SHOW STRING .)
    STRING          reduce using rule 100 (localmsgdirective -> # SHOW STRING .)
    }               reduce using rule 100 (localmsgdirective -> # SHOW STRING .)


state 196

    (97) localvardirective -> # localvardirectiveB ID .

    ID              reduce using rule 97 (localvardirective -> # localvardirectiveB ID .)
    IF              reduce using rule 97 (localvardirective -> # localvardirectiveB ID .)
    PRINT           reduce using rule 97 (localvardirective -> # localvardirectiveB ID .)
    WHILE           reduce using rule 97 (localvardirective -> # localvardirectiveB ID .)
    FOR             reduce using rule 97 (localvardirective -> # localvardirectiveB ID .)
    INPUT           reduce using rule 97 (localvardirective -> # localvardirectiveB ID .)
    RETURN          reduce using rule 97 (localvardirective -> # localvardirectiveB ID .)
    #               reduce using rule 97 (localvardirective -> # localvardirectiveB ID .)
    INT             reduce using rule 97 (localvardirective -> # localvardirectiveB ID .)
    FLOAT           reduce using rule 97 (localvardirective -> # localvardirectiveB ID .)
    STRING          reduce using rule 97 (localvardirective -> # localvardirectiveB ID .)
    }               reduce using rule 97 (localvardirective -> # localvardirectiveB ID .)


state 197

    (101) localdecisiondirective -> # localdecisiondirectiveB DECISION .

    ID              reduce using rule 101 (localdecisiondirective -> # localdecisiondirectiveB DECISION .)
    IF              reduce using rule 101 (localdecisiondirective -> # localdecisiondirectiveB DECISION .)
    PRINT           reduce using rule 101 (localdecisiondirective -> # localdecisiondirectiveB DECISION .)
    WHILE           reduce using rule 101 (localdecisiondirective -> # localdecisiondirectiveB DECISION .)
    FOR             reduce using rule 101 (localdecisiondirective -> # localdecisiondirectiveB DECISION .)
    INPUT           reduce using rule 101 (localdecisiondirective -> # localdecisiondirectiveB DECISION .)
    RETURN          reduce using rule 101 (localdecisiondirective -> # localdecisiondirectiveB DECISION .)
    #               reduce using rule 101 (localdecisiondirective -> # localdecisiondirectiveB DECISION .)
    INT             reduce using rule 101 (localdecisiondirective -> # localdecisiondirectiveB DECISION .)
    FLOAT           reduce using rule 101 (localdecisiondirective -> # localdecisiondirectiveB DECISION .)
    STRING          reduce using rule 101 (localdecisiondirective -> # localdecisiondirectiveB DECISION .)
    }               reduce using rule 101 (localdecisiondirective -> # localdecisiondirectiveB DECISION .)


state 198

    (88) forloop -> FOR ( asign . ; superexpression ; superexpression ) block

    ;               shift and go to state 215


state 199

    (31) asign -> ID . dimensionB = superexpression
    (21) dimensionB -> . dimension
    (22) dimensionB -> . empty
    (110) dimension -> . [ superexpression ] dimensionB
    (115) empty -> .

    [               shift and go to state 35
    =               reduce using rule 115 (empty -> .)

    dimensionB                     shift and go to state 184
    dimension                      shift and go to state 36
    empty                          shift and go to state 37

state 200

    (40) instruction -> input ; instructionB .

    }               reduce using rule 40 (instruction -> input ; instructionB .)


state 201

    (42) instruction -> return ; instructionB .

    }               reduce using rule 42 (instruction -> return ; instructionB .)


state 202

    (41) instruction -> funccall ; instructionB .

    }               reduce using rule 41 (instruction -> funccall ; instructionB .)


state 203

    (89) input -> INPUT ( ID . inputB )
    (90) inputB -> . , ID inputB
    (91) inputB -> . empty
    (115) empty -> .

    ,               shift and go to state 216
    )               reduce using rule 115 (empty -> .)

    inputB                         shift and go to state 217
    empty                          shift and go to state 218

state 204

    (31) asign -> ID dimensionB = . superexpression
    (50) superexpression -> . expression superexpressionB
    (54) expression -> . exp expressionB
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    superexpression                shift and go to state 219
    exp                            shift and go to state 59
    factor                         shift and go to state 52
    sign                           shift and go to state 56
    expression                     shift and go to state 60
    empty                          shift and go to state 53

state 205

    (36) instruction -> condition ; instructionB .

    }               reduce using rule 36 (instruction -> condition ; instructionB .)


state 206

    (32) condition -> IF ( superexpression . ) block else

    )               shift and go to state 220


state 207

    (35) instruction -> asign ; instructionB .

    }               reduce using rule 35 (instruction -> asign ; instructionB .)


state 208

    (37) instruction -> output ; instructionB .

    }               reduce using rule 37 (instruction -> output ; instructionB .)


state 209

    (113) paramsB -> , type ID . paramsB
    (113) paramsB -> . , type ID paramsB
    (114) paramsB -> . empty
    (115) empty -> .

    ,               shift and go to state 163
    )               reduce using rule 115 (empty -> .)

    paramsB                        shift and go to state 221
    empty                          shift and go to state 162

state 210

    (82) whileloop -> WHILE ( superexpression ) . block
    (30) block -> . { instruction }

    {               shift and go to state 132

    block                          shift and go to state 222

state 211

    (95) outputC -> ) .

    ;               reduce using rule 95 (outputC -> ) .)


state 212

    (93) outputB -> STRING outputC .

    ;               reduce using rule 93 (outputB -> STRING outputC .)


state 213

    (96) outputC -> , . outputB
    (93) outputB -> . STRING outputC
    (94) outputB -> . superexpression outputC
    (50) superexpression -> . expression superexpressionB
    (54) expression -> . exp expressionB
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    STRING          shift and go to state 192
    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    factor                         shift and go to state 52
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    superexpression                shift and go to state 193
    exp                            shift and go to state 59
    outputB                        shift and go to state 223
    sign                           shift and go to state 56
    expression                     shift and go to state 60
    empty                          shift and go to state 53

state 214

    (94) outputB -> superexpression outputC .

    ;               reduce using rule 94 (outputB -> superexpression outputC .)


state 215

    (88) forloop -> FOR ( asign ; . superexpression ; superexpression ) block
    (50) superexpression -> . expression superexpressionB
    (54) expression -> . exp expressionB
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    sign                           shift and go to state 56
    superexpression                shift and go to state 224
    empty                          shift and go to state 53
    exp                            shift and go to state 59
    factor                         shift and go to state 52
    expression                     shift and go to state 60

state 216

    (90) inputB -> , . ID inputB

    ID              shift and go to state 225


state 217

    (89) input -> INPUT ( ID inputB . )

    )               shift and go to state 226


state 218

    (91) inputB -> empty .

    )               reduce using rule 91 (inputB -> empty .)


state 219

    (31) asign -> ID dimensionB = superexpression .

    ;               reduce using rule 31 (asign -> ID dimensionB = superexpression .)


state 220

    (32) condition -> IF ( superexpression ) . block else
    (30) block -> . { instruction }

    {               shift and go to state 132

    block                          shift and go to state 227

state 221

    (113) paramsB -> , type ID paramsB .

    )               reduce using rule 113 (paramsB -> , type ID paramsB .)


state 222

    (82) whileloop -> WHILE ( superexpression ) block .

    ID              reduce using rule 82 (whileloop -> WHILE ( superexpression ) block .)
    IF              reduce using rule 82 (whileloop -> WHILE ( superexpression ) block .)
    PRINT           reduce using rule 82 (whileloop -> WHILE ( superexpression ) block .)
    WHILE           reduce using rule 82 (whileloop -> WHILE ( superexpression ) block .)
    FOR             reduce using rule 82 (whileloop -> WHILE ( superexpression ) block .)
    INPUT           reduce using rule 82 (whileloop -> WHILE ( superexpression ) block .)
    RETURN          reduce using rule 82 (whileloop -> WHILE ( superexpression ) block .)
    #               reduce using rule 82 (whileloop -> WHILE ( superexpression ) block .)
    INT             reduce using rule 82 (whileloop -> WHILE ( superexpression ) block .)
    FLOAT           reduce using rule 82 (whileloop -> WHILE ( superexpression ) block .)
    STRING          reduce using rule 82 (whileloop -> WHILE ( superexpression ) block .)
    }               reduce using rule 82 (whileloop -> WHILE ( superexpression ) block .)


state 223

    (96) outputC -> , outputB .

    ;               reduce using rule 96 (outputC -> , outputB .)


state 224

    (88) forloop -> FOR ( asign ; superexpression . ; superexpression ) block

    ;               shift and go to state 228


state 225

    (90) inputB -> , ID . inputB
    (90) inputB -> . , ID inputB
    (91) inputB -> . empty
    (115) empty -> .

    ,               shift and go to state 216
    )               reduce using rule 115 (empty -> .)

    inputB                         shift and go to state 229
    empty                          shift and go to state 218

state 226

    (89) input -> INPUT ( ID inputB ) .

    ;               reduce using rule 89 (input -> INPUT ( ID inputB ) .)


state 227

    (32) condition -> IF ( superexpression ) block . else
    (33) else -> . ELSE block
    (34) else -> . empty
    (115) empty -> .

    ELSE            shift and go to state 232
    ;               reduce using rule 115 (empty -> .)

    empty                          shift and go to state 231
    else                           shift and go to state 230

state 228

    (88) forloop -> FOR ( asign ; superexpression ; . superexpression ) block
    (50) superexpression -> . expression superexpressionB
    (54) expression -> . exp expressionB
    (62) exp -> . term expB
    (66) term -> . factor termB
    (70) factor -> . signB constant
    (71) factor -> . ( superexpression )
    (72) factor -> . funccall
    (73) factor -> . ID dimensionB
    (74) signB -> . sign
    (75) signB -> . empty
    (105) funccall -> . ID ( funccallB )
    (80) sign -> . +
    (81) sign -> . -
    (115) empty -> .

    (               shift and go to state 49
    ID              shift and go to state 57
    +               shift and go to state 50
    -               shift and go to state 51
    FCONST          reduce using rule 115 (empty -> .)
    ICONST          reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)

    term                           shift and go to state 58
    funccall                       shift and go to state 54
    signB                          shift and go to state 48
    sign                           shift and go to state 56
    superexpression                shift and go to state 233
    empty                          shift and go to state 53
    exp                            shift and go to state 59
    factor                         shift and go to state 52
    expression                     shift and go to state 60

state 229

    (90) inputB -> , ID inputB .

    )               reduce using rule 90 (inputB -> , ID inputB .)


state 230

    (32) condition -> IF ( superexpression ) block else .

    ;               reduce using rule 32 (condition -> IF ( superexpression ) block else .)


state 231

    (34) else -> empty .

    ;               reduce using rule 34 (else -> empty .)


state 232

    (33) else -> ELSE . block
    (30) block -> . { instruction }

    {               shift and go to state 132

    block                          shift and go to state 234

state 233

    (88) forloop -> FOR ( asign ; superexpression ; superexpression . ) block

    )               shift and go to state 235


state 234

    (33) else -> ELSE block .

    ;               reduce using rule 33 (else -> ELSE block .)


state 235

    (88) forloop -> FOR ( asign ; superexpression ; superexpression ) . block
    (30) block -> . { instruction }

    {               shift and go to state 132

    block                          shift and go to state 236

state 236

    (88) forloop -> FOR ( asign ; superexpression ; superexpression ) block .

    ID              reduce using rule 88 (forloop -> FOR ( asign ; superexpression ; superexpression ) block .)
    IF              reduce using rule 88 (forloop -> FOR ( asign ; superexpression ; superexpression ) block .)
    PRINT           reduce using rule 88 (forloop -> FOR ( asign ; superexpression ; superexpression ) block .)
    WHILE           reduce using rule 88 (forloop -> FOR ( asign ; superexpression ; superexpression ) block .)
    FOR             reduce using rule 88 (forloop -> FOR ( asign ; superexpression ; superexpression ) block .)
    INPUT           reduce using rule 88 (forloop -> FOR ( asign ; superexpression ; superexpression ) block .)
    RETURN          reduce using rule 88 (forloop -> FOR ( asign ; superexpression ; superexpression ) block .)
    #               reduce using rule 88 (forloop -> FOR ( asign ; superexpression ; superexpression ) block .)
    INT             reduce using rule 88 (forloop -> FOR ( asign ; superexpression ; superexpression ) block .)
    FLOAT           reduce using rule 88 (forloop -> FOR ( asign ; superexpression ; superexpression ) block .)
    STRING          reduce using rule 88 (forloop -> FOR ( asign ; superexpression ; superexpression ) block .)
    }               reduce using rule 88 (forloop -> FOR ( asign ; superexpression ; superexpression ) block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DEF in state 15 resolved as shift
WARNING: shift/reduce conflict for INT in state 38 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 38 resolved as shift
WARNING: shift/reduce conflict for STRING in state 38 resolved as shift
WARNING: shift/reduce conflict for DEF in state 63 resolved as shift
WARNING: shift/reduce conflict for ID in state 132 resolved as shift
WARNING: shift/reduce conflict for IF in state 132 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 132 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 132 resolved as shift
WARNING: shift/reduce conflict for FOR in state 132 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 132 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 132 resolved as shift
WARNING: shift/reduce conflict for # in state 132 resolved as shift
WARNING: shift/reduce conflict for INT in state 132 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 132 resolved as shift
WARNING: shift/reduce conflict for STRING in state 132 resolved as shift
WARNING: shift/reduce conflict for ID in state 141 resolved as shift
WARNING: shift/reduce conflict for IF in state 141 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 141 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 141 resolved as shift
WARNING: shift/reduce conflict for FOR in state 141 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 141 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 141 resolved as shift
WARNING: shift/reduce conflict for # in state 141 resolved as shift
WARNING: shift/reduce conflict for INT in state 141 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 141 resolved as shift
WARNING: shift/reduce conflict for STRING in state 141 resolved as shift
WARNING: shift/reduce conflict for ID in state 147 resolved as shift
WARNING: shift/reduce conflict for IF in state 147 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 147 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 147 resolved as shift
WARNING: shift/reduce conflict for FOR in state 147 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 147 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 147 resolved as shift
WARNING: shift/reduce conflict for # in state 147 resolved as shift
WARNING: shift/reduce conflict for INT in state 147 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 147 resolved as shift
WARNING: shift/reduce conflict for STRING in state 147 resolved as shift
WARNING: shift/reduce conflict for ID in state 150 resolved as shift
WARNING: shift/reduce conflict for IF in state 150 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 150 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 150 resolved as shift
WARNING: shift/reduce conflict for FOR in state 150 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 150 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 150 resolved as shift
WARNING: shift/reduce conflict for # in state 150 resolved as shift
WARNING: shift/reduce conflict for INT in state 150 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 150 resolved as shift
WARNING: shift/reduce conflict for STRING in state 150 resolved as shift
WARNING: shift/reduce conflict for ID in state 155 resolved as shift
WARNING: shift/reduce conflict for IF in state 155 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 155 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 155 resolved as shift
WARNING: shift/reduce conflict for FOR in state 155 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 155 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 155 resolved as shift
WARNING: shift/reduce conflict for # in state 155 resolved as shift
WARNING: shift/reduce conflict for INT in state 155 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 155 resolved as shift
WARNING: shift/reduce conflict for STRING in state 155 resolved as shift
WARNING: shift/reduce conflict for ID in state 178 resolved as shift
WARNING: shift/reduce conflict for IF in state 178 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 178 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 178 resolved as shift
WARNING: shift/reduce conflict for FOR in state 178 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 178 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 178 resolved as shift
WARNING: shift/reduce conflict for # in state 178 resolved as shift
WARNING: shift/reduce conflict for INT in state 178 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 178 resolved as shift
WARNING: shift/reduce conflict for STRING in state 178 resolved as shift
WARNING: shift/reduce conflict for ID in state 180 resolved as shift
WARNING: shift/reduce conflict for IF in state 180 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 180 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 180 resolved as shift
WARNING: shift/reduce conflict for FOR in state 180 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 180 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 180 resolved as shift
WARNING: shift/reduce conflict for # in state 180 resolved as shift
WARNING: shift/reduce conflict for INT in state 180 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 180 resolved as shift
WARNING: shift/reduce conflict for STRING in state 180 resolved as shift
WARNING: shift/reduce conflict for ID in state 181 resolved as shift
WARNING: shift/reduce conflict for IF in state 181 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 181 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 181 resolved as shift
WARNING: shift/reduce conflict for FOR in state 181 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 181 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 181 resolved as shift
WARNING: shift/reduce conflict for # in state 181 resolved as shift
WARNING: shift/reduce conflict for INT in state 181 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 181 resolved as shift
WARNING: shift/reduce conflict for STRING in state 181 resolved as shift
WARNING: shift/reduce conflict for ID in state 185 resolved as shift
WARNING: shift/reduce conflict for IF in state 185 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 185 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 185 resolved as shift
WARNING: shift/reduce conflict for FOR in state 185 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 185 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 185 resolved as shift
WARNING: shift/reduce conflict for # in state 185 resolved as shift
WARNING: shift/reduce conflict for INT in state 185 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 185 resolved as shift
WARNING: shift/reduce conflict for STRING in state 185 resolved as shift
WARNING: shift/reduce conflict for ID in state 188 resolved as shift
WARNING: shift/reduce conflict for IF in state 188 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 188 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 188 resolved as shift
WARNING: shift/reduce conflict for FOR in state 188 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 188 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 188 resolved as shift
WARNING: shift/reduce conflict for # in state 188 resolved as shift
WARNING: shift/reduce conflict for INT in state 188 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 188 resolved as shift
WARNING: shift/reduce conflict for STRING in state 188 resolved as shift
WARNING: shift/reduce conflict for ID in state 189 resolved as shift
WARNING: shift/reduce conflict for IF in state 189 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 189 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 189 resolved as shift
WARNING: shift/reduce conflict for FOR in state 189 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 189 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 189 resolved as shift
WARNING: shift/reduce conflict for # in state 189 resolved as shift
WARNING: shift/reduce conflict for INT in state 189 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 189 resolved as shift
WARNING: shift/reduce conflict for STRING in state 189 resolved as shift
WARNING: reduce/reduce conflict in state 40 resolved using rule (funcB -> empty)
WARNING: rejected rule (func -> empty) in state 40
WARNING: reduce/reduce conflict in state 146 resolved using rule (declarations -> empty)
WARNING: rejected rule (localdecisiondirective -> empty) in state 146
WARNING: reduce/reduce conflict in state 170 resolved using rule (declarations -> empty)
WARNING: rejected rule (instructionB -> empty) in state 170
WARNING: reduce/reduce conflict in state 170 resolved using rule (declarations -> empty)
WARNING: rejected rule (localdecisiondirective -> empty) in state 170
WARNING: Rule (localdecisiondirective -> empty) is never reduced
WARNING: Rule (instructionB -> empty) is never reduced
