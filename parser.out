Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> config body
Rule 2     config -> configdirective config
Rule 3     config -> empty
Rule 4     configdirective -> VARSCONFIG = options
Rule 5     configdirective -> DECISIONSCONFIG = options
Rule 6     configdirective -> COMPLEXITYCONFIG = optionsyesno
Rule 7     options -> SOME
Rule 8     options -> ALL
Rule 9     options -> MOST
Rule 10    options -> NONE
Rule 11    optionsyesno -> YES
Rule 12    optionsyesno -> NO
Rule 13    body -> declarationsOpt funcsOpt main funcsOpt
Rule 14    funcsOpt -> suprafunc funcsOpt
Rule 15    funcsOpt -> empty
Rule 16    declarationsOpt -> declaration declarationsOpt
Rule 17    declarationsOpt -> empty
Rule 18    declaration -> type push_type declarationB declarationC
Rule 19    declarationB -> ID push_operand dimensionsOpt
Rule 20    push_operand -> <empty>
Rule 21    push_type -> <empty>
Rule 22    push_operator -> <empty>
Rule 23    quadruple_assign -> <empty>
Rule 24    declarationC -> = push_operator superexpression quadruple_assign declarationD
Rule 25    declarationC -> , declarationB declarationC
Rule 26    declarationC -> ;
Rule 27    declarationD -> , declarationB declarationC
Rule 28    declarationD -> ;
Rule 29    main -> MAIN ( ) block
Rule 30    suprafunc -> func block
Rule 31    func -> DEF returntype ID ( paramsOpt )
Rule 32    paramsOpt -> params paramsB
Rule 33    paramsOpt -> empty
Rule 34    block -> { instructionsOpt }
Rule 35    instructionsOpt -> instruction instructionsOpt
Rule 36    instructionsOpt -> empty
Rule 37    assign -> ID dimensionsOpt = superexpression
Rule 38    assignB -> dimensionsOpt = superexpression
Rule 39    dimensionsOpt -> dimensions
Rule 40    dimensionsOpt -> empty
Rule 41    condition -> IF ( superexpression ) block else
Rule 42    else -> ELSE block
Rule 43    else -> empty
Rule 44    instruction -> assignfunccall ;
Rule 45    instruction -> output ;
Rule 46    instruction -> return ;
Rule 47    instruction -> input ;
Rule 48    instruction -> declaration
Rule 49    instruction -> condition
Rule 50    instruction -> whileloop
Rule 51    instruction -> forloop
Rule 52    instruction -> localdirective
Rule 53    assignfunccall -> ID assignfunccallB
Rule 54    assignfunccallB -> ( funccallB funccallC
Rule 55    assignfunccallB -> assignB
Rule 56    localdirective -> localvardirective
Rule 57    localdirective -> localdecisiondirective
Rule 58    localdirective -> localmsgdirective
Rule 59    superexpression -> expression superexpressionB
Rule 60    superexpressionB -> & & superexpression
Rule 61    superexpressionB -> | | superexpression
Rule 62    superexpressionB -> empty
Rule 63    expression -> exp expressionB
Rule 64    expressionB -> < exp
Rule 65    expressionB -> > exp
Rule 66    expressionB -> < > exp
Rule 67    expressionB -> = = exp
Rule 68    expressionB -> < = exp
Rule 69    expressionB -> > = exp
Rule 70    expressionB -> empty
Rule 71    exp -> term expB
Rule 72    expB -> - exp
Rule 73    expB -> + exp
Rule 74    expB -> empty
Rule 75    term -> factor termB
Rule 76    termB -> / term
Rule 77    termB -> * term
Rule 78    termB -> empty
Rule 79    factor -> signB constant
Rule 80    factor -> ( superexpression )
Rule 81    factor -> funccall
Rule 82    factor -> ID seen_ID dimensionsOpt
Rule 83    seen_ID -> <empty>
Rule 84    signB -> sign
Rule 85    signB -> empty
Rule 86    constant -> FCONST
Rule 87    constant -> ICONST
Rule 88    constant -> SCONST
Rule 89    constant -> TRUE
Rule 90    constant -> FALSE
Rule 91    sign -> +
Rule 92    sign -> -
Rule 93    whileloop -> WHILE ( superexpression ) block
Rule 94    type -> INT
Rule 95    type -> FLOAT
Rule 96    type -> STRING
Rule 97    type -> BOOL
Rule 98    returntype -> VOID
Rule 99    returntype -> type
Rule 100   forloop -> FOR ( assign ; superexpression ; superexpression ) block
Rule 101   input -> INPUT ( ID inputB )
Rule 102   inputB -> , ID inputB
Rule 103   inputB -> empty
Rule 104   output -> PRINT ( outputB
Rule 105   outputB -> SCONST outputC
Rule 106   outputB -> superexpression outputC
Rule 107   outputC -> )
Rule 108   outputC -> , outputB
Rule 109   localvardirective -> # localvardirectiveB ID
Rule 110   localvardirectiveB -> TRACK
Rule 111   localvardirectiveB -> FORGET
Rule 112   localmsgdirective -> # SHOW SCONST
Rule 113   localdecisiondirective -> TRACKDECISION
Rule 114   localdecisiondirective -> FORGETDECISION
Rule 115   localdecisiondirective -> empty
Rule 116   funccall -> ID ( funccallB funccallC
Rule 117   funccallB -> superexpression
Rule 118   funccallB -> empty
Rule 119   funccallC -> , funccallB funccallC
Rule 120   funccallC -> )
Rule 121   dimensions -> [ superexpression ] dimensionsB
Rule 122   dimensionsB -> [ superexpression ]
Rule 123   dimensionsB -> empty
Rule 124   return -> RETURN superexpression
Rule 125   params -> type ID
Rule 126   paramsB -> , params paramsB
Rule 127   paramsB -> empty
Rule 128   empty -> <empty>

Terminals, with rules where they appear

#                    : 109 112
&                    : 60 60
(                    : 29 31 41 54 80 93 100 101 104 116
)                    : 29 31 41 80 93 100 101 107 120
*                    : 77
+                    : 73 91
,                    : 25 27 102 108 119 126
-                    : 72 92
/                    : 76
;                    : 26 28 44 45 46 47 100 100
<                    : 64 66 68
=                    : 4 5 6 24 37 38 67 67 68 69
>                    : 65 66 69
ALL                  : 8
BOOL                 : 97
COMPLEXITYCONFIG     : 6
DECISIONSCONFIG      : 5
DEF                  : 31
ELSE                 : 42
FALSE                : 90
FCONST               : 86
FLOAT                : 95
FOR                  : 100
FORGET               : 111
FORGETDECISION       : 114
ICONST               : 87
ID                   : 19 31 37 53 82 101 102 109 116 125
IF                   : 41
INPUT                : 101
INT                  : 94
MAIN                 : 29
MOST                 : 9
NO                   : 12
NONE                 : 10
PRINT                : 104
RETURN               : 124
SCONST               : 88 105 112
SHOW                 : 112
SOME                 : 7
STRING               : 96
TRACK                : 110
TRACKDECISION        : 113
TRUE                 : 89
VARSCONFIG           : 4
VOID                 : 98
WHILE                : 93
YES                  : 11
[                    : 121 122
]                    : 121 122
error                : 
{                    : 34
|                    : 61 61
}                    : 34

Nonterminals, with rules where they appear

assign               : 100
assignB              : 55
assignfunccall       : 44
assignfunccallB      : 53
block                : 29 30 41 42 93 100
body                 : 1
condition            : 49
config               : 1 2
configdirective      : 2
constant             : 79
declaration          : 16 48
declarationB         : 18 25 27
declarationC         : 18 25 27
declarationD         : 24
declarationsOpt      : 13 16
dimensions           : 39
dimensionsB          : 121
dimensionsOpt        : 19 37 38 82
else                 : 41
empty                : 3 15 17 33 36 40 43 62 70 74 78 85 103 115 118 123 127
exp                  : 63 64 65 66 67 68 69 72 73
expB                 : 71
expression           : 59
expressionB          : 63
factor               : 75
forloop              : 51
func                 : 30
funccall             : 81
funccallB            : 54 116 119
funccallC            : 54 116 119
funcsOpt             : 13 13 14
input                : 47
inputB               : 101 102
instruction          : 35
instructionsOpt      : 34 35
localdecisiondirective : 57
localdirective       : 52
localmsgdirective    : 58
localvardirective    : 56
localvardirectiveB   : 109
main                 : 13
options              : 4 5
optionsyesno         : 6
output               : 45
outputB              : 104 108
outputC              : 105 106
params               : 32 126
paramsB              : 32 126
paramsOpt            : 31
program              : 0
push_operand         : 19
push_operator        : 24
push_type            : 18
quadruple_assign     : 24
return               : 46
returntype           : 31
seen_ID              : 82
sign                 : 84
signB                : 79
superexpression      : 24 37 38 41 60 61 80 93 100 100 106 117 121 122 124
superexpressionB     : 59
suprafunc            : 14
term                 : 71 76 77
termB                : 75
type                 : 18 99 125
whileloop            : 50

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . config body
    (2) config -> . configdirective config
    (3) config -> . empty
    (4) configdirective -> . VARSCONFIG = options
    (5) configdirective -> . DECISIONSCONFIG = options
    (6) configdirective -> . COMPLEXITYCONFIG = optionsyesno
    (128) empty -> .

    VARSCONFIG      shift and go to state 2
    DECISIONSCONFIG shift and go to state 1
    COMPLEXITYCONFIG shift and go to state 4
    INT             reduce using rule 128 (empty -> .)
    FLOAT           reduce using rule 128 (empty -> .)
    STRING          reduce using rule 128 (empty -> .)
    BOOL            reduce using rule 128 (empty -> .)
    DEF             reduce using rule 128 (empty -> .)
    MAIN            reduce using rule 128 (empty -> .)

    configdirective                shift and go to state 3
    program                        shift and go to state 5
    config                         shift and go to state 6
    empty                          shift and go to state 7

state 1

    (5) configdirective -> DECISIONSCONFIG . = options

    =               shift and go to state 8


state 2

    (4) configdirective -> VARSCONFIG . = options

    =               shift and go to state 9


state 3

    (2) config -> configdirective . config
    (2) config -> . configdirective config
    (3) config -> . empty
    (4) configdirective -> . VARSCONFIG = options
    (5) configdirective -> . DECISIONSCONFIG = options
    (6) configdirective -> . COMPLEXITYCONFIG = optionsyesno
    (128) empty -> .

    VARSCONFIG      shift and go to state 2
    DECISIONSCONFIG shift and go to state 1
    COMPLEXITYCONFIG shift and go to state 4
    INT             reduce using rule 128 (empty -> .)
    FLOAT           reduce using rule 128 (empty -> .)
    STRING          reduce using rule 128 (empty -> .)
    BOOL            reduce using rule 128 (empty -> .)
    DEF             reduce using rule 128 (empty -> .)
    MAIN            reduce using rule 128 (empty -> .)

    config                         shift and go to state 10
    empty                          shift and go to state 7
    configdirective                shift and go to state 3

state 4

    (6) configdirective -> COMPLEXITYCONFIG . = optionsyesno

    =               shift and go to state 11


state 5

    (0) S' -> program .



state 6

    (1) program -> config . body
    (13) body -> . declarationsOpt funcsOpt main funcsOpt
    (16) declarationsOpt -> . declaration declarationsOpt
    (17) declarationsOpt -> . empty
    (18) declaration -> . type push_type declarationB declarationC
    (128) empty -> .
    (94) type -> . INT
    (95) type -> . FLOAT
    (96) type -> . STRING
    (97) type -> . BOOL

    DEF             reduce using rule 128 (empty -> .)
    MAIN            reduce using rule 128 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18

    body                           shift and go to state 12
    declarationsOpt                shift and go to state 13
    type                           shift and go to state 16
    declaration                    shift and go to state 19
    empty                          shift and go to state 20

state 7

    (3) config -> empty .

    INT             reduce using rule 3 (config -> empty .)
    FLOAT           reduce using rule 3 (config -> empty .)
    STRING          reduce using rule 3 (config -> empty .)
    BOOL            reduce using rule 3 (config -> empty .)
    DEF             reduce using rule 3 (config -> empty .)
    MAIN            reduce using rule 3 (config -> empty .)


state 8

    (5) configdirective -> DECISIONSCONFIG = . options
    (7) options -> . SOME
    (8) options -> . ALL
    (9) options -> . MOST
    (10) options -> . NONE

    SOME            shift and go to state 22
    ALL             shift and go to state 21
    MOST            shift and go to state 24
    NONE            shift and go to state 23

    options                        shift and go to state 25

state 9

    (4) configdirective -> VARSCONFIG = . options
    (7) options -> . SOME
    (8) options -> . ALL
    (9) options -> . MOST
    (10) options -> . NONE

    SOME            shift and go to state 22
    ALL             shift and go to state 21
    MOST            shift and go to state 24
    NONE            shift and go to state 23

    options                        shift and go to state 26

state 10

    (2) config -> configdirective config .

    INT             reduce using rule 2 (config -> configdirective config .)
    FLOAT           reduce using rule 2 (config -> configdirective config .)
    STRING          reduce using rule 2 (config -> configdirective config .)
    BOOL            reduce using rule 2 (config -> configdirective config .)
    DEF             reduce using rule 2 (config -> configdirective config .)
    MAIN            reduce using rule 2 (config -> configdirective config .)


state 11

    (6) configdirective -> COMPLEXITYCONFIG = . optionsyesno
    (11) optionsyesno -> . YES
    (12) optionsyesno -> . NO

    YES             shift and go to state 27
    NO              shift and go to state 29

    optionsyesno                   shift and go to state 28

state 12

    (1) program -> config body .

    $end            reduce using rule 1 (program -> config body .)


state 13

    (13) body -> declarationsOpt . funcsOpt main funcsOpt
    (14) funcsOpt -> . suprafunc funcsOpt
    (15) funcsOpt -> . empty
    (30) suprafunc -> . func block
    (128) empty -> .
    (31) func -> . DEF returntype ID ( paramsOpt )

    MAIN            reduce using rule 128 (empty -> .)
    DEF             shift and go to state 33

    suprafunc                      shift and go to state 30
    funcsOpt                       shift and go to state 31
    func                           shift and go to state 32
    empty                          shift and go to state 34

state 14

    (96) type -> STRING .

    ID              reduce using rule 96 (type -> STRING .)


state 15

    (94) type -> INT .

    ID              reduce using rule 94 (type -> INT .)


state 16

    (18) declaration -> type . push_type declarationB declarationC
    (21) push_type -> .

    ID              reduce using rule 21 (push_type -> .)

    push_type                      shift and go to state 35

state 17

    (95) type -> FLOAT .

    ID              reduce using rule 95 (type -> FLOAT .)


state 18

    (97) type -> BOOL .

    ID              reduce using rule 97 (type -> BOOL .)


state 19

    (16) declarationsOpt -> declaration . declarationsOpt
    (16) declarationsOpt -> . declaration declarationsOpt
    (17) declarationsOpt -> . empty
    (18) declaration -> . type push_type declarationB declarationC
    (128) empty -> .
    (94) type -> . INT
    (95) type -> . FLOAT
    (96) type -> . STRING
    (97) type -> . BOOL

    DEF             reduce using rule 128 (empty -> .)
    MAIN            reduce using rule 128 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18

    declarationsOpt                shift and go to state 36
    declaration                    shift and go to state 19
    type                           shift and go to state 16
    empty                          shift and go to state 20

state 20

    (17) declarationsOpt -> empty .

    DEF             reduce using rule 17 (declarationsOpt -> empty .)
    MAIN            reduce using rule 17 (declarationsOpt -> empty .)


state 21

    (8) options -> ALL .

    VARSCONFIG      reduce using rule 8 (options -> ALL .)
    DECISIONSCONFIG reduce using rule 8 (options -> ALL .)
    COMPLEXITYCONFIG reduce using rule 8 (options -> ALL .)
    INT             reduce using rule 8 (options -> ALL .)
    FLOAT           reduce using rule 8 (options -> ALL .)
    STRING          reduce using rule 8 (options -> ALL .)
    BOOL            reduce using rule 8 (options -> ALL .)
    DEF             reduce using rule 8 (options -> ALL .)
    MAIN            reduce using rule 8 (options -> ALL .)


state 22

    (7) options -> SOME .

    VARSCONFIG      reduce using rule 7 (options -> SOME .)
    DECISIONSCONFIG reduce using rule 7 (options -> SOME .)
    COMPLEXITYCONFIG reduce using rule 7 (options -> SOME .)
    INT             reduce using rule 7 (options -> SOME .)
    FLOAT           reduce using rule 7 (options -> SOME .)
    STRING          reduce using rule 7 (options -> SOME .)
    BOOL            reduce using rule 7 (options -> SOME .)
    DEF             reduce using rule 7 (options -> SOME .)
    MAIN            reduce using rule 7 (options -> SOME .)


state 23

    (10) options -> NONE .

    VARSCONFIG      reduce using rule 10 (options -> NONE .)
    DECISIONSCONFIG reduce using rule 10 (options -> NONE .)
    COMPLEXITYCONFIG reduce using rule 10 (options -> NONE .)
    INT             reduce using rule 10 (options -> NONE .)
    FLOAT           reduce using rule 10 (options -> NONE .)
    STRING          reduce using rule 10 (options -> NONE .)
    BOOL            reduce using rule 10 (options -> NONE .)
    DEF             reduce using rule 10 (options -> NONE .)
    MAIN            reduce using rule 10 (options -> NONE .)


state 24

    (9) options -> MOST .

    VARSCONFIG      reduce using rule 9 (options -> MOST .)
    DECISIONSCONFIG reduce using rule 9 (options -> MOST .)
    COMPLEXITYCONFIG reduce using rule 9 (options -> MOST .)
    INT             reduce using rule 9 (options -> MOST .)
    FLOAT           reduce using rule 9 (options -> MOST .)
    STRING          reduce using rule 9 (options -> MOST .)
    BOOL            reduce using rule 9 (options -> MOST .)
    DEF             reduce using rule 9 (options -> MOST .)
    MAIN            reduce using rule 9 (options -> MOST .)


state 25

    (5) configdirective -> DECISIONSCONFIG = options .

    VARSCONFIG      reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    DECISIONSCONFIG reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    COMPLEXITYCONFIG reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    INT             reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    FLOAT           reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    STRING          reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    BOOL            reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    DEF             reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)
    MAIN            reduce using rule 5 (configdirective -> DECISIONSCONFIG = options .)


state 26

    (4) configdirective -> VARSCONFIG = options .

    VARSCONFIG      reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    DECISIONSCONFIG reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    COMPLEXITYCONFIG reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    INT             reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    FLOAT           reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    STRING          reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    BOOL            reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    DEF             reduce using rule 4 (configdirective -> VARSCONFIG = options .)
    MAIN            reduce using rule 4 (configdirective -> VARSCONFIG = options .)


state 27

    (11) optionsyesno -> YES .

    VARSCONFIG      reduce using rule 11 (optionsyesno -> YES .)
    DECISIONSCONFIG reduce using rule 11 (optionsyesno -> YES .)
    COMPLEXITYCONFIG reduce using rule 11 (optionsyesno -> YES .)
    INT             reduce using rule 11 (optionsyesno -> YES .)
    FLOAT           reduce using rule 11 (optionsyesno -> YES .)
    STRING          reduce using rule 11 (optionsyesno -> YES .)
    BOOL            reduce using rule 11 (optionsyesno -> YES .)
    DEF             reduce using rule 11 (optionsyesno -> YES .)
    MAIN            reduce using rule 11 (optionsyesno -> YES .)


state 28

    (6) configdirective -> COMPLEXITYCONFIG = optionsyesno .

    VARSCONFIG      reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    DECISIONSCONFIG reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    COMPLEXITYCONFIG reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    INT             reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    FLOAT           reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    STRING          reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    BOOL            reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    DEF             reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)
    MAIN            reduce using rule 6 (configdirective -> COMPLEXITYCONFIG = optionsyesno .)


state 29

    (12) optionsyesno -> NO .

    VARSCONFIG      reduce using rule 12 (optionsyesno -> NO .)
    DECISIONSCONFIG reduce using rule 12 (optionsyesno -> NO .)
    COMPLEXITYCONFIG reduce using rule 12 (optionsyesno -> NO .)
    INT             reduce using rule 12 (optionsyesno -> NO .)
    FLOAT           reduce using rule 12 (optionsyesno -> NO .)
    STRING          reduce using rule 12 (optionsyesno -> NO .)
    BOOL            reduce using rule 12 (optionsyesno -> NO .)
    DEF             reduce using rule 12 (optionsyesno -> NO .)
    MAIN            reduce using rule 12 (optionsyesno -> NO .)


state 30

    (14) funcsOpt -> suprafunc . funcsOpt
    (14) funcsOpt -> . suprafunc funcsOpt
    (15) funcsOpt -> . empty
    (30) suprafunc -> . func block
    (128) empty -> .
    (31) func -> . DEF returntype ID ( paramsOpt )

    MAIN            reduce using rule 128 (empty -> .)
    $end            reduce using rule 128 (empty -> .)
    DEF             shift and go to state 33

    suprafunc                      shift and go to state 30
    funcsOpt                       shift and go to state 37
    empty                          shift and go to state 34
    func                           shift and go to state 32

state 31

    (13) body -> declarationsOpt funcsOpt . main funcsOpt
    (29) main -> . MAIN ( ) block

    MAIN            shift and go to state 38

    main                           shift and go to state 39

state 32

    (30) suprafunc -> func . block
    (34) block -> . { instructionsOpt }

    {               shift and go to state 40

    block                          shift and go to state 41

state 33

    (31) func -> DEF . returntype ID ( paramsOpt )
    (98) returntype -> . VOID
    (99) returntype -> . type
    (94) type -> . INT
    (95) type -> . FLOAT
    (96) type -> . STRING
    (97) type -> . BOOL

    VOID            shift and go to state 42
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18

    returntype                     shift and go to state 43
    type                           shift and go to state 44

state 34

    (15) funcsOpt -> empty .

    MAIN            reduce using rule 15 (funcsOpt -> empty .)
    $end            reduce using rule 15 (funcsOpt -> empty .)


state 35

    (18) declaration -> type push_type . declarationB declarationC
    (19) declarationB -> . ID push_operand dimensionsOpt

    ID              shift and go to state 45

    declarationB                   shift and go to state 46

state 36

    (16) declarationsOpt -> declaration declarationsOpt .

    DEF             reduce using rule 16 (declarationsOpt -> declaration declarationsOpt .)
    MAIN            reduce using rule 16 (declarationsOpt -> declaration declarationsOpt .)


state 37

    (14) funcsOpt -> suprafunc funcsOpt .

    MAIN            reduce using rule 14 (funcsOpt -> suprafunc funcsOpt .)
    $end            reduce using rule 14 (funcsOpt -> suprafunc funcsOpt .)


state 38

    (29) main -> MAIN . ( ) block

    (               shift and go to state 47


state 39

    (13) body -> declarationsOpt funcsOpt main . funcsOpt
    (14) funcsOpt -> . suprafunc funcsOpt
    (15) funcsOpt -> . empty
    (30) suprafunc -> . func block
    (128) empty -> .
    (31) func -> . DEF returntype ID ( paramsOpt )

    $end            reduce using rule 128 (empty -> .)
    DEF             shift and go to state 33

    suprafunc                      shift and go to state 30
    funcsOpt                       shift and go to state 48
    func                           shift and go to state 32
    empty                          shift and go to state 34

state 40

    (34) block -> { . instructionsOpt }
    (35) instructionsOpt -> . instruction instructionsOpt
    (36) instructionsOpt -> . empty
    (44) instruction -> . assignfunccall ;
    (45) instruction -> . output ;
    (46) instruction -> . return ;
    (47) instruction -> . input ;
    (48) instruction -> . declaration
    (49) instruction -> . condition
    (50) instruction -> . whileloop
    (51) instruction -> . forloop
    (52) instruction -> . localdirective
    (128) empty -> .
    (53) assignfunccall -> . ID assignfunccallB
    (104) output -> . PRINT ( outputB
    (124) return -> . RETURN superexpression
    (101) input -> . INPUT ( ID inputB )
    (18) declaration -> . type push_type declarationB declarationC
    (41) condition -> . IF ( superexpression ) block else
    (93) whileloop -> . WHILE ( superexpression ) block
    (100) forloop -> . FOR ( assign ; superexpression ; superexpression ) block
    (56) localdirective -> . localvardirective
    (57) localdirective -> . localdecisiondirective
    (58) localdirective -> . localmsgdirective
    (94) type -> . INT
    (95) type -> . FLOAT
    (96) type -> . STRING
    (97) type -> . BOOL
    (109) localvardirective -> . # localvardirectiveB ID
    (113) localdecisiondirective -> . TRACKDECISION
    (114) localdecisiondirective -> . FORGETDECISION
    (115) localdecisiondirective -> . empty
    (112) localmsgdirective -> . # SHOW SCONST

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for TRACKDECISION resolved as shift
  ! shift/reduce conflict for FORGETDECISION resolved as shift
    }               reduce using rule 128 (empty -> .)
    ID              shift and go to state 67
    PRINT           shift and go to state 52
    RETURN          shift and go to state 49
    INPUT           shift and go to state 66
    IF              shift and go to state 69
    WHILE           shift and go to state 51
    FOR             shift and go to state 61
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18
    #               shift and go to state 54
    TRACKDECISION   shift and go to state 56
    FORGETDECISION  shift and go to state 63

  ! ID              [ reduce using rule 128 (empty -> .) ]
  ! PRINT           [ reduce using rule 128 (empty -> .) ]
  ! RETURN          [ reduce using rule 128 (empty -> .) ]
  ! INPUT           [ reduce using rule 128 (empty -> .) ]
  ! IF              [ reduce using rule 128 (empty -> .) ]
  ! WHILE           [ reduce using rule 128 (empty -> .) ]
  ! FOR             [ reduce using rule 128 (empty -> .) ]
  ! INT             [ reduce using rule 128 (empty -> .) ]
  ! FLOAT           [ reduce using rule 128 (empty -> .) ]
  ! STRING          [ reduce using rule 128 (empty -> .) ]
  ! BOOL            [ reduce using rule 128 (empty -> .) ]
  ! #               [ reduce using rule 128 (empty -> .) ]
  ! TRACKDECISION   [ reduce using rule 128 (empty -> .) ]
  ! FORGETDECISION  [ reduce using rule 128 (empty -> .) ]

    assignfunccall                 shift and go to state 50
    whileloop                      shift and go to state 53
    localvardirective              shift and go to state 55
    input                          shift and go to state 57
    type                           shift and go to state 16
    empty                          shift and go to state 58
    forloop                        shift and go to state 59
    return                         shift and go to state 60
    instructionsOpt                shift and go to state 62
    localdirective                 shift and go to state 64
    declaration                    shift and go to state 65
    condition                      shift and go to state 68
    instruction                    shift and go to state 70
    localmsgdirective              shift and go to state 71
    localdecisiondirective         shift and go to state 72
    output                         shift and go to state 73

state 41

    (30) suprafunc -> func block .

    DEF             reduce using rule 30 (suprafunc -> func block .)
    MAIN            reduce using rule 30 (suprafunc -> func block .)
    $end            reduce using rule 30 (suprafunc -> func block .)


state 42

    (98) returntype -> VOID .

    ID              reduce using rule 98 (returntype -> VOID .)


state 43

    (31) func -> DEF returntype . ID ( paramsOpt )

    ID              shift and go to state 74


state 44

    (99) returntype -> type .

    ID              reduce using rule 99 (returntype -> type .)


state 45

    (19) declarationB -> ID . push_operand dimensionsOpt
    (20) push_operand -> .

    [               reduce using rule 20 (push_operand -> .)
    =               reduce using rule 20 (push_operand -> .)
    ,               reduce using rule 20 (push_operand -> .)
    ;               reduce using rule 20 (push_operand -> .)

    push_operand                   shift and go to state 75

state 46

    (18) declaration -> type push_type declarationB . declarationC
    (24) declarationC -> . = push_operator superexpression quadruple_assign declarationD
    (25) declarationC -> . , declarationB declarationC
    (26) declarationC -> . ;

    =               shift and go to state 79
    ,               shift and go to state 76
    ;               shift and go to state 77

    declarationC                   shift and go to state 78

state 47

    (29) main -> MAIN ( . ) block

    )               shift and go to state 80


state 48

    (13) body -> declarationsOpt funcsOpt main funcsOpt .

    $end            reduce using rule 13 (body -> declarationsOpt funcsOpt main funcsOpt .)


state 49

    (124) return -> RETURN . superexpression
    (59) superexpression -> . expression superexpressionB
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 89
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93
    empty                          shift and go to state 87

state 50

    (44) instruction -> assignfunccall . ;

    ;               shift and go to state 94


state 51

    (93) whileloop -> WHILE . ( superexpression ) block

    (               shift and go to state 95


state 52

    (104) output -> PRINT . ( outputB

    (               shift and go to state 96


state 53

    (50) instruction -> whileloop .

    ID              reduce using rule 50 (instruction -> whileloop .)
    PRINT           reduce using rule 50 (instruction -> whileloop .)
    RETURN          reduce using rule 50 (instruction -> whileloop .)
    INPUT           reduce using rule 50 (instruction -> whileloop .)
    IF              reduce using rule 50 (instruction -> whileloop .)
    WHILE           reduce using rule 50 (instruction -> whileloop .)
    FOR             reduce using rule 50 (instruction -> whileloop .)
    INT             reduce using rule 50 (instruction -> whileloop .)
    FLOAT           reduce using rule 50 (instruction -> whileloop .)
    STRING          reduce using rule 50 (instruction -> whileloop .)
    BOOL            reduce using rule 50 (instruction -> whileloop .)
    #               reduce using rule 50 (instruction -> whileloop .)
    TRACKDECISION   reduce using rule 50 (instruction -> whileloop .)
    FORGETDECISION  reduce using rule 50 (instruction -> whileloop .)
    }               reduce using rule 50 (instruction -> whileloop .)


state 54

    (109) localvardirective -> # . localvardirectiveB ID
    (112) localmsgdirective -> # . SHOW SCONST
    (110) localvardirectiveB -> . TRACK
    (111) localvardirectiveB -> . FORGET

    SHOW            shift and go to state 98
    TRACK           shift and go to state 99
    FORGET          shift and go to state 97

    localvardirectiveB             shift and go to state 100

state 55

    (56) localdirective -> localvardirective .

    ID              reduce using rule 56 (localdirective -> localvardirective .)
    PRINT           reduce using rule 56 (localdirective -> localvardirective .)
    RETURN          reduce using rule 56 (localdirective -> localvardirective .)
    INPUT           reduce using rule 56 (localdirective -> localvardirective .)
    IF              reduce using rule 56 (localdirective -> localvardirective .)
    WHILE           reduce using rule 56 (localdirective -> localvardirective .)
    FOR             reduce using rule 56 (localdirective -> localvardirective .)
    INT             reduce using rule 56 (localdirective -> localvardirective .)
    FLOAT           reduce using rule 56 (localdirective -> localvardirective .)
    STRING          reduce using rule 56 (localdirective -> localvardirective .)
    BOOL            reduce using rule 56 (localdirective -> localvardirective .)
    #               reduce using rule 56 (localdirective -> localvardirective .)
    TRACKDECISION   reduce using rule 56 (localdirective -> localvardirective .)
    FORGETDECISION  reduce using rule 56 (localdirective -> localvardirective .)
    }               reduce using rule 56 (localdirective -> localvardirective .)


state 56

    (113) localdecisiondirective -> TRACKDECISION .

    ID              reduce using rule 113 (localdecisiondirective -> TRACKDECISION .)
    PRINT           reduce using rule 113 (localdecisiondirective -> TRACKDECISION .)
    RETURN          reduce using rule 113 (localdecisiondirective -> TRACKDECISION .)
    INPUT           reduce using rule 113 (localdecisiondirective -> TRACKDECISION .)
    IF              reduce using rule 113 (localdecisiondirective -> TRACKDECISION .)
    WHILE           reduce using rule 113 (localdecisiondirective -> TRACKDECISION .)
    FOR             reduce using rule 113 (localdecisiondirective -> TRACKDECISION .)
    INT             reduce using rule 113 (localdecisiondirective -> TRACKDECISION .)
    FLOAT           reduce using rule 113 (localdecisiondirective -> TRACKDECISION .)
    STRING          reduce using rule 113 (localdecisiondirective -> TRACKDECISION .)
    BOOL            reduce using rule 113 (localdecisiondirective -> TRACKDECISION .)
    #               reduce using rule 113 (localdecisiondirective -> TRACKDECISION .)
    TRACKDECISION   reduce using rule 113 (localdecisiondirective -> TRACKDECISION .)
    FORGETDECISION  reduce using rule 113 (localdecisiondirective -> TRACKDECISION .)
    }               reduce using rule 113 (localdecisiondirective -> TRACKDECISION .)


state 57

    (47) instruction -> input . ;

    ;               shift and go to state 101


state 58

    (36) instructionsOpt -> empty .
    (115) localdecisiondirective -> empty .

  ! reduce/reduce conflict for } resolved using rule 36 (instructionsOpt -> empty .)
    }               reduce using rule 36 (instructionsOpt -> empty .)
    ID              reduce using rule 115 (localdecisiondirective -> empty .)
    PRINT           reduce using rule 115 (localdecisiondirective -> empty .)
    RETURN          reduce using rule 115 (localdecisiondirective -> empty .)
    INPUT           reduce using rule 115 (localdecisiondirective -> empty .)
    IF              reduce using rule 115 (localdecisiondirective -> empty .)
    WHILE           reduce using rule 115 (localdecisiondirective -> empty .)
    FOR             reduce using rule 115 (localdecisiondirective -> empty .)
    INT             reduce using rule 115 (localdecisiondirective -> empty .)
    FLOAT           reduce using rule 115 (localdecisiondirective -> empty .)
    STRING          reduce using rule 115 (localdecisiondirective -> empty .)
    BOOL            reduce using rule 115 (localdecisiondirective -> empty .)
    #               reduce using rule 115 (localdecisiondirective -> empty .)
    TRACKDECISION   reduce using rule 115 (localdecisiondirective -> empty .)
    FORGETDECISION  reduce using rule 115 (localdecisiondirective -> empty .)

  ! }               [ reduce using rule 115 (localdecisiondirective -> empty .) ]


state 59

    (51) instruction -> forloop .

    ID              reduce using rule 51 (instruction -> forloop .)
    PRINT           reduce using rule 51 (instruction -> forloop .)
    RETURN          reduce using rule 51 (instruction -> forloop .)
    INPUT           reduce using rule 51 (instruction -> forloop .)
    IF              reduce using rule 51 (instruction -> forloop .)
    WHILE           reduce using rule 51 (instruction -> forloop .)
    FOR             reduce using rule 51 (instruction -> forloop .)
    INT             reduce using rule 51 (instruction -> forloop .)
    FLOAT           reduce using rule 51 (instruction -> forloop .)
    STRING          reduce using rule 51 (instruction -> forloop .)
    BOOL            reduce using rule 51 (instruction -> forloop .)
    #               reduce using rule 51 (instruction -> forloop .)
    TRACKDECISION   reduce using rule 51 (instruction -> forloop .)
    FORGETDECISION  reduce using rule 51 (instruction -> forloop .)
    }               reduce using rule 51 (instruction -> forloop .)


state 60

    (46) instruction -> return . ;

    ;               shift and go to state 102


state 61

    (100) forloop -> FOR . ( assign ; superexpression ; superexpression ) block

    (               shift and go to state 103


state 62

    (34) block -> { instructionsOpt . }

    }               shift and go to state 104


state 63

    (114) localdecisiondirective -> FORGETDECISION .

    ID              reduce using rule 114 (localdecisiondirective -> FORGETDECISION .)
    PRINT           reduce using rule 114 (localdecisiondirective -> FORGETDECISION .)
    RETURN          reduce using rule 114 (localdecisiondirective -> FORGETDECISION .)
    INPUT           reduce using rule 114 (localdecisiondirective -> FORGETDECISION .)
    IF              reduce using rule 114 (localdecisiondirective -> FORGETDECISION .)
    WHILE           reduce using rule 114 (localdecisiondirective -> FORGETDECISION .)
    FOR             reduce using rule 114 (localdecisiondirective -> FORGETDECISION .)
    INT             reduce using rule 114 (localdecisiondirective -> FORGETDECISION .)
    FLOAT           reduce using rule 114 (localdecisiondirective -> FORGETDECISION .)
    STRING          reduce using rule 114 (localdecisiondirective -> FORGETDECISION .)
    BOOL            reduce using rule 114 (localdecisiondirective -> FORGETDECISION .)
    #               reduce using rule 114 (localdecisiondirective -> FORGETDECISION .)
    TRACKDECISION   reduce using rule 114 (localdecisiondirective -> FORGETDECISION .)
    FORGETDECISION  reduce using rule 114 (localdecisiondirective -> FORGETDECISION .)
    }               reduce using rule 114 (localdecisiondirective -> FORGETDECISION .)


state 64

    (52) instruction -> localdirective .

    ID              reduce using rule 52 (instruction -> localdirective .)
    PRINT           reduce using rule 52 (instruction -> localdirective .)
    RETURN          reduce using rule 52 (instruction -> localdirective .)
    INPUT           reduce using rule 52 (instruction -> localdirective .)
    IF              reduce using rule 52 (instruction -> localdirective .)
    WHILE           reduce using rule 52 (instruction -> localdirective .)
    FOR             reduce using rule 52 (instruction -> localdirective .)
    INT             reduce using rule 52 (instruction -> localdirective .)
    FLOAT           reduce using rule 52 (instruction -> localdirective .)
    STRING          reduce using rule 52 (instruction -> localdirective .)
    BOOL            reduce using rule 52 (instruction -> localdirective .)
    #               reduce using rule 52 (instruction -> localdirective .)
    TRACKDECISION   reduce using rule 52 (instruction -> localdirective .)
    FORGETDECISION  reduce using rule 52 (instruction -> localdirective .)
    }               reduce using rule 52 (instruction -> localdirective .)


state 65

    (48) instruction -> declaration .

    ID              reduce using rule 48 (instruction -> declaration .)
    PRINT           reduce using rule 48 (instruction -> declaration .)
    RETURN          reduce using rule 48 (instruction -> declaration .)
    INPUT           reduce using rule 48 (instruction -> declaration .)
    IF              reduce using rule 48 (instruction -> declaration .)
    WHILE           reduce using rule 48 (instruction -> declaration .)
    FOR             reduce using rule 48 (instruction -> declaration .)
    INT             reduce using rule 48 (instruction -> declaration .)
    FLOAT           reduce using rule 48 (instruction -> declaration .)
    STRING          reduce using rule 48 (instruction -> declaration .)
    BOOL            reduce using rule 48 (instruction -> declaration .)
    #               reduce using rule 48 (instruction -> declaration .)
    TRACKDECISION   reduce using rule 48 (instruction -> declaration .)
    FORGETDECISION  reduce using rule 48 (instruction -> declaration .)
    }               reduce using rule 48 (instruction -> declaration .)


state 66

    (101) input -> INPUT . ( ID inputB )

    (               shift and go to state 105


state 67

    (53) assignfunccall -> ID . assignfunccallB
    (54) assignfunccallB -> . ( funccallB funccallC
    (55) assignfunccallB -> . assignB
    (38) assignB -> . dimensionsOpt = superexpression
    (39) dimensionsOpt -> . dimensions
    (40) dimensionsOpt -> . empty
    (121) dimensions -> . [ superexpression ] dimensionsB
    (128) empty -> .

    (               shift and go to state 108
    [               shift and go to state 110
    =               reduce using rule 128 (empty -> .)

    dimensions                     shift and go to state 106
    assignfunccallB                shift and go to state 107
    assignB                        shift and go to state 109
    dimensionsOpt                  shift and go to state 111
    empty                          shift and go to state 112

state 68

    (49) instruction -> condition .

    ID              reduce using rule 49 (instruction -> condition .)
    PRINT           reduce using rule 49 (instruction -> condition .)
    RETURN          reduce using rule 49 (instruction -> condition .)
    INPUT           reduce using rule 49 (instruction -> condition .)
    IF              reduce using rule 49 (instruction -> condition .)
    WHILE           reduce using rule 49 (instruction -> condition .)
    FOR             reduce using rule 49 (instruction -> condition .)
    INT             reduce using rule 49 (instruction -> condition .)
    FLOAT           reduce using rule 49 (instruction -> condition .)
    STRING          reduce using rule 49 (instruction -> condition .)
    BOOL            reduce using rule 49 (instruction -> condition .)
    #               reduce using rule 49 (instruction -> condition .)
    TRACKDECISION   reduce using rule 49 (instruction -> condition .)
    FORGETDECISION  reduce using rule 49 (instruction -> condition .)
    }               reduce using rule 49 (instruction -> condition .)


state 69

    (41) condition -> IF . ( superexpression ) block else

    (               shift and go to state 113


state 70

    (35) instructionsOpt -> instruction . instructionsOpt
    (35) instructionsOpt -> . instruction instructionsOpt
    (36) instructionsOpt -> . empty
    (44) instruction -> . assignfunccall ;
    (45) instruction -> . output ;
    (46) instruction -> . return ;
    (47) instruction -> . input ;
    (48) instruction -> . declaration
    (49) instruction -> . condition
    (50) instruction -> . whileloop
    (51) instruction -> . forloop
    (52) instruction -> . localdirective
    (128) empty -> .
    (53) assignfunccall -> . ID assignfunccallB
    (104) output -> . PRINT ( outputB
    (124) return -> . RETURN superexpression
    (101) input -> . INPUT ( ID inputB )
    (18) declaration -> . type push_type declarationB declarationC
    (41) condition -> . IF ( superexpression ) block else
    (93) whileloop -> . WHILE ( superexpression ) block
    (100) forloop -> . FOR ( assign ; superexpression ; superexpression ) block
    (56) localdirective -> . localvardirective
    (57) localdirective -> . localdecisiondirective
    (58) localdirective -> . localmsgdirective
    (94) type -> . INT
    (95) type -> . FLOAT
    (96) type -> . STRING
    (97) type -> . BOOL
    (109) localvardirective -> . # localvardirectiveB ID
    (113) localdecisiondirective -> . TRACKDECISION
    (114) localdecisiondirective -> . FORGETDECISION
    (115) localdecisiondirective -> . empty
    (112) localmsgdirective -> . # SHOW SCONST

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for # resolved as shift
  ! shift/reduce conflict for TRACKDECISION resolved as shift
  ! shift/reduce conflict for FORGETDECISION resolved as shift
    }               reduce using rule 128 (empty -> .)
    ID              shift and go to state 67
    PRINT           shift and go to state 52
    RETURN          shift and go to state 49
    INPUT           shift and go to state 66
    IF              shift and go to state 69
    WHILE           shift and go to state 51
    FOR             shift and go to state 61
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18
    #               shift and go to state 54
    TRACKDECISION   shift and go to state 56
    FORGETDECISION  shift and go to state 63

  ! ID              [ reduce using rule 128 (empty -> .) ]
  ! PRINT           [ reduce using rule 128 (empty -> .) ]
  ! RETURN          [ reduce using rule 128 (empty -> .) ]
  ! INPUT           [ reduce using rule 128 (empty -> .) ]
  ! IF              [ reduce using rule 128 (empty -> .) ]
  ! WHILE           [ reduce using rule 128 (empty -> .) ]
  ! FOR             [ reduce using rule 128 (empty -> .) ]
  ! INT             [ reduce using rule 128 (empty -> .) ]
  ! FLOAT           [ reduce using rule 128 (empty -> .) ]
  ! STRING          [ reduce using rule 128 (empty -> .) ]
  ! BOOL            [ reduce using rule 128 (empty -> .) ]
  ! #               [ reduce using rule 128 (empty -> .) ]
  ! TRACKDECISION   [ reduce using rule 128 (empty -> .) ]
  ! FORGETDECISION  [ reduce using rule 128 (empty -> .) ]

    assignfunccall                 shift and go to state 50
    whileloop                      shift and go to state 53
    localvardirective              shift and go to state 55
    input                          shift and go to state 57
    type                           shift and go to state 16
    empty                          shift and go to state 58
    forloop                        shift and go to state 59
    return                         shift and go to state 60
    instructionsOpt                shift and go to state 114
    localdirective                 shift and go to state 64
    declaration                    shift and go to state 65
    condition                      shift and go to state 68
    instruction                    shift and go to state 70
    localmsgdirective              shift and go to state 71
    localdecisiondirective         shift and go to state 72
    output                         shift and go to state 73

state 71

    (58) localdirective -> localmsgdirective .

    ID              reduce using rule 58 (localdirective -> localmsgdirective .)
    PRINT           reduce using rule 58 (localdirective -> localmsgdirective .)
    RETURN          reduce using rule 58 (localdirective -> localmsgdirective .)
    INPUT           reduce using rule 58 (localdirective -> localmsgdirective .)
    IF              reduce using rule 58 (localdirective -> localmsgdirective .)
    WHILE           reduce using rule 58 (localdirective -> localmsgdirective .)
    FOR             reduce using rule 58 (localdirective -> localmsgdirective .)
    INT             reduce using rule 58 (localdirective -> localmsgdirective .)
    FLOAT           reduce using rule 58 (localdirective -> localmsgdirective .)
    STRING          reduce using rule 58 (localdirective -> localmsgdirective .)
    BOOL            reduce using rule 58 (localdirective -> localmsgdirective .)
    #               reduce using rule 58 (localdirective -> localmsgdirective .)
    TRACKDECISION   reduce using rule 58 (localdirective -> localmsgdirective .)
    FORGETDECISION  reduce using rule 58 (localdirective -> localmsgdirective .)
    }               reduce using rule 58 (localdirective -> localmsgdirective .)


state 72

    (57) localdirective -> localdecisiondirective .

    ID              reduce using rule 57 (localdirective -> localdecisiondirective .)
    PRINT           reduce using rule 57 (localdirective -> localdecisiondirective .)
    RETURN          reduce using rule 57 (localdirective -> localdecisiondirective .)
    INPUT           reduce using rule 57 (localdirective -> localdecisiondirective .)
    IF              reduce using rule 57 (localdirective -> localdecisiondirective .)
    WHILE           reduce using rule 57 (localdirective -> localdecisiondirective .)
    FOR             reduce using rule 57 (localdirective -> localdecisiondirective .)
    INT             reduce using rule 57 (localdirective -> localdecisiondirective .)
    FLOAT           reduce using rule 57 (localdirective -> localdecisiondirective .)
    STRING          reduce using rule 57 (localdirective -> localdecisiondirective .)
    BOOL            reduce using rule 57 (localdirective -> localdecisiondirective .)
    #               reduce using rule 57 (localdirective -> localdecisiondirective .)
    TRACKDECISION   reduce using rule 57 (localdirective -> localdecisiondirective .)
    FORGETDECISION  reduce using rule 57 (localdirective -> localdecisiondirective .)
    }               reduce using rule 57 (localdirective -> localdecisiondirective .)


state 73

    (45) instruction -> output . ;

    ;               shift and go to state 115


state 74

    (31) func -> DEF returntype ID . ( paramsOpt )

    (               shift and go to state 116


state 75

    (19) declarationB -> ID push_operand . dimensionsOpt
    (39) dimensionsOpt -> . dimensions
    (40) dimensionsOpt -> . empty
    (121) dimensions -> . [ superexpression ] dimensionsB
    (128) empty -> .

    [               shift and go to state 110
    =               reduce using rule 128 (empty -> .)
    ,               reduce using rule 128 (empty -> .)
    ;               reduce using rule 128 (empty -> .)

    dimensions                     shift and go to state 106
    dimensionsOpt                  shift and go to state 117
    empty                          shift and go to state 112

state 76

    (25) declarationC -> , . declarationB declarationC
    (19) declarationB -> . ID push_operand dimensionsOpt

    ID              shift and go to state 45

    declarationB                   shift and go to state 118

state 77

    (26) declarationC -> ; .

    INT             reduce using rule 26 (declarationC -> ; .)
    FLOAT           reduce using rule 26 (declarationC -> ; .)
    STRING          reduce using rule 26 (declarationC -> ; .)
    BOOL            reduce using rule 26 (declarationC -> ; .)
    DEF             reduce using rule 26 (declarationC -> ; .)
    MAIN            reduce using rule 26 (declarationC -> ; .)
    ID              reduce using rule 26 (declarationC -> ; .)
    PRINT           reduce using rule 26 (declarationC -> ; .)
    RETURN          reduce using rule 26 (declarationC -> ; .)
    INPUT           reduce using rule 26 (declarationC -> ; .)
    IF              reduce using rule 26 (declarationC -> ; .)
    WHILE           reduce using rule 26 (declarationC -> ; .)
    FOR             reduce using rule 26 (declarationC -> ; .)
    #               reduce using rule 26 (declarationC -> ; .)
    TRACKDECISION   reduce using rule 26 (declarationC -> ; .)
    FORGETDECISION  reduce using rule 26 (declarationC -> ; .)
    }               reduce using rule 26 (declarationC -> ; .)


state 78

    (18) declaration -> type push_type declarationB declarationC .

    INT             reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    FLOAT           reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    STRING          reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    BOOL            reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    DEF             reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    MAIN            reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    ID              reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    PRINT           reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    RETURN          reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    INPUT           reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    IF              reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    WHILE           reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    FOR             reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    #               reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    TRACKDECISION   reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    FORGETDECISION  reduce using rule 18 (declaration -> type push_type declarationB declarationC .)
    }               reduce using rule 18 (declaration -> type push_type declarationB declarationC .)


state 79

    (24) declarationC -> = . push_operator superexpression quadruple_assign declarationD
    (22) push_operator -> .

    (               reduce using rule 22 (push_operator -> .)
    ID              reduce using rule 22 (push_operator -> .)
    +               reduce using rule 22 (push_operator -> .)
    -               reduce using rule 22 (push_operator -> .)
    FCONST          reduce using rule 22 (push_operator -> .)
    ICONST          reduce using rule 22 (push_operator -> .)
    SCONST          reduce using rule 22 (push_operator -> .)
    TRUE            reduce using rule 22 (push_operator -> .)
    FALSE           reduce using rule 22 (push_operator -> .)

    push_operator                  shift and go to state 119

state 80

    (29) main -> MAIN ( ) . block
    (34) block -> . { instructionsOpt }

    {               shift and go to state 40

    block                          shift and go to state 120

state 81

    (84) signB -> sign .

    FCONST          reduce using rule 84 (signB -> sign .)
    ICONST          reduce using rule 84 (signB -> sign .)
    SCONST          reduce using rule 84 (signB -> sign .)
    TRUE            reduce using rule 84 (signB -> sign .)
    FALSE           reduce using rule 84 (signB -> sign .)


state 82

    (79) factor -> signB . constant
    (86) constant -> . FCONST
    (87) constant -> . ICONST
    (88) constant -> . SCONST
    (89) constant -> . TRUE
    (90) constant -> . FALSE

    FCONST          shift and go to state 122
    ICONST          shift and go to state 124
    SCONST          shift and go to state 123
    TRUE            shift and go to state 126
    FALSE           shift and go to state 125

    constant                       shift and go to state 121

state 83

    (80) factor -> ( . superexpression )
    (59) superexpression -> . expression superexpressionB
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 127
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93
    empty                          shift and go to state 87

state 84

    (91) sign -> + .

    FCONST          reduce using rule 91 (sign -> + .)
    ICONST          reduce using rule 91 (sign -> + .)
    SCONST          reduce using rule 91 (sign -> + .)
    TRUE            reduce using rule 91 (sign -> + .)
    FALSE           reduce using rule 91 (sign -> + .)


state 85

    (92) sign -> - .

    FCONST          reduce using rule 92 (sign -> - .)
    ICONST          reduce using rule 92 (sign -> - .)
    SCONST          reduce using rule 92 (sign -> - .)
    TRUE            reduce using rule 92 (sign -> - .)
    FALSE           reduce using rule 92 (sign -> - .)


state 86

    (75) term -> factor . termB
    (76) termB -> . / term
    (77) termB -> . * term
    (78) termB -> . empty
    (128) empty -> .

    /               shift and go to state 129
    *               shift and go to state 128
    -               reduce using rule 128 (empty -> .)
    +               reduce using rule 128 (empty -> .)
    <               reduce using rule 128 (empty -> .)
    >               reduce using rule 128 (empty -> .)
    =               reduce using rule 128 (empty -> .)
    &               reduce using rule 128 (empty -> .)
    |               reduce using rule 128 (empty -> .)
    ;               reduce using rule 128 (empty -> .)
    )               reduce using rule 128 (empty -> .)
    ,               reduce using rule 128 (empty -> .)
    ]               reduce using rule 128 (empty -> .)

    termB                          shift and go to state 130
    empty                          shift and go to state 131

state 87

    (85) signB -> empty .

    FCONST          reduce using rule 85 (signB -> empty .)
    ICONST          reduce using rule 85 (signB -> empty .)
    SCONST          reduce using rule 85 (signB -> empty .)
    TRUE            reduce using rule 85 (signB -> empty .)
    FALSE           reduce using rule 85 (signB -> empty .)


state 88

    (81) factor -> funccall .

    /               reduce using rule 81 (factor -> funccall .)
    *               reduce using rule 81 (factor -> funccall .)
    -               reduce using rule 81 (factor -> funccall .)
    +               reduce using rule 81 (factor -> funccall .)
    <               reduce using rule 81 (factor -> funccall .)
    >               reduce using rule 81 (factor -> funccall .)
    =               reduce using rule 81 (factor -> funccall .)
    &               reduce using rule 81 (factor -> funccall .)
    |               reduce using rule 81 (factor -> funccall .)
    )               reduce using rule 81 (factor -> funccall .)
    ,               reduce using rule 81 (factor -> funccall .)
    ;               reduce using rule 81 (factor -> funccall .)
    ]               reduce using rule 81 (factor -> funccall .)


state 89

    (124) return -> RETURN superexpression .

    ;               reduce using rule 124 (return -> RETURN superexpression .)


state 90

    (82) factor -> ID . seen_ID dimensionsOpt
    (116) funccall -> ID . ( funccallB funccallC
    (83) seen_ID -> .

    (               shift and go to state 132
    [               reduce using rule 83 (seen_ID -> .)
    /               reduce using rule 83 (seen_ID -> .)
    *               reduce using rule 83 (seen_ID -> .)
    -               reduce using rule 83 (seen_ID -> .)
    +               reduce using rule 83 (seen_ID -> .)
    <               reduce using rule 83 (seen_ID -> .)
    >               reduce using rule 83 (seen_ID -> .)
    =               reduce using rule 83 (seen_ID -> .)
    &               reduce using rule 83 (seen_ID -> .)
    |               reduce using rule 83 (seen_ID -> .)
    ;               reduce using rule 83 (seen_ID -> .)
    )               reduce using rule 83 (seen_ID -> .)
    ,               reduce using rule 83 (seen_ID -> .)
    ]               reduce using rule 83 (seen_ID -> .)

    seen_ID                        shift and go to state 133

state 91

    (71) exp -> term . expB
    (72) expB -> . - exp
    (73) expB -> . + exp
    (74) expB -> . empty
    (128) empty -> .

    -               shift and go to state 135
    +               shift and go to state 134
    <               reduce using rule 128 (empty -> .)
    >               reduce using rule 128 (empty -> .)
    =               reduce using rule 128 (empty -> .)
    &               reduce using rule 128 (empty -> .)
    |               reduce using rule 128 (empty -> .)
    ;               reduce using rule 128 (empty -> .)
    )               reduce using rule 128 (empty -> .)
    ,               reduce using rule 128 (empty -> .)
    ]               reduce using rule 128 (empty -> .)

    expB                           shift and go to state 136
    empty                          shift and go to state 137

state 92

    (63) expression -> exp . expressionB
    (64) expressionB -> . < exp
    (65) expressionB -> . > exp
    (66) expressionB -> . < > exp
    (67) expressionB -> . = = exp
    (68) expressionB -> . < = exp
    (69) expressionB -> . > = exp
    (70) expressionB -> . empty
    (128) empty -> .

    <               shift and go to state 140
    >               shift and go to state 142
    =               shift and go to state 139
    &               reduce using rule 128 (empty -> .)
    |               reduce using rule 128 (empty -> .)
    ;               reduce using rule 128 (empty -> .)
    )               reduce using rule 128 (empty -> .)
    ,               reduce using rule 128 (empty -> .)
    ]               reduce using rule 128 (empty -> .)

    expressionB                    shift and go to state 138
    empty                          shift and go to state 141

state 93

    (59) superexpression -> expression . superexpressionB
    (60) superexpressionB -> . & & superexpression
    (61) superexpressionB -> . | | superexpression
    (62) superexpressionB -> . empty
    (128) empty -> .

    &               shift and go to state 143
    |               shift and go to state 145
    ;               reduce using rule 128 (empty -> .)
    )               reduce using rule 128 (empty -> .)
    ,               reduce using rule 128 (empty -> .)
    ]               reduce using rule 128 (empty -> .)

    empty                          shift and go to state 146
    superexpressionB               shift and go to state 144

state 94

    (44) instruction -> assignfunccall ; .

    ID              reduce using rule 44 (instruction -> assignfunccall ; .)
    PRINT           reduce using rule 44 (instruction -> assignfunccall ; .)
    RETURN          reduce using rule 44 (instruction -> assignfunccall ; .)
    INPUT           reduce using rule 44 (instruction -> assignfunccall ; .)
    IF              reduce using rule 44 (instruction -> assignfunccall ; .)
    WHILE           reduce using rule 44 (instruction -> assignfunccall ; .)
    FOR             reduce using rule 44 (instruction -> assignfunccall ; .)
    INT             reduce using rule 44 (instruction -> assignfunccall ; .)
    FLOAT           reduce using rule 44 (instruction -> assignfunccall ; .)
    STRING          reduce using rule 44 (instruction -> assignfunccall ; .)
    BOOL            reduce using rule 44 (instruction -> assignfunccall ; .)
    #               reduce using rule 44 (instruction -> assignfunccall ; .)
    TRACKDECISION   reduce using rule 44 (instruction -> assignfunccall ; .)
    FORGETDECISION  reduce using rule 44 (instruction -> assignfunccall ; .)
    }               reduce using rule 44 (instruction -> assignfunccall ; .)


state 95

    (93) whileloop -> WHILE ( . superexpression ) block
    (59) superexpression -> . expression superexpressionB
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 147
    empty                          shift and go to state 87
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93

state 96

    (104) output -> PRINT ( . outputB
    (105) outputB -> . SCONST outputC
    (106) outputB -> . superexpression outputC
    (59) superexpression -> . expression superexpressionB
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

  ! shift/reduce conflict for SCONST resolved as shift
    SCONST          shift and go to state 148
    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

  ! SCONST          [ reduce using rule 128 (empty -> .) ]

    term                           shift and go to state 91
    factor                         shift and go to state 86
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 149
    exp                            shift and go to state 92
    outputB                        shift and go to state 150
    expression                     shift and go to state 93
    empty                          shift and go to state 87

state 97

    (111) localvardirectiveB -> FORGET .

    ID              reduce using rule 111 (localvardirectiveB -> FORGET .)


state 98

    (112) localmsgdirective -> # SHOW . SCONST

    SCONST          shift and go to state 151


state 99

    (110) localvardirectiveB -> TRACK .

    ID              reduce using rule 110 (localvardirectiveB -> TRACK .)


state 100

    (109) localvardirective -> # localvardirectiveB . ID

    ID              shift and go to state 152


state 101

    (47) instruction -> input ; .

    ID              reduce using rule 47 (instruction -> input ; .)
    PRINT           reduce using rule 47 (instruction -> input ; .)
    RETURN          reduce using rule 47 (instruction -> input ; .)
    INPUT           reduce using rule 47 (instruction -> input ; .)
    IF              reduce using rule 47 (instruction -> input ; .)
    WHILE           reduce using rule 47 (instruction -> input ; .)
    FOR             reduce using rule 47 (instruction -> input ; .)
    INT             reduce using rule 47 (instruction -> input ; .)
    FLOAT           reduce using rule 47 (instruction -> input ; .)
    STRING          reduce using rule 47 (instruction -> input ; .)
    BOOL            reduce using rule 47 (instruction -> input ; .)
    #               reduce using rule 47 (instruction -> input ; .)
    TRACKDECISION   reduce using rule 47 (instruction -> input ; .)
    FORGETDECISION  reduce using rule 47 (instruction -> input ; .)
    }               reduce using rule 47 (instruction -> input ; .)


state 102

    (46) instruction -> return ; .

    ID              reduce using rule 46 (instruction -> return ; .)
    PRINT           reduce using rule 46 (instruction -> return ; .)
    RETURN          reduce using rule 46 (instruction -> return ; .)
    INPUT           reduce using rule 46 (instruction -> return ; .)
    IF              reduce using rule 46 (instruction -> return ; .)
    WHILE           reduce using rule 46 (instruction -> return ; .)
    FOR             reduce using rule 46 (instruction -> return ; .)
    INT             reduce using rule 46 (instruction -> return ; .)
    FLOAT           reduce using rule 46 (instruction -> return ; .)
    STRING          reduce using rule 46 (instruction -> return ; .)
    BOOL            reduce using rule 46 (instruction -> return ; .)
    #               reduce using rule 46 (instruction -> return ; .)
    TRACKDECISION   reduce using rule 46 (instruction -> return ; .)
    FORGETDECISION  reduce using rule 46 (instruction -> return ; .)
    }               reduce using rule 46 (instruction -> return ; .)


state 103

    (100) forloop -> FOR ( . assign ; superexpression ; superexpression ) block
    (37) assign -> . ID dimensionsOpt = superexpression

    ID              shift and go to state 153

    assign                         shift and go to state 154

state 104

    (34) block -> { instructionsOpt } .

    DEF             reduce using rule 34 (block -> { instructionsOpt } .)
    $end            reduce using rule 34 (block -> { instructionsOpt } .)
    ID              reduce using rule 34 (block -> { instructionsOpt } .)
    PRINT           reduce using rule 34 (block -> { instructionsOpt } .)
    RETURN          reduce using rule 34 (block -> { instructionsOpt } .)
    INPUT           reduce using rule 34 (block -> { instructionsOpt } .)
    IF              reduce using rule 34 (block -> { instructionsOpt } .)
    WHILE           reduce using rule 34 (block -> { instructionsOpt } .)
    FOR             reduce using rule 34 (block -> { instructionsOpt } .)
    INT             reduce using rule 34 (block -> { instructionsOpt } .)
    FLOAT           reduce using rule 34 (block -> { instructionsOpt } .)
    STRING          reduce using rule 34 (block -> { instructionsOpt } .)
    BOOL            reduce using rule 34 (block -> { instructionsOpt } .)
    #               reduce using rule 34 (block -> { instructionsOpt } .)
    TRACKDECISION   reduce using rule 34 (block -> { instructionsOpt } .)
    FORGETDECISION  reduce using rule 34 (block -> { instructionsOpt } .)
    }               reduce using rule 34 (block -> { instructionsOpt } .)
    ELSE            reduce using rule 34 (block -> { instructionsOpt } .)
    MAIN            reduce using rule 34 (block -> { instructionsOpt } .)


state 105

    (101) input -> INPUT ( . ID inputB )

    ID              shift and go to state 155


state 106

    (39) dimensionsOpt -> dimensions .

    /               reduce using rule 39 (dimensionsOpt -> dimensions .)
    *               reduce using rule 39 (dimensionsOpt -> dimensions .)
    -               reduce using rule 39 (dimensionsOpt -> dimensions .)
    +               reduce using rule 39 (dimensionsOpt -> dimensions .)
    <               reduce using rule 39 (dimensionsOpt -> dimensions .)
    >               reduce using rule 39 (dimensionsOpt -> dimensions .)
    =               reduce using rule 39 (dimensionsOpt -> dimensions .)
    &               reduce using rule 39 (dimensionsOpt -> dimensions .)
    |               reduce using rule 39 (dimensionsOpt -> dimensions .)
    ;               reduce using rule 39 (dimensionsOpt -> dimensions .)
    )               reduce using rule 39 (dimensionsOpt -> dimensions .)
    ,               reduce using rule 39 (dimensionsOpt -> dimensions .)
    ]               reduce using rule 39 (dimensionsOpt -> dimensions .)


state 107

    (53) assignfunccall -> ID assignfunccallB .

    ;               reduce using rule 53 (assignfunccall -> ID assignfunccallB .)


state 108

    (54) assignfunccallB -> ( . funccallB funccallC
    (117) funccallB -> . superexpression
    (118) funccallB -> . empty
    (59) superexpression -> . expression superexpressionB
    (128) empty -> .
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -

    ,               reduce using rule 128 (empty -> .)
    )               reduce using rule 128 (empty -> .)
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)
    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85

    funccallB                      shift and go to state 156
    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 158
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93
    empty                          shift and go to state 157

state 109

    (55) assignfunccallB -> assignB .

    ;               reduce using rule 55 (assignfunccallB -> assignB .)


state 110

    (121) dimensions -> [ . superexpression ] dimensionsB
    (59) superexpression -> . expression superexpressionB
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 159
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93
    empty                          shift and go to state 87

state 111

    (38) assignB -> dimensionsOpt . = superexpression

    =               shift and go to state 160


state 112

    (40) dimensionsOpt -> empty .

    /               reduce using rule 40 (dimensionsOpt -> empty .)
    *               reduce using rule 40 (dimensionsOpt -> empty .)
    -               reduce using rule 40 (dimensionsOpt -> empty .)
    +               reduce using rule 40 (dimensionsOpt -> empty .)
    <               reduce using rule 40 (dimensionsOpt -> empty .)
    >               reduce using rule 40 (dimensionsOpt -> empty .)
    =               reduce using rule 40 (dimensionsOpt -> empty .)
    &               reduce using rule 40 (dimensionsOpt -> empty .)
    |               reduce using rule 40 (dimensionsOpt -> empty .)
    ;               reduce using rule 40 (dimensionsOpt -> empty .)
    )               reduce using rule 40 (dimensionsOpt -> empty .)
    ,               reduce using rule 40 (dimensionsOpt -> empty .)
    ]               reduce using rule 40 (dimensionsOpt -> empty .)


state 113

    (41) condition -> IF ( . superexpression ) block else
    (59) superexpression -> . expression superexpressionB
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 161
    empty                          shift and go to state 87
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93

state 114

    (35) instructionsOpt -> instruction instructionsOpt .

    }               reduce using rule 35 (instructionsOpt -> instruction instructionsOpt .)


state 115

    (45) instruction -> output ; .

    ID              reduce using rule 45 (instruction -> output ; .)
    PRINT           reduce using rule 45 (instruction -> output ; .)
    RETURN          reduce using rule 45 (instruction -> output ; .)
    INPUT           reduce using rule 45 (instruction -> output ; .)
    IF              reduce using rule 45 (instruction -> output ; .)
    WHILE           reduce using rule 45 (instruction -> output ; .)
    FOR             reduce using rule 45 (instruction -> output ; .)
    INT             reduce using rule 45 (instruction -> output ; .)
    FLOAT           reduce using rule 45 (instruction -> output ; .)
    STRING          reduce using rule 45 (instruction -> output ; .)
    BOOL            reduce using rule 45 (instruction -> output ; .)
    #               reduce using rule 45 (instruction -> output ; .)
    TRACKDECISION   reduce using rule 45 (instruction -> output ; .)
    FORGETDECISION  reduce using rule 45 (instruction -> output ; .)
    }               reduce using rule 45 (instruction -> output ; .)


state 116

    (31) func -> DEF returntype ID ( . paramsOpt )
    (32) paramsOpt -> . params paramsB
    (33) paramsOpt -> . empty
    (125) params -> . type ID
    (128) empty -> .
    (94) type -> . INT
    (95) type -> . FLOAT
    (96) type -> . STRING
    (97) type -> . BOOL

    )               reduce using rule 128 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18

    paramsOpt                      shift and go to state 162
    params                         shift and go to state 163
    type                           shift and go to state 165
    empty                          shift and go to state 164

state 117

    (19) declarationB -> ID push_operand dimensionsOpt .

    =               reduce using rule 19 (declarationB -> ID push_operand dimensionsOpt .)
    ,               reduce using rule 19 (declarationB -> ID push_operand dimensionsOpt .)
    ;               reduce using rule 19 (declarationB -> ID push_operand dimensionsOpt .)


state 118

    (25) declarationC -> , declarationB . declarationC
    (24) declarationC -> . = push_operator superexpression quadruple_assign declarationD
    (25) declarationC -> . , declarationB declarationC
    (26) declarationC -> . ;

    =               shift and go to state 79
    ,               shift and go to state 76
    ;               shift and go to state 77

    declarationC                   shift and go to state 166

state 119

    (24) declarationC -> = push_operator . superexpression quadruple_assign declarationD
    (59) superexpression -> . expression superexpressionB
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 167
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93
    empty                          shift and go to state 87

state 120

    (29) main -> MAIN ( ) block .

    DEF             reduce using rule 29 (main -> MAIN ( ) block .)
    $end            reduce using rule 29 (main -> MAIN ( ) block .)


state 121

    (79) factor -> signB constant .

    /               reduce using rule 79 (factor -> signB constant .)
    *               reduce using rule 79 (factor -> signB constant .)
    -               reduce using rule 79 (factor -> signB constant .)
    +               reduce using rule 79 (factor -> signB constant .)
    <               reduce using rule 79 (factor -> signB constant .)
    >               reduce using rule 79 (factor -> signB constant .)
    =               reduce using rule 79 (factor -> signB constant .)
    &               reduce using rule 79 (factor -> signB constant .)
    |               reduce using rule 79 (factor -> signB constant .)
    )               reduce using rule 79 (factor -> signB constant .)
    ,               reduce using rule 79 (factor -> signB constant .)
    ;               reduce using rule 79 (factor -> signB constant .)
    ]               reduce using rule 79 (factor -> signB constant .)


state 122

    (86) constant -> FCONST .

    /               reduce using rule 86 (constant -> FCONST .)
    *               reduce using rule 86 (constant -> FCONST .)
    -               reduce using rule 86 (constant -> FCONST .)
    +               reduce using rule 86 (constant -> FCONST .)
    <               reduce using rule 86 (constant -> FCONST .)
    >               reduce using rule 86 (constant -> FCONST .)
    =               reduce using rule 86 (constant -> FCONST .)
    &               reduce using rule 86 (constant -> FCONST .)
    |               reduce using rule 86 (constant -> FCONST .)
    ;               reduce using rule 86 (constant -> FCONST .)
    )               reduce using rule 86 (constant -> FCONST .)
    ,               reduce using rule 86 (constant -> FCONST .)
    ]               reduce using rule 86 (constant -> FCONST .)


state 123

    (88) constant -> SCONST .

    /               reduce using rule 88 (constant -> SCONST .)
    *               reduce using rule 88 (constant -> SCONST .)
    -               reduce using rule 88 (constant -> SCONST .)
    +               reduce using rule 88 (constant -> SCONST .)
    <               reduce using rule 88 (constant -> SCONST .)
    >               reduce using rule 88 (constant -> SCONST .)
    =               reduce using rule 88 (constant -> SCONST .)
    &               reduce using rule 88 (constant -> SCONST .)
    |               reduce using rule 88 (constant -> SCONST .)
    ;               reduce using rule 88 (constant -> SCONST .)
    )               reduce using rule 88 (constant -> SCONST .)
    ,               reduce using rule 88 (constant -> SCONST .)
    ]               reduce using rule 88 (constant -> SCONST .)


state 124

    (87) constant -> ICONST .

    /               reduce using rule 87 (constant -> ICONST .)
    *               reduce using rule 87 (constant -> ICONST .)
    -               reduce using rule 87 (constant -> ICONST .)
    +               reduce using rule 87 (constant -> ICONST .)
    <               reduce using rule 87 (constant -> ICONST .)
    >               reduce using rule 87 (constant -> ICONST .)
    =               reduce using rule 87 (constant -> ICONST .)
    &               reduce using rule 87 (constant -> ICONST .)
    |               reduce using rule 87 (constant -> ICONST .)
    ;               reduce using rule 87 (constant -> ICONST .)
    )               reduce using rule 87 (constant -> ICONST .)
    ,               reduce using rule 87 (constant -> ICONST .)
    ]               reduce using rule 87 (constant -> ICONST .)


state 125

    (90) constant -> FALSE .

    /               reduce using rule 90 (constant -> FALSE .)
    *               reduce using rule 90 (constant -> FALSE .)
    -               reduce using rule 90 (constant -> FALSE .)
    +               reduce using rule 90 (constant -> FALSE .)
    <               reduce using rule 90 (constant -> FALSE .)
    >               reduce using rule 90 (constant -> FALSE .)
    =               reduce using rule 90 (constant -> FALSE .)
    &               reduce using rule 90 (constant -> FALSE .)
    |               reduce using rule 90 (constant -> FALSE .)
    ;               reduce using rule 90 (constant -> FALSE .)
    )               reduce using rule 90 (constant -> FALSE .)
    ,               reduce using rule 90 (constant -> FALSE .)
    ]               reduce using rule 90 (constant -> FALSE .)


state 126

    (89) constant -> TRUE .

    /               reduce using rule 89 (constant -> TRUE .)
    *               reduce using rule 89 (constant -> TRUE .)
    -               reduce using rule 89 (constant -> TRUE .)
    +               reduce using rule 89 (constant -> TRUE .)
    <               reduce using rule 89 (constant -> TRUE .)
    >               reduce using rule 89 (constant -> TRUE .)
    =               reduce using rule 89 (constant -> TRUE .)
    &               reduce using rule 89 (constant -> TRUE .)
    |               reduce using rule 89 (constant -> TRUE .)
    ;               reduce using rule 89 (constant -> TRUE .)
    )               reduce using rule 89 (constant -> TRUE .)
    ,               reduce using rule 89 (constant -> TRUE .)
    ]               reduce using rule 89 (constant -> TRUE .)


state 127

    (80) factor -> ( superexpression . )

    )               shift and go to state 168


state 128

    (77) termB -> * . term
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 169
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 129

    (76) termB -> / . term
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 170
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 130

    (75) term -> factor termB .

    -               reduce using rule 75 (term -> factor termB .)
    +               reduce using rule 75 (term -> factor termB .)
    <               reduce using rule 75 (term -> factor termB .)
    >               reduce using rule 75 (term -> factor termB .)
    =               reduce using rule 75 (term -> factor termB .)
    &               reduce using rule 75 (term -> factor termB .)
    |               reduce using rule 75 (term -> factor termB .)
    ;               reduce using rule 75 (term -> factor termB .)
    )               reduce using rule 75 (term -> factor termB .)
    ,               reduce using rule 75 (term -> factor termB .)
    ]               reduce using rule 75 (term -> factor termB .)


state 131

    (78) termB -> empty .

    -               reduce using rule 78 (termB -> empty .)
    +               reduce using rule 78 (termB -> empty .)
    <               reduce using rule 78 (termB -> empty .)
    >               reduce using rule 78 (termB -> empty .)
    =               reduce using rule 78 (termB -> empty .)
    &               reduce using rule 78 (termB -> empty .)
    |               reduce using rule 78 (termB -> empty .)
    ;               reduce using rule 78 (termB -> empty .)
    )               reduce using rule 78 (termB -> empty .)
    ,               reduce using rule 78 (termB -> empty .)
    ]               reduce using rule 78 (termB -> empty .)


state 132

    (116) funccall -> ID ( . funccallB funccallC
    (117) funccallB -> . superexpression
    (118) funccallB -> . empty
    (59) superexpression -> . expression superexpressionB
    (128) empty -> .
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -

    ,               reduce using rule 128 (empty -> .)
    )               reduce using rule 128 (empty -> .)
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)
    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85

    funccallB                      shift and go to state 171
    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 158
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93
    empty                          shift and go to state 157

state 133

    (82) factor -> ID seen_ID . dimensionsOpt
    (39) dimensionsOpt -> . dimensions
    (40) dimensionsOpt -> . empty
    (121) dimensions -> . [ superexpression ] dimensionsB
    (128) empty -> .

    [               shift and go to state 110
    /               reduce using rule 128 (empty -> .)
    *               reduce using rule 128 (empty -> .)
    -               reduce using rule 128 (empty -> .)
    +               reduce using rule 128 (empty -> .)
    <               reduce using rule 128 (empty -> .)
    >               reduce using rule 128 (empty -> .)
    =               reduce using rule 128 (empty -> .)
    &               reduce using rule 128 (empty -> .)
    |               reduce using rule 128 (empty -> .)
    ;               reduce using rule 128 (empty -> .)
    )               reduce using rule 128 (empty -> .)
    ,               reduce using rule 128 (empty -> .)
    ]               reduce using rule 128 (empty -> .)

    dimensions                     shift and go to state 106
    dimensionsOpt                  shift and go to state 172
    empty                          shift and go to state 112

state 134

    (73) expB -> + . exp
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    exp                            shift and go to state 173
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 135

    (72) expB -> - . exp
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    exp                            shift and go to state 174
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 136

    (71) exp -> term expB .

    <               reduce using rule 71 (exp -> term expB .)
    >               reduce using rule 71 (exp -> term expB .)
    =               reduce using rule 71 (exp -> term expB .)
    &               reduce using rule 71 (exp -> term expB .)
    |               reduce using rule 71 (exp -> term expB .)
    )               reduce using rule 71 (exp -> term expB .)
    ,               reduce using rule 71 (exp -> term expB .)
    ;               reduce using rule 71 (exp -> term expB .)
    ]               reduce using rule 71 (exp -> term expB .)


state 137

    (74) expB -> empty .

    <               reduce using rule 74 (expB -> empty .)
    >               reduce using rule 74 (expB -> empty .)
    =               reduce using rule 74 (expB -> empty .)
    &               reduce using rule 74 (expB -> empty .)
    |               reduce using rule 74 (expB -> empty .)
    ;               reduce using rule 74 (expB -> empty .)
    )               reduce using rule 74 (expB -> empty .)
    ,               reduce using rule 74 (expB -> empty .)
    ]               reduce using rule 74 (expB -> empty .)


state 138

    (63) expression -> exp expressionB .

    &               reduce using rule 63 (expression -> exp expressionB .)
    |               reduce using rule 63 (expression -> exp expressionB .)
    )               reduce using rule 63 (expression -> exp expressionB .)
    ,               reduce using rule 63 (expression -> exp expressionB .)
    ;               reduce using rule 63 (expression -> exp expressionB .)
    ]               reduce using rule 63 (expression -> exp expressionB .)


state 139

    (67) expressionB -> = . = exp

    =               shift and go to state 175


state 140

    (64) expressionB -> < . exp
    (66) expressionB -> < . > exp
    (68) expressionB -> < . = exp
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    >               shift and go to state 177
    =               shift and go to state 176
    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    exp                            shift and go to state 178
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 141

    (70) expressionB -> empty .

    &               reduce using rule 70 (expressionB -> empty .)
    |               reduce using rule 70 (expressionB -> empty .)
    ;               reduce using rule 70 (expressionB -> empty .)
    )               reduce using rule 70 (expressionB -> empty .)
    ,               reduce using rule 70 (expressionB -> empty .)
    ]               reduce using rule 70 (expressionB -> empty .)


state 142

    (65) expressionB -> > . exp
    (69) expressionB -> > . = exp
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    =               shift and go to state 179
    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    exp                            shift and go to state 180
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 143

    (60) superexpressionB -> & . & superexpression

    &               shift and go to state 181


state 144

    (59) superexpression -> expression superexpressionB .

    )               reduce using rule 59 (superexpression -> expression superexpressionB .)
    ,               reduce using rule 59 (superexpression -> expression superexpressionB .)
    ;               reduce using rule 59 (superexpression -> expression superexpressionB .)
    ]               reduce using rule 59 (superexpression -> expression superexpressionB .)


state 145

    (61) superexpressionB -> | . | superexpression

    |               shift and go to state 182


state 146

    (62) superexpressionB -> empty .

    ;               reduce using rule 62 (superexpressionB -> empty .)
    )               reduce using rule 62 (superexpressionB -> empty .)
    ,               reduce using rule 62 (superexpressionB -> empty .)
    ]               reduce using rule 62 (superexpressionB -> empty .)


state 147

    (93) whileloop -> WHILE ( superexpression . ) block

    )               shift and go to state 183


state 148

    (105) outputB -> SCONST . outputC
    (107) outputC -> . )
    (108) outputC -> . , outputB

    )               shift and go to state 184
    ,               shift and go to state 186

    outputC                        shift and go to state 185

state 149

    (106) outputB -> superexpression . outputC
    (107) outputC -> . )
    (108) outputC -> . , outputB

    )               shift and go to state 184
    ,               shift and go to state 186

    outputC                        shift and go to state 187

state 150

    (104) output -> PRINT ( outputB .

    ;               reduce using rule 104 (output -> PRINT ( outputB .)


state 151

    (112) localmsgdirective -> # SHOW SCONST .

    ID              reduce using rule 112 (localmsgdirective -> # SHOW SCONST .)
    PRINT           reduce using rule 112 (localmsgdirective -> # SHOW SCONST .)
    RETURN          reduce using rule 112 (localmsgdirective -> # SHOW SCONST .)
    INPUT           reduce using rule 112 (localmsgdirective -> # SHOW SCONST .)
    IF              reduce using rule 112 (localmsgdirective -> # SHOW SCONST .)
    WHILE           reduce using rule 112 (localmsgdirective -> # SHOW SCONST .)
    FOR             reduce using rule 112 (localmsgdirective -> # SHOW SCONST .)
    INT             reduce using rule 112 (localmsgdirective -> # SHOW SCONST .)
    FLOAT           reduce using rule 112 (localmsgdirective -> # SHOW SCONST .)
    STRING          reduce using rule 112 (localmsgdirective -> # SHOW SCONST .)
    BOOL            reduce using rule 112 (localmsgdirective -> # SHOW SCONST .)
    #               reduce using rule 112 (localmsgdirective -> # SHOW SCONST .)
    TRACKDECISION   reduce using rule 112 (localmsgdirective -> # SHOW SCONST .)
    FORGETDECISION  reduce using rule 112 (localmsgdirective -> # SHOW SCONST .)
    }               reduce using rule 112 (localmsgdirective -> # SHOW SCONST .)


state 152

    (109) localvardirective -> # localvardirectiveB ID .

    ID              reduce using rule 109 (localvardirective -> # localvardirectiveB ID .)
    PRINT           reduce using rule 109 (localvardirective -> # localvardirectiveB ID .)
    RETURN          reduce using rule 109 (localvardirective -> # localvardirectiveB ID .)
    INPUT           reduce using rule 109 (localvardirective -> # localvardirectiveB ID .)
    IF              reduce using rule 109 (localvardirective -> # localvardirectiveB ID .)
    WHILE           reduce using rule 109 (localvardirective -> # localvardirectiveB ID .)
    FOR             reduce using rule 109 (localvardirective -> # localvardirectiveB ID .)
    INT             reduce using rule 109 (localvardirective -> # localvardirectiveB ID .)
    FLOAT           reduce using rule 109 (localvardirective -> # localvardirectiveB ID .)
    STRING          reduce using rule 109 (localvardirective -> # localvardirectiveB ID .)
    BOOL            reduce using rule 109 (localvardirective -> # localvardirectiveB ID .)
    #               reduce using rule 109 (localvardirective -> # localvardirectiveB ID .)
    TRACKDECISION   reduce using rule 109 (localvardirective -> # localvardirectiveB ID .)
    FORGETDECISION  reduce using rule 109 (localvardirective -> # localvardirectiveB ID .)
    }               reduce using rule 109 (localvardirective -> # localvardirectiveB ID .)


state 153

    (37) assign -> ID . dimensionsOpt = superexpression
    (39) dimensionsOpt -> . dimensions
    (40) dimensionsOpt -> . empty
    (121) dimensions -> . [ superexpression ] dimensionsB
    (128) empty -> .

    [               shift and go to state 110
    =               reduce using rule 128 (empty -> .)

    dimensionsOpt                  shift and go to state 188
    dimensions                     shift and go to state 106
    empty                          shift and go to state 112

state 154

    (100) forloop -> FOR ( assign . ; superexpression ; superexpression ) block

    ;               shift and go to state 189


state 155

    (101) input -> INPUT ( ID . inputB )
    (102) inputB -> . , ID inputB
    (103) inputB -> . empty
    (128) empty -> .

    ,               shift and go to state 190
    )               reduce using rule 128 (empty -> .)

    inputB                         shift and go to state 191
    empty                          shift and go to state 192

state 156

    (54) assignfunccallB -> ( funccallB . funccallC
    (119) funccallC -> . , funccallB funccallC
    (120) funccallC -> . )

    ,               shift and go to state 195
    )               shift and go to state 194

    funccallC                      shift and go to state 193

state 157

    (118) funccallB -> empty .
    (85) signB -> empty .

    ,               reduce using rule 118 (funccallB -> empty .)
    )               reduce using rule 118 (funccallB -> empty .)
    FCONST          reduce using rule 85 (signB -> empty .)
    ICONST          reduce using rule 85 (signB -> empty .)
    SCONST          reduce using rule 85 (signB -> empty .)
    TRUE            reduce using rule 85 (signB -> empty .)
    FALSE           reduce using rule 85 (signB -> empty .)


state 158

    (117) funccallB -> superexpression .

    ,               reduce using rule 117 (funccallB -> superexpression .)
    )               reduce using rule 117 (funccallB -> superexpression .)


state 159

    (121) dimensions -> [ superexpression . ] dimensionsB

    ]               shift and go to state 196


state 160

    (38) assignB -> dimensionsOpt = . superexpression
    (59) superexpression -> . expression superexpressionB
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 197
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93
    empty                          shift and go to state 87

state 161

    (41) condition -> IF ( superexpression . ) block else

    )               shift and go to state 198


state 162

    (31) func -> DEF returntype ID ( paramsOpt . )

    )               shift and go to state 199


state 163

    (32) paramsOpt -> params . paramsB
    (126) paramsB -> . , params paramsB
    (127) paramsB -> . empty
    (128) empty -> .

    ,               shift and go to state 201
    )               reduce using rule 128 (empty -> .)

    paramsB                        shift and go to state 200
    empty                          shift and go to state 202

state 164

    (33) paramsOpt -> empty .

    )               reduce using rule 33 (paramsOpt -> empty .)


state 165

    (125) params -> type . ID

    ID              shift and go to state 203


state 166

    (25) declarationC -> , declarationB declarationC .

    INT             reduce using rule 25 (declarationC -> , declarationB declarationC .)
    FLOAT           reduce using rule 25 (declarationC -> , declarationB declarationC .)
    STRING          reduce using rule 25 (declarationC -> , declarationB declarationC .)
    BOOL            reduce using rule 25 (declarationC -> , declarationB declarationC .)
    DEF             reduce using rule 25 (declarationC -> , declarationB declarationC .)
    MAIN            reduce using rule 25 (declarationC -> , declarationB declarationC .)
    ID              reduce using rule 25 (declarationC -> , declarationB declarationC .)
    PRINT           reduce using rule 25 (declarationC -> , declarationB declarationC .)
    RETURN          reduce using rule 25 (declarationC -> , declarationB declarationC .)
    INPUT           reduce using rule 25 (declarationC -> , declarationB declarationC .)
    IF              reduce using rule 25 (declarationC -> , declarationB declarationC .)
    WHILE           reduce using rule 25 (declarationC -> , declarationB declarationC .)
    FOR             reduce using rule 25 (declarationC -> , declarationB declarationC .)
    #               reduce using rule 25 (declarationC -> , declarationB declarationC .)
    TRACKDECISION   reduce using rule 25 (declarationC -> , declarationB declarationC .)
    FORGETDECISION  reduce using rule 25 (declarationC -> , declarationB declarationC .)
    }               reduce using rule 25 (declarationC -> , declarationB declarationC .)


state 167

    (24) declarationC -> = push_operator superexpression . quadruple_assign declarationD
    (23) quadruple_assign -> .

    ,               reduce using rule 23 (quadruple_assign -> .)
    ;               reduce using rule 23 (quadruple_assign -> .)

    quadruple_assign               shift and go to state 204

state 168

    (80) factor -> ( superexpression ) .

    /               reduce using rule 80 (factor -> ( superexpression ) .)
    *               reduce using rule 80 (factor -> ( superexpression ) .)
    -               reduce using rule 80 (factor -> ( superexpression ) .)
    +               reduce using rule 80 (factor -> ( superexpression ) .)
    <               reduce using rule 80 (factor -> ( superexpression ) .)
    >               reduce using rule 80 (factor -> ( superexpression ) .)
    =               reduce using rule 80 (factor -> ( superexpression ) .)
    &               reduce using rule 80 (factor -> ( superexpression ) .)
    |               reduce using rule 80 (factor -> ( superexpression ) .)
    )               reduce using rule 80 (factor -> ( superexpression ) .)
    ,               reduce using rule 80 (factor -> ( superexpression ) .)
    ;               reduce using rule 80 (factor -> ( superexpression ) .)
    ]               reduce using rule 80 (factor -> ( superexpression ) .)


state 169

    (77) termB -> * term .

    -               reduce using rule 77 (termB -> * term .)
    +               reduce using rule 77 (termB -> * term .)
    <               reduce using rule 77 (termB -> * term .)
    >               reduce using rule 77 (termB -> * term .)
    =               reduce using rule 77 (termB -> * term .)
    &               reduce using rule 77 (termB -> * term .)
    |               reduce using rule 77 (termB -> * term .)
    ;               reduce using rule 77 (termB -> * term .)
    )               reduce using rule 77 (termB -> * term .)
    ,               reduce using rule 77 (termB -> * term .)
    ]               reduce using rule 77 (termB -> * term .)


state 170

    (76) termB -> / term .

    -               reduce using rule 76 (termB -> / term .)
    +               reduce using rule 76 (termB -> / term .)
    <               reduce using rule 76 (termB -> / term .)
    >               reduce using rule 76 (termB -> / term .)
    =               reduce using rule 76 (termB -> / term .)
    &               reduce using rule 76 (termB -> / term .)
    |               reduce using rule 76 (termB -> / term .)
    ;               reduce using rule 76 (termB -> / term .)
    )               reduce using rule 76 (termB -> / term .)
    ,               reduce using rule 76 (termB -> / term .)
    ]               reduce using rule 76 (termB -> / term .)


state 171

    (116) funccall -> ID ( funccallB . funccallC
    (119) funccallC -> . , funccallB funccallC
    (120) funccallC -> . )

    ,               shift and go to state 195
    )               shift and go to state 194

    funccallC                      shift and go to state 205

state 172

    (82) factor -> ID seen_ID dimensionsOpt .

    /               reduce using rule 82 (factor -> ID seen_ID dimensionsOpt .)
    *               reduce using rule 82 (factor -> ID seen_ID dimensionsOpt .)
    -               reduce using rule 82 (factor -> ID seen_ID dimensionsOpt .)
    +               reduce using rule 82 (factor -> ID seen_ID dimensionsOpt .)
    <               reduce using rule 82 (factor -> ID seen_ID dimensionsOpt .)
    >               reduce using rule 82 (factor -> ID seen_ID dimensionsOpt .)
    =               reduce using rule 82 (factor -> ID seen_ID dimensionsOpt .)
    &               reduce using rule 82 (factor -> ID seen_ID dimensionsOpt .)
    |               reduce using rule 82 (factor -> ID seen_ID dimensionsOpt .)
    )               reduce using rule 82 (factor -> ID seen_ID dimensionsOpt .)
    ,               reduce using rule 82 (factor -> ID seen_ID dimensionsOpt .)
    ;               reduce using rule 82 (factor -> ID seen_ID dimensionsOpt .)
    ]               reduce using rule 82 (factor -> ID seen_ID dimensionsOpt .)


state 173

    (73) expB -> + exp .

    <               reduce using rule 73 (expB -> + exp .)
    >               reduce using rule 73 (expB -> + exp .)
    =               reduce using rule 73 (expB -> + exp .)
    &               reduce using rule 73 (expB -> + exp .)
    |               reduce using rule 73 (expB -> + exp .)
    ;               reduce using rule 73 (expB -> + exp .)
    )               reduce using rule 73 (expB -> + exp .)
    ,               reduce using rule 73 (expB -> + exp .)
    ]               reduce using rule 73 (expB -> + exp .)


state 174

    (72) expB -> - exp .

    <               reduce using rule 72 (expB -> - exp .)
    >               reduce using rule 72 (expB -> - exp .)
    =               reduce using rule 72 (expB -> - exp .)
    &               reduce using rule 72 (expB -> - exp .)
    |               reduce using rule 72 (expB -> - exp .)
    ;               reduce using rule 72 (expB -> - exp .)
    )               reduce using rule 72 (expB -> - exp .)
    ,               reduce using rule 72 (expB -> - exp .)
    ]               reduce using rule 72 (expB -> - exp .)


state 175

    (67) expressionB -> = = . exp
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    exp                            shift and go to state 206
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 176

    (68) expressionB -> < = . exp
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    exp                            shift and go to state 207
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 177

    (66) expressionB -> < > . exp
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    exp                            shift and go to state 208
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 178

    (64) expressionB -> < exp .

    &               reduce using rule 64 (expressionB -> < exp .)
    |               reduce using rule 64 (expressionB -> < exp .)
    ;               reduce using rule 64 (expressionB -> < exp .)
    )               reduce using rule 64 (expressionB -> < exp .)
    ,               reduce using rule 64 (expressionB -> < exp .)
    ]               reduce using rule 64 (expressionB -> < exp .)


state 179

    (69) expressionB -> > = . exp
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    exp                            shift and go to state 209
    factor                         shift and go to state 86
    empty                          shift and go to state 87

state 180

    (65) expressionB -> > exp .

    &               reduce using rule 65 (expressionB -> > exp .)
    |               reduce using rule 65 (expressionB -> > exp .)
    ;               reduce using rule 65 (expressionB -> > exp .)
    )               reduce using rule 65 (expressionB -> > exp .)
    ,               reduce using rule 65 (expressionB -> > exp .)
    ]               reduce using rule 65 (expressionB -> > exp .)


state 181

    (60) superexpressionB -> & & . superexpression
    (59) superexpression -> . expression superexpressionB
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 210
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93
    empty                          shift and go to state 87

state 182

    (61) superexpressionB -> | | . superexpression
    (59) superexpression -> . expression superexpressionB
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 211
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93
    empty                          shift and go to state 87

state 183

    (93) whileloop -> WHILE ( superexpression ) . block
    (34) block -> . { instructionsOpt }

    {               shift and go to state 40

    block                          shift and go to state 212

state 184

    (107) outputC -> ) .

    ;               reduce using rule 107 (outputC -> ) .)


state 185

    (105) outputB -> SCONST outputC .

    ;               reduce using rule 105 (outputB -> SCONST outputC .)


state 186

    (108) outputC -> , . outputB
    (105) outputB -> . SCONST outputC
    (106) outputB -> . superexpression outputC
    (59) superexpression -> . expression superexpressionB
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

  ! shift/reduce conflict for SCONST resolved as shift
    SCONST          shift and go to state 148
    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

  ! SCONST          [ reduce using rule 128 (empty -> .) ]

    term                           shift and go to state 91
    factor                         shift and go to state 86
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 149
    exp                            shift and go to state 92
    outputB                        shift and go to state 213
    expression                     shift and go to state 93
    empty                          shift and go to state 87

state 187

    (106) outputB -> superexpression outputC .

    ;               reduce using rule 106 (outputB -> superexpression outputC .)


state 188

    (37) assign -> ID dimensionsOpt . = superexpression

    =               shift and go to state 214


state 189

    (100) forloop -> FOR ( assign ; . superexpression ; superexpression ) block
    (59) superexpression -> . expression superexpressionB
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 215
    empty                          shift and go to state 87
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93

state 190

    (102) inputB -> , . ID inputB

    ID              shift and go to state 216


state 191

    (101) input -> INPUT ( ID inputB . )

    )               shift and go to state 217


state 192

    (103) inputB -> empty .

    )               reduce using rule 103 (inputB -> empty .)


state 193

    (54) assignfunccallB -> ( funccallB funccallC .

    ;               reduce using rule 54 (assignfunccallB -> ( funccallB funccallC .)


state 194

    (120) funccallC -> ) .

    ;               reduce using rule 120 (funccallC -> ) .)
    /               reduce using rule 120 (funccallC -> ) .)
    *               reduce using rule 120 (funccallC -> ) .)
    -               reduce using rule 120 (funccallC -> ) .)
    +               reduce using rule 120 (funccallC -> ) .)
    <               reduce using rule 120 (funccallC -> ) .)
    >               reduce using rule 120 (funccallC -> ) .)
    =               reduce using rule 120 (funccallC -> ) .)
    &               reduce using rule 120 (funccallC -> ) .)
    |               reduce using rule 120 (funccallC -> ) .)
    )               reduce using rule 120 (funccallC -> ) .)
    ,               reduce using rule 120 (funccallC -> ) .)
    ]               reduce using rule 120 (funccallC -> ) .)


state 195

    (119) funccallC -> , . funccallB funccallC
    (117) funccallB -> . superexpression
    (118) funccallB -> . empty
    (59) superexpression -> . expression superexpressionB
    (128) empty -> .
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -

    ,               reduce using rule 128 (empty -> .)
    )               reduce using rule 128 (empty -> .)
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)
    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85

    funccallB                      shift and go to state 218
    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 158
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93
    empty                          shift and go to state 157

state 196

    (121) dimensions -> [ superexpression ] . dimensionsB
    (122) dimensionsB -> . [ superexpression ]
    (123) dimensionsB -> . empty
    (128) empty -> .

    [               shift and go to state 220
    =               reduce using rule 128 (empty -> .)
    ,               reduce using rule 128 (empty -> .)
    ;               reduce using rule 128 (empty -> .)
    /               reduce using rule 128 (empty -> .)
    *               reduce using rule 128 (empty -> .)
    -               reduce using rule 128 (empty -> .)
    +               reduce using rule 128 (empty -> .)
    <               reduce using rule 128 (empty -> .)
    >               reduce using rule 128 (empty -> .)
    &               reduce using rule 128 (empty -> .)
    |               reduce using rule 128 (empty -> .)
    )               reduce using rule 128 (empty -> .)
    ]               reduce using rule 128 (empty -> .)

    dimensionsB                    shift and go to state 219
    empty                          shift and go to state 221

state 197

    (38) assignB -> dimensionsOpt = superexpression .

    ;               reduce using rule 38 (assignB -> dimensionsOpt = superexpression .)


state 198

    (41) condition -> IF ( superexpression ) . block else
    (34) block -> . { instructionsOpt }

    {               shift and go to state 40

    block                          shift and go to state 222

state 199

    (31) func -> DEF returntype ID ( paramsOpt ) .

    {               reduce using rule 31 (func -> DEF returntype ID ( paramsOpt ) .)


state 200

    (32) paramsOpt -> params paramsB .

    )               reduce using rule 32 (paramsOpt -> params paramsB .)


state 201

    (126) paramsB -> , . params paramsB
    (125) params -> . type ID
    (94) type -> . INT
    (95) type -> . FLOAT
    (96) type -> . STRING
    (97) type -> . BOOL

    INT             shift and go to state 15
    FLOAT           shift and go to state 17
    STRING          shift and go to state 14
    BOOL            shift and go to state 18

    type                           shift and go to state 165
    params                         shift and go to state 223

state 202

    (127) paramsB -> empty .

    )               reduce using rule 127 (paramsB -> empty .)


state 203

    (125) params -> type ID .

    ,               reduce using rule 125 (params -> type ID .)
    )               reduce using rule 125 (params -> type ID .)


state 204

    (24) declarationC -> = push_operator superexpression quadruple_assign . declarationD
    (27) declarationD -> . , declarationB declarationC
    (28) declarationD -> . ;

    ,               shift and go to state 224
    ;               shift and go to state 225

    declarationD                   shift and go to state 226

state 205

    (116) funccall -> ID ( funccallB funccallC .

    /               reduce using rule 116 (funccall -> ID ( funccallB funccallC .)
    *               reduce using rule 116 (funccall -> ID ( funccallB funccallC .)
    -               reduce using rule 116 (funccall -> ID ( funccallB funccallC .)
    +               reduce using rule 116 (funccall -> ID ( funccallB funccallC .)
    &               reduce using rule 116 (funccall -> ID ( funccallB funccallC .)
    |               reduce using rule 116 (funccall -> ID ( funccallB funccallC .)
    ;               reduce using rule 116 (funccall -> ID ( funccallB funccallC .)
    )               reduce using rule 116 (funccall -> ID ( funccallB funccallC .)
    ,               reduce using rule 116 (funccall -> ID ( funccallB funccallC .)
    ]               reduce using rule 116 (funccall -> ID ( funccallB funccallC .)
    <               reduce using rule 116 (funccall -> ID ( funccallB funccallC .)
    >               reduce using rule 116 (funccall -> ID ( funccallB funccallC .)
    =               reduce using rule 116 (funccall -> ID ( funccallB funccallC .)


state 206

    (67) expressionB -> = = exp .

    &               reduce using rule 67 (expressionB -> = = exp .)
    |               reduce using rule 67 (expressionB -> = = exp .)
    ;               reduce using rule 67 (expressionB -> = = exp .)
    )               reduce using rule 67 (expressionB -> = = exp .)
    ,               reduce using rule 67 (expressionB -> = = exp .)
    ]               reduce using rule 67 (expressionB -> = = exp .)


state 207

    (68) expressionB -> < = exp .

    &               reduce using rule 68 (expressionB -> < = exp .)
    |               reduce using rule 68 (expressionB -> < = exp .)
    ;               reduce using rule 68 (expressionB -> < = exp .)
    )               reduce using rule 68 (expressionB -> < = exp .)
    ,               reduce using rule 68 (expressionB -> < = exp .)
    ]               reduce using rule 68 (expressionB -> < = exp .)


state 208

    (66) expressionB -> < > exp .

    &               reduce using rule 66 (expressionB -> < > exp .)
    |               reduce using rule 66 (expressionB -> < > exp .)
    ;               reduce using rule 66 (expressionB -> < > exp .)
    )               reduce using rule 66 (expressionB -> < > exp .)
    ,               reduce using rule 66 (expressionB -> < > exp .)
    ]               reduce using rule 66 (expressionB -> < > exp .)


state 209

    (69) expressionB -> > = exp .

    &               reduce using rule 69 (expressionB -> > = exp .)
    |               reduce using rule 69 (expressionB -> > = exp .)
    ;               reduce using rule 69 (expressionB -> > = exp .)
    )               reduce using rule 69 (expressionB -> > = exp .)
    ,               reduce using rule 69 (expressionB -> > = exp .)
    ]               reduce using rule 69 (expressionB -> > = exp .)


state 210

    (60) superexpressionB -> & & superexpression .

    ;               reduce using rule 60 (superexpressionB -> & & superexpression .)
    )               reduce using rule 60 (superexpressionB -> & & superexpression .)
    ,               reduce using rule 60 (superexpressionB -> & & superexpression .)
    ]               reduce using rule 60 (superexpressionB -> & & superexpression .)


state 211

    (61) superexpressionB -> | | superexpression .

    ;               reduce using rule 61 (superexpressionB -> | | superexpression .)
    )               reduce using rule 61 (superexpressionB -> | | superexpression .)
    ,               reduce using rule 61 (superexpressionB -> | | superexpression .)
    ]               reduce using rule 61 (superexpressionB -> | | superexpression .)


state 212

    (93) whileloop -> WHILE ( superexpression ) block .

    ID              reduce using rule 93 (whileloop -> WHILE ( superexpression ) block .)
    PRINT           reduce using rule 93 (whileloop -> WHILE ( superexpression ) block .)
    RETURN          reduce using rule 93 (whileloop -> WHILE ( superexpression ) block .)
    INPUT           reduce using rule 93 (whileloop -> WHILE ( superexpression ) block .)
    IF              reduce using rule 93 (whileloop -> WHILE ( superexpression ) block .)
    WHILE           reduce using rule 93 (whileloop -> WHILE ( superexpression ) block .)
    FOR             reduce using rule 93 (whileloop -> WHILE ( superexpression ) block .)
    INT             reduce using rule 93 (whileloop -> WHILE ( superexpression ) block .)
    FLOAT           reduce using rule 93 (whileloop -> WHILE ( superexpression ) block .)
    STRING          reduce using rule 93 (whileloop -> WHILE ( superexpression ) block .)
    BOOL            reduce using rule 93 (whileloop -> WHILE ( superexpression ) block .)
    #               reduce using rule 93 (whileloop -> WHILE ( superexpression ) block .)
    TRACKDECISION   reduce using rule 93 (whileloop -> WHILE ( superexpression ) block .)
    FORGETDECISION  reduce using rule 93 (whileloop -> WHILE ( superexpression ) block .)
    }               reduce using rule 93 (whileloop -> WHILE ( superexpression ) block .)


state 213

    (108) outputC -> , outputB .

    ;               reduce using rule 108 (outputC -> , outputB .)


state 214

    (37) assign -> ID dimensionsOpt = . superexpression
    (59) superexpression -> . expression superexpressionB
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 227
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93
    empty                          shift and go to state 87

state 215

    (100) forloop -> FOR ( assign ; superexpression . ; superexpression ) block

    ;               shift and go to state 228


state 216

    (102) inputB -> , ID . inputB
    (102) inputB -> . , ID inputB
    (103) inputB -> . empty
    (128) empty -> .

    ,               shift and go to state 190
    )               reduce using rule 128 (empty -> .)

    inputB                         shift and go to state 229
    empty                          shift and go to state 192

state 217

    (101) input -> INPUT ( ID inputB ) .

    ;               reduce using rule 101 (input -> INPUT ( ID inputB ) .)


state 218

    (119) funccallC -> , funccallB . funccallC
    (119) funccallC -> . , funccallB funccallC
    (120) funccallC -> . )

    ,               shift and go to state 195
    )               shift and go to state 194

    funccallC                      shift and go to state 230

state 219

    (121) dimensions -> [ superexpression ] dimensionsB .

    =               reduce using rule 121 (dimensions -> [ superexpression ] dimensionsB .)
    /               reduce using rule 121 (dimensions -> [ superexpression ] dimensionsB .)
    *               reduce using rule 121 (dimensions -> [ superexpression ] dimensionsB .)
    -               reduce using rule 121 (dimensions -> [ superexpression ] dimensionsB .)
    +               reduce using rule 121 (dimensions -> [ superexpression ] dimensionsB .)
    <               reduce using rule 121 (dimensions -> [ superexpression ] dimensionsB .)
    >               reduce using rule 121 (dimensions -> [ superexpression ] dimensionsB .)
    &               reduce using rule 121 (dimensions -> [ superexpression ] dimensionsB .)
    |               reduce using rule 121 (dimensions -> [ superexpression ] dimensionsB .)
    ;               reduce using rule 121 (dimensions -> [ superexpression ] dimensionsB .)
    )               reduce using rule 121 (dimensions -> [ superexpression ] dimensionsB .)
    ,               reduce using rule 121 (dimensions -> [ superexpression ] dimensionsB .)
    ]               reduce using rule 121 (dimensions -> [ superexpression ] dimensionsB .)


state 220

    (122) dimensionsB -> [ . superexpression ]
    (59) superexpression -> . expression superexpressionB
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 231
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93
    empty                          shift and go to state 87

state 221

    (123) dimensionsB -> empty .

    =               reduce using rule 123 (dimensionsB -> empty .)
    ,               reduce using rule 123 (dimensionsB -> empty .)
    ;               reduce using rule 123 (dimensionsB -> empty .)
    /               reduce using rule 123 (dimensionsB -> empty .)
    *               reduce using rule 123 (dimensionsB -> empty .)
    -               reduce using rule 123 (dimensionsB -> empty .)
    +               reduce using rule 123 (dimensionsB -> empty .)
    <               reduce using rule 123 (dimensionsB -> empty .)
    >               reduce using rule 123 (dimensionsB -> empty .)
    &               reduce using rule 123 (dimensionsB -> empty .)
    |               reduce using rule 123 (dimensionsB -> empty .)
    )               reduce using rule 123 (dimensionsB -> empty .)
    ]               reduce using rule 123 (dimensionsB -> empty .)


state 222

    (41) condition -> IF ( superexpression ) block . else
    (42) else -> . ELSE block
    (43) else -> . empty
    (128) empty -> .

    ELSE            shift and go to state 234
    ID              reduce using rule 128 (empty -> .)
    PRINT           reduce using rule 128 (empty -> .)
    RETURN          reduce using rule 128 (empty -> .)
    INPUT           reduce using rule 128 (empty -> .)
    IF              reduce using rule 128 (empty -> .)
    WHILE           reduce using rule 128 (empty -> .)
    FOR             reduce using rule 128 (empty -> .)
    INT             reduce using rule 128 (empty -> .)
    FLOAT           reduce using rule 128 (empty -> .)
    STRING          reduce using rule 128 (empty -> .)
    BOOL            reduce using rule 128 (empty -> .)
    #               reduce using rule 128 (empty -> .)
    TRACKDECISION   reduce using rule 128 (empty -> .)
    FORGETDECISION  reduce using rule 128 (empty -> .)
    }               reduce using rule 128 (empty -> .)

    empty                          shift and go to state 233
    else                           shift and go to state 232

state 223

    (126) paramsB -> , params . paramsB
    (126) paramsB -> . , params paramsB
    (127) paramsB -> . empty
    (128) empty -> .

    ,               shift and go to state 201
    )               reduce using rule 128 (empty -> .)

    paramsB                        shift and go to state 235
    empty                          shift and go to state 202

state 224

    (27) declarationD -> , . declarationB declarationC
    (19) declarationB -> . ID push_operand dimensionsOpt

    ID              shift and go to state 45

    declarationB                   shift and go to state 236

state 225

    (28) declarationD -> ; .

    INT             reduce using rule 28 (declarationD -> ; .)
    FLOAT           reduce using rule 28 (declarationD -> ; .)
    STRING          reduce using rule 28 (declarationD -> ; .)
    BOOL            reduce using rule 28 (declarationD -> ; .)
    DEF             reduce using rule 28 (declarationD -> ; .)
    MAIN            reduce using rule 28 (declarationD -> ; .)
    ID              reduce using rule 28 (declarationD -> ; .)
    PRINT           reduce using rule 28 (declarationD -> ; .)
    RETURN          reduce using rule 28 (declarationD -> ; .)
    INPUT           reduce using rule 28 (declarationD -> ; .)
    IF              reduce using rule 28 (declarationD -> ; .)
    WHILE           reduce using rule 28 (declarationD -> ; .)
    FOR             reduce using rule 28 (declarationD -> ; .)
    #               reduce using rule 28 (declarationD -> ; .)
    TRACKDECISION   reduce using rule 28 (declarationD -> ; .)
    FORGETDECISION  reduce using rule 28 (declarationD -> ; .)
    }               reduce using rule 28 (declarationD -> ; .)


state 226

    (24) declarationC -> = push_operator superexpression quadruple_assign declarationD .

    INT             reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    FLOAT           reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    STRING          reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    BOOL            reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    DEF             reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    MAIN            reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    ID              reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    PRINT           reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    RETURN          reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    INPUT           reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    IF              reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    WHILE           reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    FOR             reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    #               reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    TRACKDECISION   reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    FORGETDECISION  reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)
    }               reduce using rule 24 (declarationC -> = push_operator superexpression quadruple_assign declarationD .)


state 227

    (37) assign -> ID dimensionsOpt = superexpression .

    ;               reduce using rule 37 (assign -> ID dimensionsOpt = superexpression .)


state 228

    (100) forloop -> FOR ( assign ; superexpression ; . superexpression ) block
    (59) superexpression -> . expression superexpressionB
    (63) expression -> . exp expressionB
    (71) exp -> . term expB
    (75) term -> . factor termB
    (79) factor -> . signB constant
    (80) factor -> . ( superexpression )
    (81) factor -> . funccall
    (82) factor -> . ID seen_ID dimensionsOpt
    (84) signB -> . sign
    (85) signB -> . empty
    (116) funccall -> . ID ( funccallB funccallC
    (91) sign -> . +
    (92) sign -> . -
    (128) empty -> .

    (               shift and go to state 83
    ID              shift and go to state 90
    +               shift and go to state 84
    -               shift and go to state 85
    FCONST          reduce using rule 128 (empty -> .)
    ICONST          reduce using rule 128 (empty -> .)
    SCONST          reduce using rule 128 (empty -> .)
    TRUE            reduce using rule 128 (empty -> .)
    FALSE           reduce using rule 128 (empty -> .)

    term                           shift and go to state 91
    funccall                       shift and go to state 88
    signB                          shift and go to state 82
    sign                           shift and go to state 81
    superexpression                shift and go to state 237
    empty                          shift and go to state 87
    exp                            shift and go to state 92
    factor                         shift and go to state 86
    expression                     shift and go to state 93

state 229

    (102) inputB -> , ID inputB .

    )               reduce using rule 102 (inputB -> , ID inputB .)


state 230

    (119) funccallC -> , funccallB funccallC .

    ;               reduce using rule 119 (funccallC -> , funccallB funccallC .)
    /               reduce using rule 119 (funccallC -> , funccallB funccallC .)
    *               reduce using rule 119 (funccallC -> , funccallB funccallC .)
    -               reduce using rule 119 (funccallC -> , funccallB funccallC .)
    +               reduce using rule 119 (funccallC -> , funccallB funccallC .)
    <               reduce using rule 119 (funccallC -> , funccallB funccallC .)
    >               reduce using rule 119 (funccallC -> , funccallB funccallC .)
    =               reduce using rule 119 (funccallC -> , funccallB funccallC .)
    &               reduce using rule 119 (funccallC -> , funccallB funccallC .)
    |               reduce using rule 119 (funccallC -> , funccallB funccallC .)
    )               reduce using rule 119 (funccallC -> , funccallB funccallC .)
    ,               reduce using rule 119 (funccallC -> , funccallB funccallC .)
    ]               reduce using rule 119 (funccallC -> , funccallB funccallC .)


state 231

    (122) dimensionsB -> [ superexpression . ]

    ]               shift and go to state 238


state 232

    (41) condition -> IF ( superexpression ) block else .

    ID              reduce using rule 41 (condition -> IF ( superexpression ) block else .)
    PRINT           reduce using rule 41 (condition -> IF ( superexpression ) block else .)
    RETURN          reduce using rule 41 (condition -> IF ( superexpression ) block else .)
    INPUT           reduce using rule 41 (condition -> IF ( superexpression ) block else .)
    IF              reduce using rule 41 (condition -> IF ( superexpression ) block else .)
    WHILE           reduce using rule 41 (condition -> IF ( superexpression ) block else .)
    FOR             reduce using rule 41 (condition -> IF ( superexpression ) block else .)
    INT             reduce using rule 41 (condition -> IF ( superexpression ) block else .)
    FLOAT           reduce using rule 41 (condition -> IF ( superexpression ) block else .)
    STRING          reduce using rule 41 (condition -> IF ( superexpression ) block else .)
    BOOL            reduce using rule 41 (condition -> IF ( superexpression ) block else .)
    #               reduce using rule 41 (condition -> IF ( superexpression ) block else .)
    TRACKDECISION   reduce using rule 41 (condition -> IF ( superexpression ) block else .)
    FORGETDECISION  reduce using rule 41 (condition -> IF ( superexpression ) block else .)
    }               reduce using rule 41 (condition -> IF ( superexpression ) block else .)


state 233

    (43) else -> empty .

    ID              reduce using rule 43 (else -> empty .)
    PRINT           reduce using rule 43 (else -> empty .)
    RETURN          reduce using rule 43 (else -> empty .)
    INPUT           reduce using rule 43 (else -> empty .)
    IF              reduce using rule 43 (else -> empty .)
    WHILE           reduce using rule 43 (else -> empty .)
    FOR             reduce using rule 43 (else -> empty .)
    INT             reduce using rule 43 (else -> empty .)
    FLOAT           reduce using rule 43 (else -> empty .)
    STRING          reduce using rule 43 (else -> empty .)
    BOOL            reduce using rule 43 (else -> empty .)
    #               reduce using rule 43 (else -> empty .)
    TRACKDECISION   reduce using rule 43 (else -> empty .)
    FORGETDECISION  reduce using rule 43 (else -> empty .)
    }               reduce using rule 43 (else -> empty .)


state 234

    (42) else -> ELSE . block
    (34) block -> . { instructionsOpt }

    {               shift and go to state 40

    block                          shift and go to state 239

state 235

    (126) paramsB -> , params paramsB .

    )               reduce using rule 126 (paramsB -> , params paramsB .)


state 236

    (27) declarationD -> , declarationB . declarationC
    (24) declarationC -> . = push_operator superexpression quadruple_assign declarationD
    (25) declarationC -> . , declarationB declarationC
    (26) declarationC -> . ;

    =               shift and go to state 79
    ,               shift and go to state 76
    ;               shift and go to state 77

    declarationC                   shift and go to state 240

state 237

    (100) forloop -> FOR ( assign ; superexpression ; superexpression . ) block

    )               shift and go to state 241


state 238

    (122) dimensionsB -> [ superexpression ] .

    =               reduce using rule 122 (dimensionsB -> [ superexpression ] .)
    ,               reduce using rule 122 (dimensionsB -> [ superexpression ] .)
    ;               reduce using rule 122 (dimensionsB -> [ superexpression ] .)
    /               reduce using rule 122 (dimensionsB -> [ superexpression ] .)
    *               reduce using rule 122 (dimensionsB -> [ superexpression ] .)
    -               reduce using rule 122 (dimensionsB -> [ superexpression ] .)
    +               reduce using rule 122 (dimensionsB -> [ superexpression ] .)
    <               reduce using rule 122 (dimensionsB -> [ superexpression ] .)
    >               reduce using rule 122 (dimensionsB -> [ superexpression ] .)
    &               reduce using rule 122 (dimensionsB -> [ superexpression ] .)
    |               reduce using rule 122 (dimensionsB -> [ superexpression ] .)
    )               reduce using rule 122 (dimensionsB -> [ superexpression ] .)
    ]               reduce using rule 122 (dimensionsB -> [ superexpression ] .)


state 239

    (42) else -> ELSE block .

    ID              reduce using rule 42 (else -> ELSE block .)
    PRINT           reduce using rule 42 (else -> ELSE block .)
    RETURN          reduce using rule 42 (else -> ELSE block .)
    INPUT           reduce using rule 42 (else -> ELSE block .)
    IF              reduce using rule 42 (else -> ELSE block .)
    WHILE           reduce using rule 42 (else -> ELSE block .)
    FOR             reduce using rule 42 (else -> ELSE block .)
    INT             reduce using rule 42 (else -> ELSE block .)
    FLOAT           reduce using rule 42 (else -> ELSE block .)
    STRING          reduce using rule 42 (else -> ELSE block .)
    BOOL            reduce using rule 42 (else -> ELSE block .)
    #               reduce using rule 42 (else -> ELSE block .)
    TRACKDECISION   reduce using rule 42 (else -> ELSE block .)
    FORGETDECISION  reduce using rule 42 (else -> ELSE block .)
    }               reduce using rule 42 (else -> ELSE block .)


state 240

    (27) declarationD -> , declarationB declarationC .

    INT             reduce using rule 27 (declarationD -> , declarationB declarationC .)
    FLOAT           reduce using rule 27 (declarationD -> , declarationB declarationC .)
    STRING          reduce using rule 27 (declarationD -> , declarationB declarationC .)
    BOOL            reduce using rule 27 (declarationD -> , declarationB declarationC .)
    DEF             reduce using rule 27 (declarationD -> , declarationB declarationC .)
    MAIN            reduce using rule 27 (declarationD -> , declarationB declarationC .)
    ID              reduce using rule 27 (declarationD -> , declarationB declarationC .)
    PRINT           reduce using rule 27 (declarationD -> , declarationB declarationC .)
    RETURN          reduce using rule 27 (declarationD -> , declarationB declarationC .)
    INPUT           reduce using rule 27 (declarationD -> , declarationB declarationC .)
    IF              reduce using rule 27 (declarationD -> , declarationB declarationC .)
    WHILE           reduce using rule 27 (declarationD -> , declarationB declarationC .)
    FOR             reduce using rule 27 (declarationD -> , declarationB declarationC .)
    #               reduce using rule 27 (declarationD -> , declarationB declarationC .)
    TRACKDECISION   reduce using rule 27 (declarationD -> , declarationB declarationC .)
    FORGETDECISION  reduce using rule 27 (declarationD -> , declarationB declarationC .)
    }               reduce using rule 27 (declarationD -> , declarationB declarationC .)


state 241

    (100) forloop -> FOR ( assign ; superexpression ; superexpression ) . block
    (34) block -> . { instructionsOpt }

    {               shift and go to state 40

    block                          shift and go to state 242

state 242

    (100) forloop -> FOR ( assign ; superexpression ; superexpression ) block .

    ID              reduce using rule 100 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    PRINT           reduce using rule 100 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    RETURN          reduce using rule 100 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    INPUT           reduce using rule 100 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    IF              reduce using rule 100 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    WHILE           reduce using rule 100 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    FOR             reduce using rule 100 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    INT             reduce using rule 100 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    FLOAT           reduce using rule 100 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    STRING          reduce using rule 100 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    BOOL            reduce using rule 100 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    #               reduce using rule 100 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    TRACKDECISION   reduce using rule 100 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    FORGETDECISION  reduce using rule 100 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)
    }               reduce using rule 100 (forloop -> FOR ( assign ; superexpression ; superexpression ) block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 40 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 40 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 40 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 40 resolved as shift
WARNING: shift/reduce conflict for IF in state 40 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 40 resolved as shift
WARNING: shift/reduce conflict for FOR in state 40 resolved as shift
WARNING: shift/reduce conflict for INT in state 40 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 40 resolved as shift
WARNING: shift/reduce conflict for STRING in state 40 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 40 resolved as shift
WARNING: shift/reduce conflict for # in state 40 resolved as shift
WARNING: shift/reduce conflict for TRACKDECISION in state 40 resolved as shift
WARNING: shift/reduce conflict for FORGETDECISION in state 40 resolved as shift
WARNING: shift/reduce conflict for ID in state 70 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 70 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 70 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 70 resolved as shift
WARNING: shift/reduce conflict for IF in state 70 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 70 resolved as shift
WARNING: shift/reduce conflict for FOR in state 70 resolved as shift
WARNING: shift/reduce conflict for INT in state 70 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 70 resolved as shift
WARNING: shift/reduce conflict for STRING in state 70 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 70 resolved as shift
WARNING: shift/reduce conflict for # in state 70 resolved as shift
WARNING: shift/reduce conflict for TRACKDECISION in state 70 resolved as shift
WARNING: shift/reduce conflict for FORGETDECISION in state 70 resolved as shift
WARNING: shift/reduce conflict for SCONST in state 96 resolved as shift
WARNING: shift/reduce conflict for SCONST in state 186 resolved as shift
WARNING: reduce/reduce conflict in state 58 resolved using rule (instructionsOpt -> empty)
WARNING: rejected rule (localdecisiondirective -> empty) in state 58
